
pub fn mbedtls_aesni_has_support(u32 what) -> i32
{
	static i32 done = 0;
	static u32 c = 0;
	if !done
	{
		__asm("movl  $1, %%eax   \n\t"
			  "cpuid             \n\t"
			  : "=c"(c)
			  :
			  : "eax", "ebx", "edx");
		done = 1;
	}
	return (c & what) != 0;
}

pub fn mbedtls_aesni_crypt_ecb(mbedtls_aes_context * ctx, i32 mode, const u8 input[16], u8 output[16]) -> i32
{
	__asm("movdqu    (%3), %%xmm0    \n\t"
		  "movdqu    (%1), %%xmm1    \n\t"
		  "pxor      %%xmm1, %%xmm0  \n\t"
		  "add       $16, %1         \n\t"
		  "subl      $1, %0          \n\t"
		  "test      %2, %2          \n\t"
		  "jz        2f              \n\t"
		  "1:                        \n\t"
		  "movdqu    (%1), %%xmm1    \n\t"
		  ".byte 0x66,0x0F,0x38,0xDC,"
		  "0xC1"
		  "\n\t"
		  "add       $16, %1         \n\t"
		  "subl      $1, %0          \n\t"
		  "jnz       1b              \n\t"
		  "movdqu    (%1), %%xmm1    \n\t"
		  ".byte 0x66,0x0F,0x38,0xDD,"
		  "0xC1"
		  "\n\t"
		  "jmp       3f              \n\t"
		  "2:                        \n\t"
		  "movdqu    (%1), %%xmm1    \n\t"
		  ".byte 0x66,0x0F,0x38,0xDE,"
		  "0xC1"
		  "\n\t"
		  "add       $16, %1         \n\t"
		  "subl      $1, %0          \n\t"
		  "jnz       2b              \n\t"
		  "movdqu    (%1), %%xmm1    \n\t"
		  ".byte 0x66,0x0F,0x38,0xDF,"
		  "0xC1"
		  "\n\t"
		  "3:                        \n\t"
		  "movdqu    %%xmm0, (%4)    \n\t"
		  :
		  : "r"(ctx.nr), "r"(ctx.rk), "r"(mode), "r"(input), "r"(output)
		  : "memory", "cc", "xmm0", "xmm1");
	return 0;
}

pub fn mbedtls_aesni_gcm_mult(u8 c[16], const u8 a[16], const u8 b[16])
{
	u8 aa[16], bb[16], cc[16];
	usize i;
	for (i = 0; i < 16; i++)
	{
		aa[i] = a[15 - i];
		bb[i] = b[15 - i];
	}
	__asm("movdqu (%0), %%xmm0               \n\t"
		  "movdqu (%1), %%xmm1               \n\t"
		  "movdqa %%xmm1, %%xmm2             \n\t"
		  "movdqa %%xmm1, %%xmm3             \n\t"
		  "movdqa %%xmm1, %%xmm4             \n\t"
		  ".byte 0x66,0x0F,0x3A,0x44,"
		  "0xC8"
		  ",0x00         \n\t"
		  ".byte 0x66,0x0F,0x3A,0x44,"
		  "0xD0"
		  ",0x11         \n\t"
		  ".byte 0x66,0x0F,0x3A,0x44,"
		  "0xD8"
		  ",0x10         \n\t"
		  ".byte 0x66,0x0F,0x3A,0x44,"
		  "0xE0"
		  ",0x01         \n\t"
		  "pxor %%xmm3, %%xmm4               \n\t"
		  "movdqa %%xmm4, %%xmm3             \n\t"
		  "psrldq $8, %%xmm4                 \n\t"
		  "pslldq $8, %%xmm3                 \n\t"
		  "pxor %%xmm4, %%xmm2               \n\t"
		  "pxor %%xmm3, %%xmm1               \n\t"
		  "movdqa %%xmm1, %%xmm3             \n\t"
		  "movdqa %%xmm2, %%xmm4             \n\t"
		  "psllq $1, %%xmm1                  \n\t"
		  "psllq $1, %%xmm2                  \n\t"
		  "psrlq $63, %%xmm3                 \n\t"
		  "psrlq $63, %%xmm4                 \n\t"
		  "movdqa %%xmm3, %%xmm5             \n\t"
		  "pslldq $8, %%xmm3                 \n\t"
		  "pslldq $8, %%xmm4                 \n\t"
		  "psrldq $8, %%xmm5                 \n\t"
		  "por %%xmm3, %%xmm1                \n\t"
		  "por %%xmm4, %%xmm2                \n\t"
		  "por %%xmm5, %%xmm2                \n\t"
		  "movdqa %%xmm1, %%xmm3             \n\t"
		  "movdqa %%xmm1, %%xmm4             \n\t"
		  "movdqa %%xmm1, %%xmm5             \n\t"
		  "psllq $63, %%xmm3                 \n\t"
		  "psllq $62, %%xmm4                 \n\t"
		  "psllq $57, %%xmm5                 \n\t"
		  "pxor %%xmm4, %%xmm3               \n\t"
		  "pxor %%xmm5, %%xmm3               \n\t"
		  "pslldq $8, %%xmm3                 \n\t"
		  "pxor %%xmm3, %%xmm1               \n\t"
		  "movdqa %%xmm1,%%xmm0              \n\t"
		  "movdqa %%xmm1,%%xmm4              \n\t"
		  "movdqa %%xmm1,%%xmm5              \n\t"
		  "psrlq $1, %%xmm0                  \n\t"
		  "psrlq $2, %%xmm4                  \n\t"
		  "psrlq $7, %%xmm5                  \n\t"
		  "pxor %%xmm4, %%xmm0               \n\t"
		  "pxor %%xmm5, %%xmm0               \n\t"
		  "movdqa %%xmm1,%%xmm3              \n\t"
		  "movdqa %%xmm1,%%xmm4              \n\t"
		  "movdqa %%xmm1,%%xmm5              \n\t"
		  "psllq $63, %%xmm3                 \n\t"
		  "psllq $62, %%xmm4                 \n\t"
		  "psllq $57, %%xmm5                 \n\t"
		  "pxor %%xmm4, %%xmm3               \n\t"
		  "pxor %%xmm5, %%xmm3               \n\t"
		  "psrldq $8, %%xmm3                 \n\t"
		  "pxor %%xmm3, %%xmm0               \n\t"
		  "pxor %%xmm1, %%xmm0               \n\t"
		  "pxor %%xmm2, %%xmm0               \n\t"
		  "movdqu %%xmm0, (%2)               \n\t"
		  :
		  : "r"(aa), "r"(bb), "r"(cc)
		  : "memory", "cc", "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5");
	for (i = 0; i < 16; i++)
	{
		c[i] = cc[15 - i];
	}
	return;
}

pub fn mbedtls_aesni_inverse_key(u8 * invkey, const u8 * fwdkey, i32 nr)
{
	u8 * ik = invkey;
	const u8 * fk = fwdkey + 16 * nr;
	memcpy(ik, fk, 16);
	for (fk -= 16, ik += 16; fk > fwdkey; fk -= 16, ik += 16)
		__asm("movdqu (%0), %%xmm0       \n\t"
			  ".byte 0x66,0x0F,0x38,0xDB,"
			  "0xC0"
			  "\n\t"
			  "movdqu %%xmm0, (%1)       \n\t"
			  :
			  : "r"(fk), "r"(ik)
			  : "memory", "xmm0");
	memcpy(ik, fk, 16);
}

fn aesni_setkey_enc_128(u8 * rk, const u8 * key)
{
	__asm("movdqu (%1), %%xmm0               \n\t"
		  "movdqu %%xmm0, (%0)               \n\t"
		  "jmp 2f                            \n\t"
		  "1:                                \n\t"
		  "pshufd $0xff, %%xmm1, %%xmm1      \n\t"
		  "pxor %%xmm0, %%xmm1               \n\t"
		  "pslldq $4, %%xmm0                 \n\t"
		  "pxor %%xmm0, %%xmm1               \n\t"
		  "pslldq $4, %%xmm0                 \n\t"
		  "pxor %%xmm0, %%xmm1               \n\t"
		  "pslldq $4, %%xmm0                 \n\t"
		  "pxor %%xmm1, %%xmm0               \n\t"
		  "add $16, %0                       \n\t"
		  "movdqu %%xmm0, (%0)               \n\t"
		  "ret                               \n\t"
		  "2:                                \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x01        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x02        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x04        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x08        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x10        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x20        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x40        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x80        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x1B        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xC8"
		  ",0x36        \n\tcall 1b \n\t"
		  :
		  : "r"(rk), "r"(key)
		  : "memory", "cc", "0");
}

fn aesni_setkey_enc_192(u8 * rk, const u8 * key)
{
	__asm("movdqu (%1), %%xmm0   \n\t"
		  "movdqu %%xmm0, (%0)   \n\t"
		  "add $16, %0           \n\t"
		  "movq 16(%1), %%xmm1   \n\t"
		  "movq %%xmm1, (%0)     \n\t"
		  "add $8, %0            \n\t"
		  "jmp 2f                \n\t"
		  "1:                            \n\t"
		  "pshufd $0x55, %%xmm2, %%xmm2  \n\t"
		  "pxor %%xmm0, %%xmm2           \n\t"
		  "pslldq $4, %%xmm0             \n\t"
		  "pxor %%xmm0, %%xmm2           \n\t"
		  "pslldq $4, %%xmm0             \n\t"
		  "pxor %%xmm0, %%xmm2           \n\t"
		  "pslldq $4, %%xmm0             \n\t"
		  "pxor %%xmm2, %%xmm0           \n\t"
		  "movdqu %%xmm0, (%0)           \n\t"
		  "add $16, %0                   \n\t"
		  "pshufd $0xff, %%xmm0, %%xmm2  \n\t"
		  "pxor %%xmm1, %%xmm2           \n\t"
		  "pslldq $4, %%xmm1             \n\t"
		  "pxor %%xmm2, %%xmm1           \n\t"
		  "movq %%xmm1, (%0)             \n\t"
		  "add $8, %0                    \n\t"
		  "ret                           \n\t"
		  "2:                            \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x01    \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x02    \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x04    \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x08    \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x10    \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x20    \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x40    \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x80    \n\tcall 1b \n\t"
		  :
		  : "r"(rk), "r"(key)
		  : "memory", "cc", "0");
}

fn aesni_setkey_enc_256(u8 * rk, const u8 * key)
{
	__asm("movdqu (%1), %%xmm0           \n\t"
		  "movdqu %%xmm0, (%0)           \n\t"
		  "add $16, %0                   \n\t"
		  "movdqu 16(%1), %%xmm1         \n\t"
		  "movdqu %%xmm1, (%0)           \n\t"
		  "jmp 2f                        \n\t"
		  "1:                                \n\t"
		  "pshufd $0xff, %%xmm2, %%xmm2      \n\t"
		  "pxor %%xmm0, %%xmm2               \n\t"
		  "pslldq $4, %%xmm0                 \n\t"
		  "pxor %%xmm0, %%xmm2               \n\t"
		  "pslldq $4, %%xmm0                 \n\t"
		  "pxor %%xmm0, %%xmm2               \n\t"
		  "pslldq $4, %%xmm0                 \n\t"
		  "pxor %%xmm2, %%xmm0               \n\t"
		  "add $16, %0                       \n\t"
		  "movdqu %%xmm0, (%0)               \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD0"
		  ",0x00        \n\t"
		  "pshufd $0xaa, %%xmm2, %%xmm2      \n\t"
		  "pxor %%xmm1, %%xmm2               \n\t"
		  "pslldq $4, %%xmm1                 \n\t"
		  "pxor %%xmm1, %%xmm2               \n\t"
		  "pslldq $4, %%xmm1                 \n\t"
		  "pxor %%xmm1, %%xmm2               \n\t"
		  "pslldq $4, %%xmm1                 \n\t"
		  "pxor %%xmm2, %%xmm1               \n\t"
		  "add $16, %0                       \n\t"
		  "movdqu %%xmm1, (%0)               \n\t"
		  "ret                               \n\t"
		  "2:                                \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x01        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x02        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x04        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x08        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x10        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x20        \n\tcall 1b \n\t"
		  ".byte 0x66,0x0F,0x3A,0xDF,"
		  "0xD1"
		  ",0x40        \n\tcall 1b \n\t"
		  :
		  : "r"(rk), "r"(key)
		  : "memory", "cc", "0");
}

pub fn mbedtls_aesni_setkey_enc(u8 * rk, const u8 * key, usize bits) -> i32
{
	switch (bits)
	{
		case 128:
		aesni_setkey_enc_128(rk, key);
		break;

		case 192:
		aesni_setkey_enc_192(rk, key);
		break;

		case 256:
		aesni_setkey_enc_256(rk, key);
		break;

	default:
		return -0x0020;
	}
	return 0;
}

pub type mbedtls_mpi_sint = i64;
pub type mbedtls_mpi_uint = u64;
typedef struct
{
	u64 a;
	u64 b;
} u128;
pub type mbedtls_t_udbl = u128;
typedef struct
{
	i32 s;
	usize n;
	mbedtls_mpi_ui32 * p;
} mbedtls_mpi;

typedef struct mbedtls_asn1_buf
{
	i32 tag;
	usize len;
	u8 * p;
} mbedtls_asn1_buf;
typedef struct mbedtls_asn1_bitstring
{
	usize len;
	u8 unused_bits;
	u8 * p;
} mbedtls_asn1_bitstring;
typedef struct mbedtls_asn1_sequence
{
	mbedtls_asn1_buf buf;
	struct mbedtls_asn1_sequence * next;
} mbedtls_asn1_sequence;
typedef struct mbedtls_asn1_named_data
{
	mbedtls_asn1_buf oid;
	mbedtls_asn1_buf val;
	struct mbedtls_asn1_named_data * next;
	u8 next_merged;
} mbedtls_asn1_named_data;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = (u8 *) v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_asn1_get_len(u8 ** p, const u8 * end, usize * len) -> i32
{
	if (end - *p) < 1
	{
		return -0x0060;
	}
	if (**p & 0x80) == 0
	{
		*len = *(*p)++;
	}
	else
	{
		switch (**p & 0x7F)
		{
			case 1:
			if (end - *p) < 2
			{
				return -0x0060;
			}
			*len = (*p)[1];
			(*p) += 2;
			break;

			case 2:
			if (end - *p) < 3
			{
				return -0x0060;
			}
			*len = ((usize)(*p)[1] << 8) | (*p)[2];
			(*p) += 3;
			break;

			case 3:
			if (end - *p) < 4
			{
				return -0x0060;
			}
			*len = ((usize)(*p)[1] << 16) | ((usize)(*p)[2] << 8) | (*p)[3];
			(*p) += 4;
			break;

			case 4:
			if (end - *p) < 5
			{
				return -0x0060;
			}
			*len = ((usize)(*p)[1] << 24) | ((usize)(*p)[2] << 16) | ((usize)(*p)[3] << 8) | (*p)[4];
			(*p) += 5;
			break;

		default:
			return -0x0064;
		}
	}
	if *len > (usize)(end - *p)
	{
		return -0x0060;
	}
	return 0;
}

pub fn mbedtls_asn1_get_tag(u8 ** p, const u8 * end, usize * len, i32 tag) -> i32
{
	if (end - *p) < 1
	{
		return -0x0060;
	}
	if **p != tag
	{
		return -0x0062;
	}
	(*p)++;
	return mbedtls_asn1_get_len(p, end, len);
}

pub fn mbedtls_asn1_get_bool(u8 ** p, const u8 * end, i32 * val) -> i32
{
	i32 ret;
	usize len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x01)) != 0
	{
		return ret;
	}
	if len != 1
	{
		return -0x0064;
	}
	*val = (**p != 0) ? 1 : 0;
	(*p)++;
	return 0;
}

pub fn mbedtls_asn1_get_int(u8 ** p, const u8 * end, i32 * val) -> i32
{
	i32 ret;
	usize len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x02)) != 0
	{
		return ret;
	}
	if len > sizeof(int) || (**p & 0x80) != 0
	{
		return -0x0064;
	}
	*val = 0;
	while (len-- > 0)
	{
		*val = (*val << 8) | **p;
		(*p)++;
	}
	return 0;
}

pub fn mbedtls_asn1_get_mpi(u8 ** p, const u8 * end, mbedtls_mpi * X) -> i32
{
	i32 ret;
	usize len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x02)) != 0
	{
		return ret;
	}
	ret = mbedtls_mpi_read_binary(X, *p, len);
	*p += len;
	return ret;
}

pub fn mbedtls_asn1_get_bitstring(u8 ** p, const u8 * end, mbedtls_asn1_bitstring * bs) -> i32
{
	i32 ret;
	if (ret = mbedtls_asn1_get_tag(p, end, &bs.len, 0x03)) != 0
	{
		return ret;
	}
	if bs.len < 1
	{
		return -0x0060;
	}
	bs.len -= 1;
	bs.unused_bits = **p;
	if bs.unused_bits > 7
	{
		return -0x0064;
	}
	(*p)++;
	bs.p = *p;
	*p += bs.len;
	if *p != end
	{
		return -0x0066;
	}
	return 0;
}

pub fn mbedtls_asn1_get_bitstring_null(u8 ** p, const u8 * end, usize * len) -> i32
{
	i32 ret;
	if (ret = mbedtls_asn1_get_tag(p, end, len, 0x03)) != 0
	{
		return ret;
	}
	if (*len)-- < 2 || *(*p)++ != 0
	{
		return -0x0068;
	}
	return 0;
}

pub fn mbedtls_asn1_get_sequence_of(u8 ** p, const u8 * end, mbedtls_asn1_sequence * cur, i32 tag) -> i32
{
	i32 ret;
	usize len;
	mbedtls_asn1_buf * buf;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return ret;
	}
	if *p + len != end
	{
		return -0x0066;
	}
	while (*p < end)
	{
		buf = &(cur.buf);
		buf.tag = **p;
		if (ret = mbedtls_asn1_get_tag(p, end, &buf.len, tag)) != 0
		{
			return ret;
		}
		buf.p = *p;
		*p += buf.len;
		if *p < end
		{
			cur.next = (mbedtls_asn1_sequence *) mbedtls_calloc(1, sizeof(mbedtls_asn1_sequence));
			if cur.next == NULL
			{
				return -0x006A;
			}
			cur = cur.next;
		}
	}
	cur.next = NULL;
	if *p != end
	{
		return -0x0066;
	}
	return 0;
}

pub fn mbedtls_asn1_get_alg(u8 ** p, const u8 * end, mbedtls_asn1_buf * alg, mbedtls_asn1_buf * params) -> i32
{
	i32 ret;
	usize len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return ret;
	}
	if (end - *p) < 1
	{
		return -0x0060;
	}
	alg.tag = **p;
	end = *p + len;
	if (ret = mbedtls_asn1_get_tag(p, end, &alg.len, 0x06)) != 0
	{
		return ret;
	}
	alg.p = *p;
	*p += alg.len;
	if *p == end
	{
		zeroize(params, sizeof(mbedtls_asn1_buf));
		return 0;
	}
	params.tag = **p;
	(*p)++;
	if (ret = mbedtls_asn1_get_len(p, end, &params.len)) != 0
	{
		return ret;
	}
	params.p = *p;
	*p += params.len;
	if *p != end
	{
		return -0x0066;
	}
	return 0;
}

pub fn mbedtls_asn1_get_alg_null(u8 ** p, const u8 * end, mbedtls_asn1_buf * alg) -> i32
{
	i32 ret;
	mbedtls_asn1_buf params;
	memset(&params, 0, sizeof(mbedtls_asn1_buf));
	if (ret = mbedtls_asn1_get_alg(p, end, alg, &params)) != 0
	{
		return ret;
	}
	if (params.tag != 0x05 && params.tag != 0) || params.len != 0
	{
		return -0x0068;
	}
	return 0;
}

pub fn mbedtls_asn1_free_named_data(mbedtls_asn1_named_data * cur)
{
	if cur == NULL
	{
		return;
	}
	mbedtls_free(cur.oid.p);
	mbedtls_free(cur.val.p);
	zeroize(cur, sizeof(mbedtls_asn1_named_data));
}

pub fn mbedtls_asn1_free_named_data_list(mbedtls_asn1_named_data ** head)
{
	mbedtls_asn1_named_data * cur;
	while ((cur = *head) != NULL)
	{
		*head = cur.next;
		mbedtls_asn1_free_named_data(cur);
		mbedtls_free(cur);
	}
}

pub fn * mbedtls_asn1_find_named_data(mbedtls_asn1_named_data * list, const i8 * oid, usize len) -> mbedtls_asn1_named_data
{
	while (list != NULL)
	{
		if list.oid.len == len && memcmp(list.oid.p, oid, len) == 0
		{
			break;

		}
		list = list.next;
	}
	return list;
}

pub fn mbedtls_asn1_write_len(u8 ** p, u8 * start, usize len) -> i32
{
	if len < 0x80
	{
		if *p - start < 1
		{
			return -0x006C;
		}
		*--(*p) = (i8) len;
		return 1;
	}
	if len <= 0xFF
	{
		if *p - start < 2
		{
			return -0x006C;
		}
		*--(*p) = (i8) len;
		*--(*p) = 0x81;
		return 2;
	}
	if *p - start < 3
	{
		return -0x006C;
	}
	*--(*p) = len % 256;
	*--(*p) = (len / 256) % 256;
	*--(*p) = 0x82;
	return 3;
}

pub fn mbedtls_asn1_write_tag(u8 ** p, u8 * start, u8 tag) -> i32
{
	if *p - start < 1
	{
		return -0x006C;
	}
	*--(*p) = tag;
	return 1;
}

pub fn mbedtls_asn1_write_raw_buffer(u8 ** p, u8 * start, const u8 * buf, usize size) -> i32
{
	usize len = 0;
	if *p < start || (usize)(*p - start) < size
	{
		return -0x006C;
	}
	len = size;
	(*p) -= len;
	memcpy(*p, buf, len);
	return (int) len;
}

pub fn mbedtls_asn1_write_mpi(u8 ** p, u8 * start, const mbedtls_mpi * X) -> i32
{
	i32 ret;
	usize len = 0;
	len = mbedtls_mpi_size(X);
	if *p < start || (usize)(*p - start) < len
	{
		return -0x006C;
	}
	(*p) -= len;
	do
	{
		if (ret = mbedtls_mpi_write_binary(X, *p, len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if X.s == 1 && **p & 0x80
	{
		if *p - start < 1
		{
			return -0x006C;
		}
		*--(*p) = 0x00;
		len += 1;
	}
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x02)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	ret = (int) len;
cleanup:
	return ret;
}

pub fn mbedtls_asn1_write_null(u8 ** p, u8 * start) -> i32
{
	i32 ret;
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, 0)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x05)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_oid(u8 ** p, u8 * start, const i8 * oid, usize oid_len) -> i32
{
	i32 ret;
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_raw_buffer(p, start, (const u8 *) oid, oid_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x06)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_algorithm_identifier(u8 ** p, u8 * start, const i8 * oid, usize oid_len, usize par_len) -> i32
{
	i32 ret;
	usize len = 0;
	if par_len == 0
		do
		{
			if (ret = mbedtls_asn1_write_null(p, start)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	else
	{
		len += par_len;
	}
	do
	{
		if (ret = mbedtls_asn1_write_oid(p, start, oid, oid_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_bool(u8 ** p, u8 * start, i32 boolean) -> i32
{
	i32 ret;
	usize len = 0;
	if *p - start < 1
	{
		return -0x006C;
	}
	*--(*p) = (boolean) ? 255 : 0;
	len++;
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x01)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_int(u8 ** p, u8 * start, i32 val) -> i32
{
	i32 ret;
	usize len = 0;
	if *p - start < 1
	{
		return -0x006C;
	}
	len += 1;
	*--(*p) = val;
	if val > 0 && **p & 0x80
	{
		if *p - start < 1
		{
			return -0x006C;
		}
		*--(*p) = 0x00;
		len += 1;
	}
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x02)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_printable_string(u8 ** p, u8 * start, const i8 * text, usize text_len) -> i32
{
	i32 ret;
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_raw_buffer(p, start, (const u8 *) text, text_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x13)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_ia5_string(u8 ** p, u8 * start, const i8 * text, usize text_len) -> i32
{
	i32 ret;
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_raw_buffer(p, start, (const u8 *) text, text_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x16)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_bitstring(u8 ** p, u8 * start, const u8 * buf, usize bits) -> i32
{
	i32 ret;
	usize len = 0, size;
	size = (bits / 8) + ((bits % 8) ? 1 : 0);
	if *p < start || (usize)(*p - start) < size + 1
	{
		return -0x006C;
	}
	len = size + 1;
	(*p) -= size;
	memcpy(*p, buf, size);
	*--(*p) = (i8) (size * 8 - bits);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x03)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_asn1_write_octet_string(u8 ** p, u8 * start, const u8 * buf, usize size) -> i32
{
	i32 ret;
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_raw_buffer(p, start, buf, size)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x04)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn * mbedtls_asn1_store_named_data(mbedtls_asn1_named_data ** head, const i8 * oid, usize oid_len, const u8 * val, usize val_len) -> mbedtls_asn1_named_data
{
	mbedtls_asn1_named_data * cur;
	if (cur = mbedtls_asn1_find_named_data(*head, oid, oid_len)) == NULL
	{
		cur = (mbedtls_asn1_named_data *) mbedtls_calloc(1, sizeof(mbedtls_asn1_named_data));
		if cur == NULL
		{
			return NULL;
		}
		cur.oid.len = oid_len;
		cur.oid.p = mbedtls_calloc(1, oid_len);
		if cur.oid.p == NULL
		{
			mbedtls_free(cur);
			return NULL;
		}
		memcpy(cur.oid.p, oid, oid_len);
		cur.val.len = val_len;
		cur.val.p = mbedtls_calloc(1, val_len);
		if cur.val.p == NULL
		{
			mbedtls_free(cur.oid.p);
			mbedtls_free(cur);
			return NULL;
		}
		cur.next = *head;
		*head = cur;
	}
	else
		if cur.val.len < val_len
		{
			void * p = mbedtls_calloc(1, val_len);
			if p == NULL
			{
				return NULL;
			}
			mbedtls_free(cur.val.p);
			cur.val.p = p;
			cur.val.len = val_len;
		}
	if val != NULL
	{
		memcpy(cur.val.p, val, val_len);
	}
	return cur;
}

static const u8 base64_enc_map[64] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
static const u8 base64_dec_map[128] = {127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 62, 127, 127, 127, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 127, 127, 127, 64, 127, 127, 127, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 127, 127, 127, 127, 127, 127, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 127, 127, 127, 127, 127};
pub fn mbedtls_base64_encode(u8 * dst, usize dlen, usize * olen, const u8 * src, usize slen) -> i32
{
	usize i, n;
	i32 C1, C2, C3;
	u8 * p;
	if slen == 0
	{
		*olen = 0;
		return 0;
	}
	n = slen / 3 + (slen % 3 != 0);
	if n > (((usize) -1) - 1) / 4
	{
		*olen = ((usize) -1);
		return -0x002A;
	}
	n *= 4;
	if (dlen < n + 1) || (NULL == dst)
	{
		*olen = n + 1;
		return -0x002A;
	}
	n = (slen / 3) * 3;
	for (i = 0, p = dst; i < n; i += 3)
	{
		C1 = *src++;
		C2 = *src++;
		C3 = *src++;
		*p++ = base64_enc_map[(C1 >> 2) & 0x3F];
		*p++ = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];
		*p++ = base64_enc_map[(((C2 & 15) << 2) + (C3 >> 6)) & 0x3F];
		*p++ = base64_enc_map[C3 & 0x3F];
	}
	if i < slen
	{
		C1 = *src++;
		C2 = ((i + 1) < slen) ? *src++ : 0;
		*p++ = base64_enc_map[(C1 >> 2) & 0x3F];
		*p++ = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];
		if (i + 1) < slen
		{
			*p++ = base64_enc_map[((C2 & 15) << 2) & 0x3F];
		}
		else
		{
			*p++ = '=';
		}
		*p++ = '=';
	}
	*olen = p - dst;
	*p = 0;
	return 0;
}

pub fn mbedtls_base64_decode(u8 * dst, usize dlen, usize * olen, const u8 * src, usize slen) -> i32
{
	usize i, n;
	u32 j, x;
	u8 * p;
	for (i = n = j = 0; i < slen; i++)
	{
		x = 0;
		while (i < slen && src[i] == ' ')
		{
			++i;
			++x;
		}
		if i == slen
		{
			break;

		}
		if (slen - i) >= 2 && src[i] == '\r' && src[i + 1] == '\n'
		{
			continue;
		}
		if src[i] == '\n'
		{
			continue;
		}
		if x != 0
		{
			return -0x002C;
		}
		if src[i] == '=' && ++j > 2
		{
			return -0x002C;
		}
		if src[i] > 127 || base64_dec_map[src[i]] == 127
		{
			return -0x002C;
		}
		if base64_dec_map[src[i]] < 64 && j != 0
		{
			return -0x002C;
		}
		n++;
	}
	if n == 0
	{
		*olen = 0;
		return 0;
	}
	n = ((n * 6) + 7) >> 3;
	n -= j;
	if dst == NULL || dlen < n
	{
		*olen = n;
		return -0x002A;
	}
	for (j = 3, n = x = 0, p = dst; i > 0; i--, src++)
	{
		if *src == '\r' || *src == '\n' || *src == ' '
		{
			continue;
		}
		j -= (base64_dec_map[*src] == 64);
		x = (x << 6) | (base64_dec_map[*src] & 0x3F);
		if ++n == 4
		{
			n = 0;
			if j > 0
			{
				*p++ = (i8) (x >> 16);
			}
			if j > 1
			{
				*p++ = (i8) (x >> 8);
			}
			if j > 2
			{
				*p++ = (i8) (x);
			}
		}
	}
	*olen = p - dst;
	return 0;
}

static const u8 base64_test_dec[64] = {0x24, 0x48, 0x6E, 0x56, 0x87, 0x62, 0x5A, 0xBD, 0xBF, 0x17, 0xD9, 0xA2, 0xC4, 0x17, 0x1A, 0x01, 0x94, 0xED, 0x8F, 0x1E, 0x11, 0xB3, 0xD7, 0x09, 0x0C, 0xB6, 0xE9, 0x10, 0x6F, 0x22, 0xEE, 0x13, 0xCA, 0xB3, 0x07, 0x05, 0x76, 0xC9, 0xFA, 0x31, 0x6C, 0x08, 0x34, 0xFF, 0x8D, 0xC2, 0x6C, 0x38, 0x00, 0x43, 0xE9, 0x54, 0x97, 0xAF, 0x50, 0x4B, 0xD1, 0x41, 0xBA, 0x95, 0x31, 0x5A, 0x0B, 0x97};
static const u8 base64_test_enc[] = "JEhuVodiWr2/F9mixBcaAZTtjx4Rs9cJDLbpEG8i7hPK"
		"swcFdsn6MWwINP+Nwmw4AEPpVJevUEvRQbqVMVoLlw==";
pub fn mbedtls_base64_self_test(i32 verbose) -> i32
{
	usize len;
	const u8 * src;
	u8 buffer[128];
	if verbose != 0
	{
		printf("  Base64 encoding test: ");
	}
	src = base64_test_dec;
	if mbedtls_base64_encode(buffer, sizeof(buffer), &len, src, 64) != 0 || memcmp(base64_test_enc, buffer, 88) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if verbose != 0
	{
		printf("passed\n  Base64 decoding test: ");
	}
	src = base64_test_enc;
	if mbedtls_base64_decode(buffer, sizeof(buffer), &len, src, 88) != 0 || memcmp(base64_test_dec, buffer, 64) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if verbose != 0
	{
		printf("passed\n\n");
	}
	return 0;
}

fn mbedtls_mpi_zeroize(mbedtls_mpi_ui32 * v, usize n)
{
	volatile mbedtls_mpi_ui32 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_mpi_init(mbedtls_mpi * X)
{
	if X == NULL
	{
		return;
	}
	X.s = 1;
	X.n = 0;
	X.p = NULL;
}

pub fn mbedtls_mpi_free(mbedtls_mpi * X)
{
	if X == NULL
	{
		return;
	}
	if X.p != NULL
	{
		mbedtls_mpi_zeroize(X.p, X.n);
		mbedtls_free(X.p);
	}
	X.s = 1;
	X.n = 0;
	X.p = NULL;
}

pub fn mbedtls_mpi_grow(mbedtls_mpi * X, usize nblimbs) -> i32
{
	mbedtls_mpi_ui32 * p;
	if nblimbs > 10000
	{
		return -0x0010;
	}
	if X.n < nblimbs
	{
		if (p = (mbedtls_mpi_ui32 *) mbedtls_calloc(nblimbs, (sizeof(mbedtls_mpi_uint)))) == NULL
		{
			return -0x0010;
		}
		if X.p != NULL
		{
			memcpy(p, X.p, X.n * (sizeof(mbedtls_mpi_uint)));
			mbedtls_mpi_zeroize(X.p, X.n);
			mbedtls_free(X.p);
		}
		X.n = nblimbs;
		X.p = p;
	}
	return 0;
}

pub fn mbedtls_mpi_shrink(mbedtls_mpi * X, usize nblimbs) -> i32
{
	mbedtls_mpi_ui32 * p;
	usize i;
	if X.n <= nblimbs
	{
		return mbedtls_mpi_grow(X, nblimbs);
	}
	for (i = X.n - 1; i > 0; i--)
		if X.p[i] != 0
		{
			break;

		}
	i++;
	if i < nblimbs
	{
		i = nblimbs;
	}
	if (p = (mbedtls_mpi_ui32 *) mbedtls_calloc(i, (sizeof(mbedtls_mpi_uint)))) == NULL
	{
		return -0x0010;
	}
	if X.p != NULL
	{
		memcpy(p, X.p, i * (sizeof(mbedtls_mpi_uint)));
		mbedtls_mpi_zeroize(X.p, X.n);
		mbedtls_free(X.p);
	}
	X.n = i;
	X.p = p;
	return 0;
}

pub fn mbedtls_mpi_copy(mbedtls_mpi * X, const mbedtls_mpi * Y) -> i32
{
	i32 ret;
	usize i;
	if X == Y
	{
		return 0;
	}
	if Y.p == NULL
	{
		mbedtls_mpi_free(X);
		return 0;
	}
	for (i = Y.n - 1; i > 0; i--)
		if Y.p[i] != 0
		{
			break;

		}
	i++;
	X.s = Y.s;
	do
	{
		if (ret = mbedtls_mpi_grow(X, i)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	memset(X.p, 0, X.n * (sizeof(mbedtls_mpi_uint)));
	memcpy(X.p, Y.p, i * (sizeof(mbedtls_mpi_uint)));
cleanup:
	return ret;
}

pub fn mbedtls_mpi_swap(mbedtls_mpi * X, mbedtls_mpi * Y)
{
	mbedtls_mpi T;
	memcpy(&T, X, sizeof(mbedtls_mpi));
	memcpy(X, Y, sizeof(mbedtls_mpi));
	memcpy(Y, &T, sizeof(mbedtls_mpi));
}

pub fn mbedtls_mpi_safe_cond_assign(mbedtls_mpi * X, const mbedtls_mpi * Y, u8 assign) -> i32
{
	i32 ret = 0;
	usize i;
	assign = (assign | (i8) -assign) >> 7;
	do
	{
		if (ret = mbedtls_mpi_grow(X, Y.n)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	X.s = X.s * (1 - assign) + Y.s * assign;
	for (i = 0; i < Y.n; i++)
	{
		X.p[i] = X.p[i] * (1 - assign) + Y.p[i] * assign;
	}
	for (; i < X.n; i++)
	{
		X.p[i] *= (1 - assign);
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_safe_cond_swap(mbedtls_mpi * X, mbedtls_mpi * Y, u8 swap) -> i32
{
	i32 ret, s;
	usize i;
	mbedtls_mpi_ui32 tmp;
	if X == Y
	{
		return 0;
	}
	swap = (swap | (i8) -swap) >> 7;
	do
	{
		if (ret = mbedtls_mpi_grow(X, Y.n)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_grow(Y, X.n)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	s = X.s;
	X.s = X.s * (1 - swap) + Y.s * swap;
	Y.s = Y.s * (1 - swap) + s * swap;
	for (i = 0; i < X.n; i++)
	{
		tmp = X.p[i];
		X.p[i] = X.p[i] * (1 - swap) + Y.p[i] * swap;
		Y.p[i] = Y.p[i] * (1 - swap) + tmp * swap;
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_lset(mbedtls_mpi * X, mbedtls_mpi_si32 z) -> i32
{
	i32 ret;
	do
	{
		if (ret = mbedtls_mpi_grow(X, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	memset(X.p, 0, X.n * (sizeof(mbedtls_mpi_uint)));
	X.p[0] = (z < 0) ? -z : z;
	X.s = (z < 0) ? -1 : 1;
cleanup:
	return ret;
}

pub fn mbedtls_mpi_get_bit(const mbedtls_mpi * X, usize pos) -> i32
{
	if X.n * ((sizeof(mbedtls_mpi_uint)) << 3) <= pos
	{
		return 0;
	}
	return (X.p[pos / ((sizeof(mbedtls_mpi_uint)) << 3)] >> (pos % ((sizeof(mbedtls_mpi_uint)) << 3))) & 0x01;
}

pub fn mbedtls_mpi_set_bit(mbedtls_mpi * X, usize pos, u8 val) -> i32
{
	i32 ret = 0;
	usize off = pos / ((sizeof(mbedtls_mpi_uint)) << 3);
	usize idx = pos % ((sizeof(mbedtls_mpi_uint)) << 3);
	if val != 0 && val != 1
	{
		return -0x0004;
	}
	if X.n * ((sizeof(mbedtls_mpi_uint)) << 3) <= pos
	{
		if val == 0
		{
			return 0;
		}
		do
		{
			if (ret = mbedtls_mpi_grow(X, off + 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	X.p[off] &= ~((mbedtls_mpi_uint) 0x01 << idx);
	X.p[off] |= (mbedtls_mpi_uint) val << idx;
cleanup:
	return ret;
}

pub fn mbedtls_mpi_lsb(const mbedtls_mpi * X) -> usize
{
	usize i, j, count = 0;
	for (i = 0; i < X.n; i++)
		for (j = 0; j < ((sizeof(mbedtls_mpi_uint)) << 3); j++, count++)
			if ((X.p[i] >> j) & 1) != 0
			{
				return count;
			}
	return 0;
}

fn mbedtls_clz(const mbedtls_mpi_ui32 x) -> usize
{
	usize j;
	mbedtls_mpi_ui32 mask = (mbedtls_mpi_uint) 1 << (((sizeof(mbedtls_mpi_uint)) << 3) - 1);
	for (j = 0; j < ((sizeof(mbedtls_mpi_uint)) << 3); j++)
	{
		if x & mask
		{
			break;

		}
		mask >>= 1;
	}
	return j;
}

pub fn mbedtls_mpi_bitlen(const mbedtls_mpi * X) -> usize
{
	usize i, j;
	if X.n == 0
	{
		return 0;
	}
	for (i = X.n - 1; i > 0; i--)
		if X.p[i] != 0
		{
			break;

		}
	j = ((sizeof(mbedtls_mpi_uint)) << 3) - mbedtls_clz(X.p[i]);
	return (i * ((sizeof(mbedtls_mpi_uint)) << 3)) + j;
}

pub fn mbedtls_mpi_size(const mbedtls_mpi * X) -> usize
{
	return (mbedtls_mpi_bitlen(X) + 7) >> 3;
}

fn mpi_get_digit(mbedtls_mpi_ui32 * d, i32 radix, i8 c) -> i32
{
	*d = 255;
	if c >= 0x30 && c <= 0x39
	{
		*d = c - 0x30;
	}
	if c >= 0x41 && c <= 0x46
	{
		*d = c - 0x37;
	}
	if c >= 0x61 && c <= 0x66
	{
		*d = c - 0x57;
	}
	if *d >= (mbedtls_mpi_uint) radix
	{
		return -0x0006;
	}
	return 0;
}

pub fn mbedtls_mpi_read_string(mbedtls_mpi * X, i32 radix, const i8 * s) -> i32
{
	i32 ret;
	usize i, j, slen, n;
	mbedtls_mpi_ui32 d;
	mbedtls_mpi T;
	if radix < 2 || radix > 16
	{
		return -0x0004;
	}
	mbedtls_mpi_init(&T);
	slen = strlen(s);
	if radix == 16
	{
		if slen > ((usize) -1) >> 2
		{
			return -0x0004;
		}
		n = ((slen << 2) / ((sizeof(mbedtls_mpi_uint)) << 3) + ((slen << 2) % ((sizeof(mbedtls_mpi_uint)) << 3) != 0));
		do
		{
			if (ret = mbedtls_mpi_grow(X, n)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_lset(X, 0)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		for (i = slen, j = 0; i > 0; i--, j++)
		{
			if i == 1 && s[i - 1] == '-'
			{
				X.s = -1;
				break;

			}
			do
			{
				if (ret = mpi_get_digit(&d, radix, s[i - 1])) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			X.p[j / (2 * (sizeof(mbedtls_mpi_uint)))] |= d << ((j % (2 * (sizeof(mbedtls_mpi_uint)))) << 2);
		}
	}
	else
	{
		do
		{
			if (ret = mbedtls_mpi_lset(X, 0)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		for (i = 0; i < slen; i++)
		{
			if i == 0 && s[i] == '-'
			{
				X.s = -1;
				continue;
			}
			do
			{
				if (ret = mpi_get_digit(&d, radix, s[i])) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_mul_int(&T, X, radix)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			if X.s == 1
			{
				do
				{
					if (ret = mbedtls_mpi_add_int(X, &T, d)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
			}
			else
			{
				do
				{
					if (ret = mbedtls_mpi_sub_int(X, &T, d)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
			}
		}
	}
cleanup:
	mbedtls_mpi_free(&T);
	return ret;
}

fn mpi_write_hlp(mbedtls_mpi * X, i32 radix, i8 ** p) -> i32
{
	i32 ret;
	mbedtls_mpi_ui32 r;
	if radix < 2 || radix > 16
	{
		return -0x0004;
	}
	do
	{
		if (ret = mbedtls_mpi_mod_int(&r, X, radix)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_div_int(X, NULL, X, radix)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_int(X, 0) != 0
		do
		{
			if (ret = mpi_write_hlp(X, radix, p)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	if r < 10
	{
		*(*p)++ = (char) (r + 0x30);
	}
	else
	{
		*(*p)++ = (char) (r + 0x37);
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_write_string(const mbedtls_mpi * X, i32 radix, i8 * buf, usize buflen, usize * olen) -> i32
{
	i32 ret = 0;
	usize n;
	i8 * p;
	mbedtls_mpi T;
	if radix < 2 || radix > 16
	{
		return -0x0004;
	}
	n = mbedtls_mpi_bitlen(X);
	if radix >= 4
	{
		n >>= 1;
	}
	if radix >= 16
	{
		n >>= 1;
	}
	n += 3;
	if buflen < n
	{
		*olen = n;
		return -0x0008;
	}
	p = buf;
	mbedtls_mpi_init(&T);
	if X.s == -1
	{
		*p++ = '-';
	}
	if radix == 16
	{
		i32 c;
		usize i, j, k;
		for (i = X.n, k = 0; i > 0; i--)
		{
			for (j = (sizeof(mbedtls_mpi_uint)); j > 0; j--)
			{
				c = (X.p[i - 1] >> ((j - 1) << 3)) & 0xFF;
				if c == 0 && k == 0 && (i + j) != 2
				{
					continue;
				}
				*(p++) = "0123456789ABCDEF"[c / 16];
				*(p++) = "0123456789ABCDEF"[c % 16];
				k = 1;
			}
		}
	}
	else
	{
		do
		{
			if (ret = mbedtls_mpi_copy(&T, X)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if T.s == -1
		{
			T.s = 1;
		}
		do
		{
			if (ret = mpi_write_hlp(&T, radix, &p)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	*p++ = '\0';
	*olen = p - buf;
cleanup:
	mbedtls_mpi_free(&T);
	return ret;
}

pub fn mbedtls_mpi_read_file(mbedtls_mpi * X, i32 radix, FILE * fin) -> i32
{
	mbedtls_mpi_ui32 d;
	usize slen;
	i8 * p;
	i8 s[((((100 * (8 * 1024)) + 332 - 1) / 332) + 10 + 6)];
	memset(s, 0, sizeof(s));
	if fgets(s, sizeof(s) - 1, fin) == NULL
	{
		return -0x0002;
	}
	slen = strlen(s);
	if slen == sizeof(s) - 2
	{
		return -0x0008;
	}
	if s[slen - 1] == '\n'
	{
		slen--;
		s[slen] = '\0';
	}
	if s[slen - 1] == '\r'
	{
		slen--;
		s[slen] = '\0';
	}
	p = s + slen;
	while (--p >= s)
		if mpi_get_digit(&d, radix, *p) != 0
		{
			break;

		}
	return mbedtls_mpi_read_string(X, radix, p + 1);
}

pub fn mbedtls_mpi_write_file(const i8 * p, const mbedtls_mpi * X, i32 radix, FILE * fout) -> i32
{
	i32 ret;
	usize n, slen, plen;
	i8 s[((((100 * (8 * 1024)) + 332 - 1) / 332) + 10 + 6)];
	memset(s, 0, sizeof(s));
	do
	{
		if (ret = mbedtls_mpi_write_string(X, radix, s, sizeof(s) - 2, &n)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if p == NULL
	{
		p = "";
	}
	plen = strlen(p);
	slen = strlen(s);
	s[slen++] = '\r';
	s[slen++] = '\n';
	if fout != NULL
	{
		if fwrite(p, 1, plen, fout) != plen || fwrite(s, 1, slen, fout) != slen
		{
			return -0x0002;
		}
	}
	else
	{
		printf("%s%s", p, s);
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_read_binary(mbedtls_mpi * X, const u8 * buf, usize buflen) -> i32
{
	i32 ret;
	usize i, j, n;
	for (n = 0; n < buflen; n++)
		if buf[n] != 0
		{
			break;

		}
	do
	{
		if (ret = mbedtls_mpi_grow(X, ((buflen - n) / (sizeof(mbedtls_mpi_uint)) + ((buflen - n) % (sizeof(mbedtls_mpi_uint)) != 0)))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(X, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i = buflen, j = 0; i > n; i--, j++)
	{
		X.p[j / (sizeof(mbedtls_mpi_uint))] |= ((mbedtls_mpi_uint) buf[i - 1]) << ((j % (sizeof(mbedtls_mpi_uint))) << 3);
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_write_binary(const mbedtls_mpi * X, u8 * buf, usize buflen) -> i32
{
	usize i, j, n;
	n = mbedtls_mpi_size(X);
	if buflen < n
	{
		return -0x0008;
	}
	memset(buf, 0, buflen);
	for (i = buflen - 1, j = 0; n > 0; i--, j++, n--)
	{
		buf[i] = (i8) (X.p[j / (sizeof(mbedtls_mpi_uint))] >> ((j % (sizeof(mbedtls_mpi_uint))) << 3));
	}
	return 0;
}

pub fn mbedtls_mpi_shift_l(mbedtls_mpi * X, usize count) -> i32
{
	i32 ret;
	usize i, v0, t1;
	mbedtls_mpi_ui32 r0 = 0, r1;
	v0 = count / (((sizeof(mbedtls_mpi_uint)) << 3));
	t1 = count & (((sizeof(mbedtls_mpi_uint)) << 3) - 1);
	i = mbedtls_mpi_bitlen(X) + count;
	if X.n * ((sizeof(mbedtls_mpi_uint)) << 3) < i
		do
		{
			if (ret = mbedtls_mpi_grow(X, ((i) / ((sizeof(mbedtls_mpi_uint)) << 3) + ((i) % ((sizeof(mbedtls_mpi_uint)) << 3) != 0)))) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	ret = 0;
	if v0 > 0
	{
		for (i = X.n; i > v0; i--)
		{
			X.p[i - 1] = X.p[i - v0 - 1];
		}
		for (; i > 0; i--)
		{
			X.p[i - 1] = 0;
		}
	}
	if t1 > 0
	{
		for (i = v0; i < X.n; i++)
		{
			r1 = X.p[i] >> (((sizeof(mbedtls_mpi_uint)) << 3) - t1);
			X.p[i] <<= t1;
			X.p[i] |= r0;
			r0 = r1;
		}
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_shift_r(mbedtls_mpi * X, usize count) -> i32
{
	usize i, v0, v1;
	mbedtls_mpi_ui32 r0 = 0, r1;
	v0 = count / ((sizeof(mbedtls_mpi_uint)) << 3);
	v1 = count & (((sizeof(mbedtls_mpi_uint)) << 3) - 1);
	if v0 > X.n || (v0 == X.n && v1 > 0)
	{
		return mbedtls_mpi_lset(X, 0);
	}
	if v0 > 0
	{
		for (i = 0; i < X.n - v0; i++)
		{
			X.p[i] = X.p[i + v0];
		}
		for (; i < X.n; i++)
		{
			X.p[i] = 0;
		}
	}
	if v1 > 0
	{
		for (i = X.n; i > 0; i--)
		{
			r1 = X.p[i - 1] << (((sizeof(mbedtls_mpi_uint)) << 3) - v1);
			X.p[i - 1] >>= v1;
			X.p[i - 1] |= r0;
			r0 = r1;
		}
	}
	return 0;
}

pub fn mbedtls_mpi_cmp_abs(const mbedtls_mpi * X, const mbedtls_mpi * Y) -> i32
{
	usize i, j;
	for (i = X.n; i > 0; i--)
		if X.p[i - 1] != 0
		{
			break;

		}
	for (j = Y.n; j > 0; j--)
		if Y.p[j - 1] != 0
		{
			break;

		}
	if i == 0 && j == 0
	{
		return 0;
	}
	if i > j
	{
		return 1;
	}
	if j > i
	{
		return -1;
	}
	for (; i > 0; i--)
	{
		if X.p[i - 1] > Y.p[i - 1]
		{
			return 1;
		}
		if X.p[i - 1] < Y.p[i - 1]
		{
			return -1;
		}
	}
	return 0;
}

pub fn mbedtls_mpi_cmp_mpi(const mbedtls_mpi * X, const mbedtls_mpi * Y) -> i32
{
	usize i, j;
	for (i = X.n; i > 0; i--)
		if X.p[i - 1] != 0
		{
			break;

		}
	for (j = Y.n; j > 0; j--)
		if Y.p[j - 1] != 0
		{
			break;

		}
	if i == 0 && j == 0
	{
		return 0;
	}
	if i > j
	{
		return X.s;
	}
	if j > i
	{
		return -Y.s;
	}
	if X.s > 0 && Y.s < 0
	{
		return 1;
	}
	if Y.s > 0 && X.s < 0
	{
		return -1;
	}
	for (; i > 0; i--)
	{
		if X.p[i - 1] > Y.p[i - 1]
		{
			return X.s;
		}
		if X.p[i - 1] < Y.p[i - 1]
		{
			return -X.s;
		}
	}
	return 0;
}

pub fn mbedtls_mpi_cmp_int(const mbedtls_mpi * X, mbedtls_mpi_si32 z) -> i32
{
	mbedtls_mpi Y;
	mbedtls_mpi_ui32 p[1];
	*p = (z < 0) ? -z : z;
	Y.s = (z < 0) ? -1 : 1;
	Y.n = 1;
	Y.p = p;
	return mbedtls_mpi_cmp_mpi(X, &Y);
}

pub fn mbedtls_mpi_add_abs(mbedtls_mpi * X, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	i32 ret;
	usize i, j;
	mbedtls_mpi_ui32 *o, *p, c, tmp;
	if X == B
	{
		const mbedtls_mpi * T = A;
		A = X;
		B = T;
	}
	if X != A
		do
		{
			if (ret = mbedtls_mpi_copy(X, A)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	X.s = 1;
	for (j = B.n; j > 0; j--)
		if B.p[j - 1] != 0
		{
			break;

		}
	do
	{
		if (ret = mbedtls_mpi_grow(X, j)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	o = B.p;
	p = X.p;
	c = 0;
	for (i = 0; i < j; i++, o++, p++)
	{
		tmp = *o;
		*p += c;
		c = (*p < c);
		*p += tmp;
		c += (*p < tmp);
	}
	while (c != 0)
	{
		if i >= X.n
		{
			do
			{
				if (ret = mbedtls_mpi_grow(X, i + 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			p = X.p + i;
		}
		*p += c;
		c = (*p < c);
		i++;
		p++;
	}
cleanup:
	return ret;
}

fn mpi_sub_hlp(usize n, mbedtls_mpi_ui32 * s, mbedtls_mpi_ui32 * d)
{
	usize i;
	mbedtls_mpi_ui32 c, z;
	for (i = c = 0; i < n; i++, s++, d++)
	{
		z = (*d < c);
		*d -= c;
		c = (*d < *s) + z;
		*d -= *s;
	}
	while (c != 0)
	{
		z = (*d < c);
		*d -= c;
		c = z;
		i++;
		d++;
	}
}

pub fn mbedtls_mpi_sub_abs(mbedtls_mpi * X, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	mbedtls_mpi TB;
	i32 ret;
	usize n;
	if mbedtls_mpi_cmp_abs(A, B) < 0
	{
		return -0x000A;
	}
	mbedtls_mpi_init(&TB);
	if X == B
	{
		do
		{
			if (ret = mbedtls_mpi_copy(&TB, B)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		B = &TB;
	}
	if X != A
		do
		{
			if (ret = mbedtls_mpi_copy(X, A)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	X.s = 1;
	ret = 0;
	for (n = B.n; n > 0; n--)
		if B.p[n - 1] != 0
		{
			break;

		}
	mpi_sub_hlp(n, B.p, X.p);
cleanup:
	mbedtls_mpi_free(&TB);
	return ret;
}

pub fn mbedtls_mpi_add_mpi(mbedtls_mpi * X, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	i32 ret, s = A.s;
	if A.s * B.s < 0
	{
		if mbedtls_mpi_cmp_abs(A, B) >= 0
		{
			do
			{
				if (ret = mbedtls_mpi_sub_abs(X, A, B)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			X.s = s;
		}
		else
		{
			do
			{
				if (ret = mbedtls_mpi_sub_abs(X, B, A)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			X.s = -s;
		}
	}
	else
	{
		do
		{
			if (ret = mbedtls_mpi_add_abs(X, A, B)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		X.s = s;
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_sub_mpi(mbedtls_mpi * X, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	i32 ret, s = A.s;
	if A.s * B.s > 0
	{
		if mbedtls_mpi_cmp_abs(A, B) >= 0
		{
			do
			{
				if (ret = mbedtls_mpi_sub_abs(X, A, B)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			X.s = s;
		}
		else
		{
			do
			{
				if (ret = mbedtls_mpi_sub_abs(X, B, A)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			X.s = -s;
		}
	}
	else
	{
		do
		{
			if (ret = mbedtls_mpi_add_abs(X, A, B)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		X.s = s;
	}
cleanup:
	return ret;
}

pub fn mbedtls_mpi_add_int(mbedtls_mpi * X, const mbedtls_mpi * A, mbedtls_mpi_si32 b) -> i32
{
	mbedtls_mpi _B;
	mbedtls_mpi_ui32 p[1];
	p[0] = (b < 0) ? -b : b;
	_B.s = (b < 0) ? -1 : 1;
	_B.n = 1;
	_B.p = p;
	return mbedtls_mpi_add_mpi(X, A, &_B);
}

pub fn mbedtls_mpi_sub_int(mbedtls_mpi * X, const mbedtls_mpi * A, mbedtls_mpi_si32 b) -> i32
{
	mbedtls_mpi _B;
	mbedtls_mpi_ui32 p[1];
	p[0] = (b < 0) ? -b : b;
	_B.s = (b < 0) ? -1 : 1;
	_B.n = 1;
	_B.p = p;
	return mbedtls_mpi_sub_mpi(X, A, &_B);
}

fn mpi_mul_hlp(usize i, mbedtls_mpi_ui32 * s, mbedtls_mpi_ui32 * d, mbedtls_mpi_ui32 b)
{
	mbedtls_mpi_ui32 c = 0, t = 0;
	for (; i >= 16; i -= 16)
	{
		__asm("xorq   %%r8, %%r8          \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  : "+c"(c), "+D"(d), "+S"(s)
			  : "b"(b)
			  : "rax", "rdx", "r8");
	}
	for (; i >= 8; i -= 8)
	{
		__asm("xorq   %%r8, %%r8          \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  : "+c"(c), "+D"(d), "+S"(s)
			  : "b"(b)
			  : "rax", "rdx", "r8");
	}
	for (; i > 0; i--)
	{
		__asm("xorq   %%r8, %%r8          \n\t"
			  "movq   (%%rsi), %%rax      \n\t"
			  "mulq   %%rbx               \n\t"
			  "addq   $8,      %%rsi      \n\t"
			  "addq   %%rcx,   %%rax      \n\t"
			  "movq   %%r8,    %%rcx      \n\t"
			  "adcq   $0,      %%rdx      \n\t"
			  "nop                        \n\t"
			  "addq   %%rax,   (%%rdi)    \n\t"
			  "adcq   %%rdx,   %%rcx      \n\t"
			  "addq   $8,      %%rdi      \n\t"
			  : "+c"(c), "+D"(d), "+S"(s)
			  : "b"(b)
			  : "rax", "rdx", "r8");
	}
	t++;
	do
	{
		*d += c;
		c = (*d < c);
		d++;
	}
	while (c != 0);
}

pub fn mbedtls_mpi_mul_mpi(mbedtls_mpi * X, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	i32 ret;
	usize i, j;
	mbedtls_mpi TA, TB;
	mbedtls_mpi_init(&TA);
	mbedtls_mpi_init(&TB);
	if X == A
	{
		do
		{
			if (ret = mbedtls_mpi_copy(&TA, A)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		A = &TA;
	}
	if X == B
	{
		do
		{
			if (ret = mbedtls_mpi_copy(&TB, B)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		B = &TB;
	}
	for (i = A.n; i > 0; i--)
		if A.p[i - 1] != 0
		{
			break;

		}
	for (j = B.n; j > 0; j--)
		if B.p[j - 1] != 0
		{
			break;

		}
	do
	{
		if (ret = mbedtls_mpi_grow(X, i + j)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(X, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i++; j > 0; j--)
	{
		mpi_mul_hlp(i - 1, A.p, X.p + j - 1, B.p[j - 1]);
	}
	X.s = A.s * B.s;
cleanup:
	mbedtls_mpi_free(&TB);
	mbedtls_mpi_free(&TA);
	return ret;
}

pub fn mbedtls_mpi_mul_int(mbedtls_mpi * X, const mbedtls_mpi * A, mbedtls_mpi_ui32 b) -> i32
{
	mbedtls_mpi _B;
	mbedtls_mpi_ui32 p[1];
	_B.s = 1;
	_B.n = 1;
	_B.p = p;
	p[0] = b;
	return mbedtls_mpi_mul_mpi(X, A, &_B);
}

fn mbedtls_int_div_int(mbedtls_mpi_ui32 u1, mbedtls_mpi_ui32 u0, mbedtls_mpi_ui32 d, mbedtls_mpi_ui32 * r) -> mbedtls_mpi_ui32
{
	mbedtls_t_udbl dividend, quotient;
	if 0 == d || u1 >= d
	{
		if r != NULL
		{
			*r = ~0;
		}
		return ~0;
	}
	dividend = (mbedtls_t_udbl) u1 << ((sizeof(mbedtls_mpi_uint)) << 3);
	dividend |= (mbedtls_t_udbl) u0;
	quotient = dividend / d;
	if quotient > ((mbedtls_t_udbl) 1 << ((sizeof(mbedtls_mpi_uint)) << 3)) - 1
	{
		quotient = ((mbedtls_t_udbl) 1 << ((sizeof(mbedtls_mpi_uint)) << 3)) - 1;
	}
	if r != NULL
	{
		*r = (mbedtls_mpi_uint)(dividend - (quotient * d));
	}
	return (mbedtls_mpi_uint) quotient;
}

pub fn mbedtls_mpi_div_mpi(mbedtls_mpi * Q, mbedtls_mpi * R, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	i32 ret;
	usize i, n, t, k;
	mbedtls_mpi X, Y, Z, T1, T2;
	if mbedtls_mpi_cmp_int(B, 0) == 0
	{
		return -0x000C;
	}
	mbedtls_mpi_init(&X);
	mbedtls_mpi_init(&Y);
	mbedtls_mpi_init(&Z);
	mbedtls_mpi_init(&T1);
	mbedtls_mpi_init(&T2);
	if mbedtls_mpi_cmp_abs(A, B) < 0
	{
		if Q != NULL
			do
			{
				if (ret = mbedtls_mpi_lset(Q, 0)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		if R != NULL
			do
			{
				if (ret = mbedtls_mpi_copy(R, A)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		return 0;
	}
	do
	{
		if (ret = mbedtls_mpi_copy(&X, A)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&Y, B)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	X.s = Y.s = 1;
	do
	{
		if (ret = mbedtls_mpi_grow(&Z, A.n + 2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&Z, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_grow(&T1, 2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_grow(&T2, 3)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	k = mbedtls_mpi_bitlen(&Y) % ((sizeof(mbedtls_mpi_uint)) << 3);
	if k < ((sizeof(mbedtls_mpi_uint)) << 3) - 1
	{
		k = ((sizeof(mbedtls_mpi_uint)) << 3) - 1 - k;
		do
		{
			if (ret = mbedtls_mpi_shift_l(&X, k)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_shift_l(&Y, k)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	else
	{
		k = 0;
	}
	n = X.n - 1;
	t = Y.n - 1;
	do
	{
		if (ret = mbedtls_mpi_shift_l(&Y, ((sizeof(mbedtls_mpi_uint)) << 3) * (n - t))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&X, &Y) >= 0)
	{
		Z.p[n - t]++;
		do
		{
			if (ret = mbedtls_mpi_sub_mpi(&X, &X, &Y)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_mpi_shift_r(&Y, ((sizeof(mbedtls_mpi_uint)) << 3) * (n - t))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i = n; i > t; i--)
	{
		if X.p[i] >= Y.p[t]
		{
			Z.p[i - t - 1] = ~0;
		}
		else
		{
			Z.p[i - t - 1] = mbedtls_int_div_int(X.p[i], X.p[i - 1], Y.p[t], NULL);
		}
		Z.p[i - t - 1]++;
		do
		{
			Z.p[i - t - 1]--;
			do
			{
				if (ret = mbedtls_mpi_lset(&T1, 0)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			T1.p[0] = (t < 1) ? 0 : Y.p[t - 1];
			T1.p[1] = Y.p[t];
			do
			{
				if (ret = mbedtls_mpi_mul_int(&T1, &T1, Z.p[i - t - 1])) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_lset(&T2, 0)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			T2.p[0] = (i < 2) ? 0 : X.p[i - 2];
			T2.p[1] = (i < 1) ? 0 : X.p[i - 1];
			T2.p[2] = X.p[i];
		}
		while (mbedtls_mpi_cmp_mpi(&T1, &T2) > 0);
		do
		{
			if (ret = mbedtls_mpi_mul_int(&T1, &Y, Z.p[i - t - 1])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_shift_l(&T1, ((sizeof(mbedtls_mpi_uint)) << 3) * (i - t - 1))) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_sub_mpi(&X, &X, &T1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if mbedtls_mpi_cmp_int(&X, 0) < 0
		{
			do
			{
				if (ret = mbedtls_mpi_copy(&T1, &Y)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_shift_l(&T1, ((sizeof(mbedtls_mpi_uint)) << 3) * (i - t - 1))) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_add_mpi(&X, &X, &T1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			Z.p[i - t - 1]--;
		}
	}
	if Q != NULL
	{
		do
		{
			if (ret = mbedtls_mpi_copy(Q, &Z)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		Q.s = A.s * B.s;
	}
	if R != NULL
	{
		do
		{
			if (ret = mbedtls_mpi_shift_r(&X, k)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		X.s = A.s;
		do
		{
			if (ret = mbedtls_mpi_copy(R, &X)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if mbedtls_mpi_cmp_int(R, 0) == 0
		{
			R.s = 1;
		}
	}
cleanup:
	mbedtls_mpi_free(&X);
	mbedtls_mpi_free(&Y);
	mbedtls_mpi_free(&Z);
	mbedtls_mpi_free(&T1);
	mbedtls_mpi_free(&T2);
	return ret;
}

pub fn mbedtls_mpi_div_int(mbedtls_mpi * Q, mbedtls_mpi * R, const mbedtls_mpi * A, mbedtls_mpi_si32 b) -> i32
{
	mbedtls_mpi _B;
	mbedtls_mpi_ui32 p[1];
	p[0] = (b < 0) ? -b : b;
	_B.s = (b < 0) ? -1 : 1;
	_B.n = 1;
	_B.p = p;
	return mbedtls_mpi_div_mpi(Q, R, A, &_B);
}

pub fn mbedtls_mpi_mod_mpi(mbedtls_mpi * R, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	i32 ret;
	if mbedtls_mpi_cmp_int(B, 0) < 0
	{
		return -0x000A;
	}
	do
	{
		if (ret = mbedtls_mpi_div_mpi(NULL, R, A, B)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_int(R, 0) < 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(R, R, B)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	while (mbedtls_mpi_cmp_mpi(R, B) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_mpi(R, R, B)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
cleanup:
	return ret;
}

pub fn mbedtls_mpi_mod_int(mbedtls_mpi_ui32 * r, const mbedtls_mpi * A, mbedtls_mpi_si32 b) -> i32
{
	usize i;
	mbedtls_mpi_ui32 x, y, z;
	if b == 0
	{
		return -0x000C;
	}
	if b < 0
	{
		return -0x000A;
	}
	if b == 1
	{
		*r = 0;
		return 0;
	}
	if b == 2
	{
		*r = A.p[0] & 1;
		return 0;
	}
	for (i = A.n, y = 0; i > 0; i--)
	{
		x = A.p[i - 1];
		y = (y << ((sizeof(mbedtls_mpi_uint)) << 2)) | (x >> ((sizeof(mbedtls_mpi_uint)) << 2));
		z = y / b;
		y -= z * b;
		x <<= ((sizeof(mbedtls_mpi_uint)) << 2);
		y = (y << ((sizeof(mbedtls_mpi_uint)) << 2)) | (x >> ((sizeof(mbedtls_mpi_uint)) << 2));
		z = y / b;
		y -= z * b;
	}
	if A.s < 0 && y != 0
	{
		y = b - y;
	}
	*r = y;
	return 0;
}

fn mpi_montg_init(mbedtls_mpi_ui32 * mm, const mbedtls_mpi * N)
{
	mbedtls_mpi_ui32 x, m0 = N.p[0];
	u32 i;
	x = m0;
	x += ((m0 + 2) & 4) << 1;
	for (i = ((sizeof(mbedtls_mpi_uint)) << 3); i >= 8; i /= 2)
	{
		x *= (2 - (m0 * x));
	}
	*mm = ~x + 1;
}

fn mpi_montmul(mbedtls_mpi * A, const mbedtls_mpi * B, const mbedtls_mpi * N, mbedtls_mpi_ui32 mm, const mbedtls_mpi * T) -> i32
{
	usize i, n, m;
	mbedtls_mpi_ui32 u0, u1, *d;
	if T.n < N.n + 1 || T.p == NULL
	{
		return -0x0004;
	}
	memset(T.p, 0, T.n * (sizeof(mbedtls_mpi_uint)));
	d = T.p;
	n = N.n;
	m = (B.n < n) ? B.n : n;
	for (i = 0; i < n; i++)
	{
		u0 = A.p[i];
		u1 = (d[0] + u0 * B.p[0]) * mm;
		mpi_mul_hlp(m, B.p, d, u0);
		mpi_mul_hlp(n, N.p, d, u1);
		*d++ = u0;
		d[n + 1] = 0;
	}
	memcpy(A.p, d, (n + 1) * (sizeof(mbedtls_mpi_uint)));
	if mbedtls_mpi_cmp_abs(A, N) >= 0
	{
		mpi_sub_hlp(n, N.p, A.p);
	}
	else
	{
		mpi_sub_hlp(n, A.p, T.p);
	}
	return 0;
}

fn mpi_montred(mbedtls_mpi * A, const mbedtls_mpi * N, mbedtls_mpi_ui32 mm, const mbedtls_mpi * T) -> i32
{
	mbedtls_mpi_ui32 z = 1;
	mbedtls_mpi U;
	U.n = U.s = (int) z;
	U.p = &z;
	return mpi_montmul(A, &U, N, mm, T);
}

pub fn mbedtls_mpi_exp_mod(mbedtls_mpi * X, const mbedtls_mpi * A, const mbedtls_mpi * E, const mbedtls_mpi * N, mbedtls_mpi * _RR) -> i32
{
	i32 ret;
	usize wbits, wsize, one = 1;
	usize i, j, nblimbs;
	usize bufsize, nbits;
	mbedtls_mpi_ui32 ei, mm, state;
	mbedtls_mpi RR, T, W[2 << 6], Apos;
	i32 neg;
	if mbedtls_mpi_cmp_int(N, 0) < 0 || (N.p[0] & 1) == 0
	{
		return -0x0004;
	}
	if mbedtls_mpi_cmp_int(E, 0) < 0
	{
		return -0x0004;
	}
	mpi_montg_init(&mm, N);
	mbedtls_mpi_init(&RR);
	mbedtls_mpi_init(&T);
	mbedtls_mpi_init(&Apos);
	memset(W, 0, sizeof(W));
	i = mbedtls_mpi_bitlen(E);
	wsize = (i > 671) ? 6 : (i > 239) ? 5 : (i > 79) ? 4 : (i > 23) ? 3 : 1;
	if wsize > 6
	{
		wsize = 6;
	}
	j = N.n + 1;
	do
	{
		if (ret = mbedtls_mpi_grow(X, j)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_grow(&W[1], j)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_grow(&T, j * 2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	neg = (A.s == -1);
	if neg
	{
		do
		{
			if (ret = mbedtls_mpi_copy(&Apos, A)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		Apos.s = 1;
		A = &Apos;
	}
	if _RR == NULL || _RR.p == NULL
	{
		do
		{
			if (ret = mbedtls_mpi_lset(&RR, 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_shift_l(&RR, N.n * 2 * ((sizeof(mbedtls_mpi_uint)) << 3))) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&RR, &RR, N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if _RR != NULL
		{
			memcpy(_RR, &RR, sizeof(mbedtls_mpi));
		}
	}
	else
	{
		memcpy(&RR, _RR, sizeof(mbedtls_mpi));
	}
	if mbedtls_mpi_cmp_mpi(A, N) >= 0
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&W[1], A, N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	else
		do
		{
			if (ret = mbedtls_mpi_copy(&W[1], A)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mpi_montmul(&W[1], &RR, N, mm, &T)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(X, &RR)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mpi_montred(X, N, mm, &T)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if wsize > 1
	{
		j = one << (wsize - 1);
		do
		{
			if (ret = mbedtls_mpi_grow(&W[j], N.n + 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_copy(&W[j], &W[1])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		for (i = 0; i < wsize - 1; i++)
			do
			{
				if (ret = mpi_montmul(&W[j], &W[j], N, mm, &T)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		for (i = j + 1; i < (one << wsize); i++)
		{
			do
			{
				if (ret = mbedtls_mpi_grow(&W[i], N.n + 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_copy(&W[i], &W[i - 1])) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mpi_montmul(&W[i], &W[1], N, mm, &T)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
	}
	nblimbs = E.n;
	bufsize = 0;
	nbits = 0;
	wbits = 0;
	state = 0;
	while (1)
	{
		if bufsize == 0
		{
			if nblimbs == 0
			{
				break;

			}
			nblimbs--;
			bufsize = sizeof(mbedtls_mpi_uint) << 3;
		}
		bufsize--;
		ei = (E.p[nblimbs] >> bufsize) & 1;
		if ei == 0 && state == 0
		{
			continue;
		}
		if ei == 0 && state == 1
		{
			do
			{
				if (ret = mpi_montmul(X, X, N, mm, &T)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			continue;
		}
		state = 2;
		nbits++;
		wbits |= (ei << (wsize - nbits));
		if nbits == wsize
		{
			for (i = 0; i < wsize; i++)
				do
				{
					if (ret = mpi_montmul(X, X, N, mm, &T)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
			do
			{
				if (ret = mpi_montmul(X, &W[wbits], N, mm, &T)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			state--;
			nbits = 0;
			wbits = 0;
		}
	}
	for (i = 0; i < nbits; i++)
	{
		do
		{
			if (ret = mpi_montmul(X, X, N, mm, &T)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		wbits <<= 1;
		if (wbits & (one << wsize)) != 0
			do
			{
				if (ret = mpi_montmul(X, &W[1], N, mm, &T)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
	}
	do
	{
		if (ret = mpi_montred(X, N, mm, &T)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if neg
	{
		X.s = -1;
		do
		{
			if (ret = mbedtls_mpi_add_mpi(X, N, X)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
cleanup:
	for (i = (one << (wsize - 1)); i < (one << wsize); i++)
	{
		mbedtls_mpi_free(&W[i]);
	}
	mbedtls_mpi_free(&W[1]);
	mbedtls_mpi_free(&T);
	mbedtls_mpi_free(&Apos);
	if _RR == NULL || _RR.p == NULL
	{
		mbedtls_mpi_free(&RR);
	}
	return ret;
}

pub fn mbedtls_mpi_gcd(mbedtls_mpi * G, const mbedtls_mpi * A, const mbedtls_mpi * B) -> i32
{
	i32 ret;
	usize lz, lzt;
	mbedtls_mpi TG, TA, TB;
	mbedtls_mpi_init(&TG);
	mbedtls_mpi_init(&TA);
	mbedtls_mpi_init(&TB);
	do
	{
		if (ret = mbedtls_mpi_copy(&TA, A)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&TB, B)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	lz = mbedtls_mpi_lsb(&TA);
	lzt = mbedtls_mpi_lsb(&TB);
	if lzt < lz
	{
		lz = lzt;
	}
	do
	{
		if (ret = mbedtls_mpi_shift_r(&TA, lz)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_shift_r(&TB, lz)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	TA.s = TB.s = 1;
	while (mbedtls_mpi_cmp_int(&TA, 0) != 0)
	{
		do
		{
			if (ret = mbedtls_mpi_shift_r(&TA, mbedtls_mpi_lsb(&TA))) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_shift_r(&TB, mbedtls_mpi_lsb(&TB))) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if mbedtls_mpi_cmp_mpi(&TA, &TB) >= 0
		{
			do
			{
				if (ret = mbedtls_mpi_sub_abs(&TA, &TA, &TB)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_shift_r(&TA, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		else
		{
			do
			{
				if (ret = mbedtls_mpi_sub_abs(&TB, &TB, &TA)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_shift_r(&TB, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
	}
	do
	{
		if (ret = mbedtls_mpi_shift_l(&TB, lz)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(G, &TB)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&TG);
	mbedtls_mpi_free(&TA);
	mbedtls_mpi_free(&TB);
	return ret;
}

pub fn mbedtls_mpi_fill_random(mbedtls_mpi * X, usize size, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	u8 buf[1024];
	if size > 1024
	{
		return -0x0004;
	}
	do
	{
		if (ret = f_rng(p_rng, buf, size)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_read_binary(X, buf, size)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

pub fn mbedtls_mpi_inv_mod(mbedtls_mpi * X, const mbedtls_mpi * A, const mbedtls_mpi * N) -> i32
{
	i32 ret;
	mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
	if mbedtls_mpi_cmp_int(N, 0) <= 0
	{
		return -0x0004;
	}
	mbedtls_mpi_init(&TA);
	mbedtls_mpi_init(&TU);
	mbedtls_mpi_init(&U1);
	mbedtls_mpi_init(&U2);
	mbedtls_mpi_init(&G);
	mbedtls_mpi_init(&TB);
	mbedtls_mpi_init(&TV);
	mbedtls_mpi_init(&V1);
	mbedtls_mpi_init(&V2);
	do
	{
		if (ret = mbedtls_mpi_gcd(&G, A, N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_int(&G, 1) != 0
	{
		ret = -0x000E;
		goto cleanup;
	}
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&TA, A, N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&TU, &TA)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&TB, N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&TV, N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&U1, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&U2, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&V1, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&V2, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		while ((TU.p[0] & 1) == 0)
		{
			do
			{
				if (ret = mbedtls_mpi_shift_r(&TU, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			if (U1.p[0] & 1) != 0 || (U2.p[0] & 1) != 0
			{
				do
				{
					if (ret = mbedtls_mpi_add_mpi(&U1, &U1, &TB)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				do
				{
					if (ret = mbedtls_mpi_sub_mpi(&U2, &U2, &TA)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
			}
			do
			{
				if (ret = mbedtls_mpi_shift_r(&U1, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_shift_r(&U2, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		while ((TV.p[0] & 1) == 0)
		{
			do
			{
				if (ret = mbedtls_mpi_shift_r(&TV, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			if (V1.p[0] & 1) != 0 || (V2.p[0] & 1) != 0
			{
				do
				{
					if (ret = mbedtls_mpi_add_mpi(&V1, &V1, &TB)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				do
				{
					if (ret = mbedtls_mpi_sub_mpi(&V2, &V2, &TA)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
			}
			do
			{
				if (ret = mbedtls_mpi_shift_r(&V1, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_shift_r(&V2, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		if mbedtls_mpi_cmp_mpi(&TU, &TV) >= 0
		{
			do
			{
				if (ret = mbedtls_mpi_sub_mpi(&TU, &TU, &TV)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_sub_mpi(&U1, &U1, &V1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_sub_mpi(&U2, &U2, &V2)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		else
		{
			do
			{
				if (ret = mbedtls_mpi_sub_mpi(&TV, &TV, &TU)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_sub_mpi(&V1, &V1, &U1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_sub_mpi(&V2, &V2, &U2)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
	}
	while (mbedtls_mpi_cmp_int(&TU, 0) != 0);
	while (mbedtls_mpi_cmp_int(&V1, 0) < 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&V1, &V1, N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	while (mbedtls_mpi_cmp_mpi(&V1, N) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_mpi(&V1, &V1, N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(X, &V1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&TA);
	mbedtls_mpi_free(&TU);
	mbedtls_mpi_free(&U1);
	mbedtls_mpi_free(&U2);
	mbedtls_mpi_free(&G);
	mbedtls_mpi_free(&TB);
	mbedtls_mpi_free(&TV);
	mbedtls_mpi_free(&V1);
	mbedtls_mpi_free(&V2);
	return ret;
}

static const i32 small_prime[] = {3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, -103};
fn mpi_check_small_factors(const mbedtls_mpi * X) -> i32
{
	i32 ret = 0;
	usize i;
	mbedtls_mpi_ui32 r;
	if (X.p[0] & 1) == 0
	{
		return -0x000E;
	}
	for (i = 0; small_prime[i] > 0; i++)
	{
		if mbedtls_mpi_cmp_int(X, small_prime[i]) <= 0
		{
			return 1;
		}
		do
		{
			if (ret = mbedtls_mpi_mod_int(&r, X, small_prime[i])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if r == 0
		{
			return -0x000E;
		}
	}
cleanup:
	return ret;
}

fn mpi_miller_rabin(const mbedtls_mpi * X, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret, count;
	usize i, j, k, n, s;
	mbedtls_mpi W, R, T, A, RR;
	mbedtls_mpi_init(&W);
	mbedtls_mpi_init(&R);
	mbedtls_mpi_init(&T);
	mbedtls_mpi_init(&A);
	mbedtls_mpi_init(&RR);
	do
	{
		if (ret = mbedtls_mpi_sub_int(&W, X, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	s = mbedtls_mpi_lsb(&W);
	do
	{
		if (ret = mbedtls_mpi_copy(&R, &W)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_shift_r(&R, s)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	i = mbedtls_mpi_bitlen(X);
	n = ((i >= 1300) ? 2 : (i >= 850) ? 3 : (i >= 650) ? 4 : (i >= 350) ? 8 : (i >= 250) ? 12 : (i >= 150) ? 18 : 27);
	for (i = 0; i < n; i++)
	{
		do
		{
			if (ret = mbedtls_mpi_fill_random(&A, X.n * (sizeof(mbedtls_mpi_uint)), f_rng, p_rng)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if mbedtls_mpi_cmp_mpi(&A, &W) >= 0
		{
			j = mbedtls_mpi_bitlen(&A) - mbedtls_mpi_bitlen(&W);
			do
			{
				if (ret = mbedtls_mpi_shift_r(&A, j + 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		A.p[0] |= 3;
		count = 0;
		do
		{
			do
			{
				if (ret = mbedtls_mpi_fill_random(&A, X.n * (sizeof(mbedtls_mpi_uint)), f_rng, p_rng)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			j = mbedtls_mpi_bitlen(&A);
			k = mbedtls_mpi_bitlen(&W);
			if j > k
			{
				do
				{
					if (ret = mbedtls_mpi_shift_r(&A, j - k)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
			}
			if count++ > 30
			{
				return -0x000E;
			}
		}
		while (mbedtls_mpi_cmp_mpi(&A, &W) >= 0 || mbedtls_mpi_cmp_int(&A, 1) <= 0);
		do
		{
			if (ret = mbedtls_mpi_exp_mod(&A, &A, &R, X, &RR)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if mbedtls_mpi_cmp_mpi(&A, &W) == 0 || mbedtls_mpi_cmp_int(&A, 1) == 0
		{
			continue;
		}
		j = 1;
		while (j < s && mbedtls_mpi_cmp_mpi(&A, &W) != 0)
		{
			do
			{
				if (ret = mbedtls_mpi_mul_mpi(&T, &A, &A)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_mod_mpi(&A, &T, X)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			if mbedtls_mpi_cmp_int(&A, 1) == 0
			{
				break;

			}
			j++;
		}
		if mbedtls_mpi_cmp_mpi(&A, &W) != 0 || mbedtls_mpi_cmp_int(&A, 1) == 0
		{
			ret = -0x000E;
			break;

		}
	}
cleanup:
	mbedtls_mpi_free(&W);
	mbedtls_mpi_free(&R);
	mbedtls_mpi_free(&T);
	mbedtls_mpi_free(&A);
	mbedtls_mpi_free(&RR);
	return ret;
}

pub fn mbedtls_mpi_is_prime(const mbedtls_mpi * X, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_mpi XX;
	XX.s = 1;
	XX.n = X.n;
	XX.p = X.p;
	if mbedtls_mpi_cmp_int(&XX, 0) == 0 || mbedtls_mpi_cmp_int(&XX, 1) == 0
	{
		return -0x000E;
	}
	if mbedtls_mpi_cmp_int(&XX, 2) == 0
	{
		return 0;
	}
	if (ret = mpi_check_small_factors(&XX)) != 0
	{
		if ret == 1
		{
			return 0;
		}
		return ret;
	}
	return mpi_miller_rabin(&XX, f_rng, p_rng);
}

pub fn mbedtls_mpi_gen_prime(mbedtls_mpi * X, usize nbits, i32 dh_flag, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	usize k, n;
	mbedtls_mpi_ui32 r;
	mbedtls_mpi Y;
	if nbits < 3 || nbits > (8 * 1024)
	{
		return -0x0004;
	}
	mbedtls_mpi_init(&Y);
	n = ((nbits) / ((sizeof(mbedtls_mpi_uint)) << 3) + ((nbits) % ((sizeof(mbedtls_mpi_uint)) << 3) != 0));
	do
	{
		if (ret = mbedtls_mpi_fill_random(X, n * (sizeof(mbedtls_mpi_uint)), f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	k = mbedtls_mpi_bitlen(X);
	if k > nbits
		do
		{
			if (ret = mbedtls_mpi_shift_r(X, k - nbits + 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	mbedtls_mpi_set_bit(X, nbits - 1, 1);
	X.p[0] |= 1;
	if dh_flag == 0
	{
		while ((ret = mbedtls_mpi_is_prime(X, f_rng, p_rng)) != 0)
		{
			if ret != -0x000E
			{
				goto cleanup;
			}
			do
			{
				if (ret = mbedtls_mpi_add_int(X, X, 2)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
	}
	else
	{
		X.p[0] |= 2;
		do
		{
			if (ret = mbedtls_mpi_mod_int(&r, X, 3)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if r == 0
			do
			{
				if (ret = mbedtls_mpi_add_int(X, X, 8)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		else
			if r == 1
				do
				{
					if (ret = mbedtls_mpi_add_int(X, X, 4)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
		do
		{
			if (ret = mbedtls_mpi_copy(&Y, X)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_shift_r(&Y, 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		while (1)
		{
			if (ret = mpi_check_small_factors(X)) == 0 && (ret = mpi_check_small_factors(&Y)) == 0 && (ret = mpi_miller_rabin(X, f_rng, p_rng)) == 0 && (ret = mpi_miller_rabin(&Y, f_rng, p_rng)) == 0
			{
				break;

			}
			if ret != -0x000E
			{
				goto cleanup;
			}
			do
			{
				if (ret = mbedtls_mpi_add_int(X, X, 12)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_add_int(&Y, &Y, 6)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
	}
cleanup:
	mbedtls_mpi_free(&Y);
	return ret;
}

static const i32 gcd_pairs[3][3] = {{693, 609, 21}, {1764, 868, 28}, {768454923, 542167814, 1}};
pub fn mbedtls_mpi_self_test(i32 verbose) -> i32
{
	i32 ret, i;
	mbedtls_mpi A, E, N, X, Y, U, V;
	mbedtls_mpi_init(&A);
	mbedtls_mpi_init(&E);
	mbedtls_mpi_init(&N);
	mbedtls_mpi_init(&X);
	mbedtls_mpi_init(&Y);
	mbedtls_mpi_init(&U);
	mbedtls_mpi_init(&V);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&A, 16, "EFE021C2645FD1DC586E69184AF4A31E"
										   "D5F53E93B5F123FA41680867BA110131"
										   "944FE7952E2517337780CB0DB80E61AA"
										   "E7C8DDC6C5C6AADEB34EB38A2F40D5E6")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&E, 16, "B2E7EFD37075B9F03FF989C7C5051C20"
										   "34D2A323810251127E7BF8625A4F49A5"
										   "F3E27F4DA8BD59C47D6DAABA4C8127BD"
										   "5B5C25763222FEFCCFC38B832366C29E")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&N, 16, "0066A198186C18C10B2F5ED9B522752A"
										   "9830B69916E535C8F047518A889A43A5"
										   "94B6BED27A168D31D4A52F88925AA8F5")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&X, &A, &N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&U, 16, "602AB7ECA597A3D6B56FF9829A5E8B85"
										   "9E857EA95A03512E2BAE7391688D264A"
										   "A5663B0341DB9CCFD2C4C5F421FEC814"
										   "8001B72E848A38CAE1C65F78E56ABDEF"
										   "E12D3C039B8A02D6BE593F0BBBDA56F1"
										   "ECF677152EF804370C1A305CAF3B5BF1"
										   "30879B56C61DE584A0F53A2447A51E")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("  MPI test #1 (mul_mpi): ");
	}
	if mbedtls_mpi_cmp_mpi(&X, &U) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	do
	{
		if (ret = mbedtls_mpi_div_mpi(&X, &Y, &A, &N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_read_string(&U, 16, "256567336059E52CAE22925474705F39A94")) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&V, 16, "6613F26162223DF488E9CD48CC132C7A"
										   "0AC93C701B001B092E4E5B9F73BCD27B"
										   "9EE50D0657C77F374E903CDFA4C642")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("  MPI test #2 (div_mpi): ");
	}
	if mbedtls_mpi_cmp_mpi(&X, &U) != 0 || mbedtls_mpi_cmp_mpi(&Y, &V) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&X, &A, &E, &N, NULL)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&U, 16, "36E139AEA55215609D2816998ED020BB"
										   "BD96C37890F65171D948E9BC7CBAA4D9"
										   "325D24D6A3C12710F10A09FA08AB87")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("  MPI test #3 (exp_mod): ");
	}
	if mbedtls_mpi_cmp_mpi(&X, &U) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&X, &A, &N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&U, 16, "003A0AAEDD7E784FC07D8F9EC6E3BFD5"
										   "C3DBA76456363A10869622EAC2DD84EC"
										   "C5B8A74DAC4D09E03B5E0BE779F2DF61")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("  MPI test #4 (inv_mod): ");
	}
	if mbedtls_mpi_cmp_mpi(&X, &U) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  MPI test #5 (simple gcd): ");
	}
	for (i = 0; i < 3; i++)
	{
		do
		{
			if (ret = mbedtls_mpi_lset(&X, gcd_pairs[i][0])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_lset(&Y, gcd_pairs[i][1])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_gcd(&A, &X, &Y)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if mbedtls_mpi_cmp_int(&A, gcd_pairs[i][2]) != 0
		{
			if verbose != 0
			{
				printf("failed at %d\n", i);
			}
			ret = 1;
			goto cleanup;
		}
	}
	if verbose != 0
	{
		printf("passed\n");
	}
cleanup:
	if ret != 0 && verbose != 0
	{
		printf("Unexpected error, return code = %08X\n", ret);
	}
	mbedtls_mpi_free(&A);
	mbedtls_mpi_free(&E);
	mbedtls_mpi_free(&N);
	mbedtls_mpi_free(&X);
	mbedtls_mpi_free(&Y);
	mbedtls_mpi_free(&U);
	mbedtls_mpi_free(&V);
	if verbose != 0
	{
		printf("\n");
	}
	return ret;
}

typedef struct
{
	u32 P[16 + 2];
	u32 S[4][256];
} mbedtls_blowfish_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = (u8 *) v;
	while (n--)
	{
		*p++ = 0;
	}
}

static const u32 P[16 + 2] = {0x243F6A88L, 0x85A308D3L, 0x13198A2EL, 0x03707344L, 0xA4093822L, 0x299F31D0L, 0x082EFA98L, 0xEC4E6C89L, 0x452821E6L, 0x38D01377L, 0xBE5466CFL, 0x34E90C6CL, 0xC0AC29B7L, 0xC97C50DDL, 0x3F84D5B5L, 0xB5470917L, 0x9216D5D9L, 0x8979FB1BL};
static const u32 S[4][256];
fn F(mbedtls_blowfish_context * ctx, u32 x) -> u32
{
	u16 a, b, c, d;
	u32 y;
	d = (i32 short) (x & 0xFF);
	x >>= 8;
	c = (i32 short) (x & 0xFF);
	x >>= 8;
	b = (i32 short) (x & 0xFF);
	x >>= 8;
	a = (i32 short) (x & 0xFF);
	y = ctx.S[0][a] + ctx.S[1][b];
	y = y ^ ctx.S[2][c];
	y = y + ctx.S[3][d];
	return y;
}

fn blowfish_enc(mbedtls_blowfish_context * ctx, u32 * xl, u32 * xr)
{
	u32 Xl, Xr, temp;
	i16 i;
	Xl = *xl;
	Xr = *xr;
	for (i = 0; i < 16; ++i)
	{
		Xl = Xl ^ ctx.P[i];
		Xr = F(ctx, Xl) ^ Xr;
		temp = Xl;
		Xl = Xr;
		Xr = temp;
	}
	temp = Xl;
	Xl = Xr;
	Xr = temp;
	Xr = Xr ^ ctx.P[16];
	Xl = Xl ^ ctx.P[16 + 1];
	*xl = Xl;
	*xr = Xr;
}

fn blowfish_dec(mbedtls_blowfish_context * ctx, u32 * xl, u32 * xr)
{
	u32 Xl, Xr, temp;
	i16 i;
	Xl = *xl;
	Xr = *xr;
	for (i = 16 + 1; i > 1; --i)
	{
		Xl = Xl ^ ctx.P[i];
		Xr = F(ctx, Xl) ^ Xr;
		temp = Xl;
		Xl = Xr;
		Xr = temp;
	}
	temp = Xl;
	Xl = Xr;
	Xr = temp;
	Xr = Xr ^ ctx.P[1];
	Xl = Xl ^ ctx.P[0];
	*xl = Xl;
	*xr = Xr;
}

pub fn mbedtls_blowfish_init(mbedtls_blowfish_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_blowfish_context));
}

pub fn mbedtls_blowfish_free(mbedtls_blowfish_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_blowfish_context));
}

pub fn mbedtls_blowfish_setkey(mbedtls_blowfish_context * ctx, const u8 * key, u32 keybits) -> i32
{
	u32 i, j, k;
	u32 data, datal, datar;
	if keybits < 32 || keybits > 448 || (keybits % 8)
	{
		return -0x0016;
	}
	keybits >>= 3;
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 256; j++)
		{
			ctx.S[i][j] = S[i][j];
		}
	}
	j = 0;
	for (i = 0; i < 16 + 2; ++i)
	{
		data = 0x00000000;
		for (k = 0; k < 4; ++k)
		{
			data = (data << 8) | key[j++];
			if j >= keybits
			{
				j = 0;
			}
		}
		ctx.P[i] = P[i] ^ data;
	}
	datal = 0x00000000;
	datar = 0x00000000;
	for (i = 0; i < 16 + 2; i += 2)
	{
		blowfish_enc(ctx, &datal, &datar);
		ctx.P[i] = datal;
		ctx.P[i + 1] = datar;
	}
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 256; j += 2)
		{
			blowfish_enc(ctx, &datal, &datar);
			ctx.S[i][j] = datal;
			ctx.S[i][j + 1] = datar;
		}
	}
	return 0;
}

pub fn mbedtls_blowfish_crypt_ecb(mbedtls_blowfish_context * ctx, i32 mode, const u8 input[8], u8 output[8]) -> i32
{
	u32 X0, X1;
	{
		(X0) = ((u32)(input)[(0)] << 24) | ((u32)(input)[(0) + 1] << 16) | ((u32)(input)[(0) + 2] << 8) | ((u32)(input)[(0) + 3]);
	};
	{
		(X1) = ((u32)(input)[(4)] << 24) | ((u32)(input)[(4) + 1] << 16) | ((u32)(input)[(4) + 2] << 8) | ((u32)(input)[(4) + 3]);
	};
	if mode == 0
	{
		blowfish_dec(ctx, &X0, &X1);
	}
	else
	{
		blowfish_enc(ctx, &X0, &X1);
	}
	{
		(output)[(0)] = (i8) ((X0) >> 24);
		(output)[(0) + 1] = (i8) ((X0) >> 16);
		(output)[(0) + 2] = (i8) ((X0) >> 8);
		(output)[(0) + 3] = (i8) ((X0));
	};
	{
		(output)[(4)] = (i8) ((X1) >> 24);
		(output)[(4) + 1] = (i8) ((X1) >> 16);
		(output)[(4) + 2] = (i8) ((X1) >> 8);
		(output)[(4) + 3] = (i8) ((X1));
	};
	return 0;
}

pub fn mbedtls_blowfish_crypt_cbc(mbedtls_blowfish_context * ctx, i32 mode, usize length, u8 iv[8], const u8 * input, u8 * output) -> i32
{
	i32 i;
	u8 temp[8];
	if length % 8
	{
		return -0x0018;
	}
	if mode == 0
	{
		while (length > 0)
		{
			memcpy(temp, input, 8);
			mbedtls_blowfish_crypt_ecb(ctx, mode, input, output);
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (output[i] ^ iv[i]);
			}
			memcpy(iv, temp, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	else
	{
		while (length > 0)
		{
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (input[i] ^ iv[i]);
			}
			mbedtls_blowfish_crypt_ecb(ctx, mode, output, output);
			memcpy(iv, output, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	return 0;
}

pub fn mbedtls_blowfish_crypt_cfb64(mbedtls_blowfish_context * ctx, i32 mode, usize length, usize * iv_off, u8 iv[8], const u8 * input, u8 * output) -> i32
{
	i32 c;
	usize n = *iv_off;
	if mode == 0
	{
		while (length--)
		{
			if n == 0
			{
				mbedtls_blowfish_crypt_ecb(ctx, 1, iv, iv);
			}
			c = *input++;
			*output++ = (i8) (c ^ iv[n]);
			iv[n] = (i8) c;
			n = (n + 1) % 8;
		}
	}
	else
	{
		while (length--)
		{
			if n == 0
			{
				mbedtls_blowfish_crypt_ecb(ctx, 1, iv, iv);
			}
			iv[n] = *output++ = (i8) (iv[n] ^ *input++);
			n = (n + 1) % 8;
		}
	}
	*iv_off = n;
	return 0;
}

pub fn mbedtls_blowfish_crypt_ctr(mbedtls_blowfish_context * ctx, usize length, usize * nc_off, u8 nonce_counter[8], u8 stream_block[8], const u8 * input, u8 * output) -> i32
{
	i32 c, i;
	usize n = *nc_off;
	while (length--)
	{
		if n == 0
		{
			mbedtls_blowfish_crypt_ecb(ctx, 1, nonce_counter, stream_block);
			for (i = 8; i > 0; i--)
				if ++nonce_counter[i - 1] != 0
				{
					break;

				}
		}
		c = *input++;
		*output++ = (i8) (c ^ stream_block[n]);
		n = (n + 1) % 8;
	}
	*nc_off = n;
	return 0;
}

static const u32 S[4][256] = {{0xD1310BA6L, 0x98DFB5ACL, 0x2FFD72DBL, 0xD01ADFB7L, 0xB8E1AFEDL, 0x6A267E96L, 0xBA7C9045L, 0xF12C7F99L, 0x24A19947L, 0xB3916CF7L, 0x0801F2E2L, 0x858EFC16L, 0x636920D8L, 0x71574E69L, 0xA458FEA3L, 0xF4933D7EL, 0x0D95748FL, 0x728EB658L, 0x718BCD58L, 0x82154AEEL, 0x7B54A41DL, 0xC25A59B5L, 0x9C30D539L, 0x2AF26013L, 0xC5D1B023L, 0x286085F0L, 0xCA417918L, 0xB8DB38EFL, 0x8E79DCB0L, 0x603A180EL, 0x6C9E0E8BL, 0xB01E8A3EL, 0xD71577C1L, 0xBD314B27L, 0x78AF2FDAL, 0x55605C60L, 0xE65525F3L, 0xAA55AB94L, 0x57489862L, 0x63E81440L, 0x55CA396AL, 0x2AAB10B6L, 0xB4CC5C34L, 0x1141E8CEL, 0xA15486AFL, 0x7C72E993L, 0xB3EE1411L, 0x636FBC2AL, 0x2BA9C55DL, 0x741831F6L, 0xCE5C3E16L, 0x9B87931EL, 0xAFD6BA33L, 0x6C24CF5CL, 0x7A325381L, 0x28958677L, 0x3B8F4898L, 0x6B4BB9AFL, 0xC4BFE81BL, 0x66282193L, 0x61D809CCL, 0xFB21A991L, 0x487CAC60L, 0x5DEC8032L, 0xEF845D5DL, 0xE98575B1L, 0xDC262302L, 0xEB651B88L, 0x23893E81L, 0xD396ACC5L, 0x0F6D6FF3L, 0x83F44239L, 0x2E0B4482L, 0xA4842004L, 0x69C8F04AL, 0x9E1F9B5EL, 0x21C66842L, 0xF6E96C9AL, 0x670C9C61L, 0xABD388F0L, 0x6A51A0D2L, 0xD8542F68L, 0x960FA728L, 0xAB5133A3L, 0x6EEF0B6CL, 0x137A3BE4L, 0xBA3BF050L, 0x7EFB2A98L, 0xA1F1651DL, 0x39AF0176L, 0x66CA593EL, 0x82430E88L, 0x8CEE8619L, 0x456F9FB4L, 0x7D84A5C3L, 0x3B8B5EBEL, 0xE06F75D8L, 0x85C12073L, 0x401A449FL, 0x56C16AA6L, 0x4ED3AA62L, 0x363F7706L, 0x1BFEDF72L, 0x429B023DL, 0x37D0D724L, 0xD00A1248L, 0xDB0FEAD3L, 0x49F1C09BL, 0x075372C9L, 0x80991B7BL, 0x25D479D8L, 0xF6E8DEF7L, 0xE3FE501AL, 0xB6794C3BL, 0x976CE0BDL, 0x04C006BAL, 0xC1A94FB6L, 0x409F60C4L, 0x5E5C9EC2L, 0x196A2463L, 0x68FB6FAFL, 0x3E6C53B5L, 0x1339B2EBL, 0x3B52EC6FL, 0x6DFC511FL, 0x9B30952CL, 0xCC814544L, 0xAF5EBD09L, 0xBEE3D004L, 0xDE334AFDL, 0x660F2807L, 0x192E4BB3L, 0xC0CBA857L, 0x45C8740FL, 0xD20B5F39L, 0xB9D3FBDBL, 0x5579C0BDL, 0x1A60320AL, 0xD6A100C6L, 0x402C7279L, 0x679F25FEL, 0xFB1FA3CCL, 0x8EA5E9F8L, 0xDB3222F8L, 0x3C7516DFL, 0xFD616B15L, 0x2F501EC8L, 0xAD0552ABL, 0x323DB5FAL, 0xFD238760L, 0x53317B48L, 0x3E00DF82L, 0x9E5C57BBL, 0xCA6F8CA0L, 0x1A87562EL, 0xDF1769DBL, 0xD542A8F6L, 0x287EFFC3L, 0xAC6732C6L, 0x8C4F5573L, 0x695B27B0L, 0xBBCA58C8L, 0xE1FFA35DL, 0xB8F011A0L, 0x10FA3D98L, 0xFD2183B8L, 0x4AFCB56CL, 0x2DD1D35BL, 0x9A53E479L, 0xB6F84565L, 0xD28E49BCL, 0x4BFB9790L, 0xE1DDF2DAL, 0xA4CB7E33L, 0x62FB1341L, 0xCEE4C6E8L, 0xEF20CADAL, 0x36774C01L, 0xD07E9EFEL, 0x2BF11FB4L, 0x95DBDA4DL, 0xAE909198L, 0xEAAD8E71L, 0x6B93D5A0L, 0xD08ED1D0L, 0xAFC725E0L, 0x8E3C5B2FL, 0x8E7594B7L, 0x8FF6E2FBL, 0xF2122B64L, 0x8888B812L, 0x900DF01CL, 0x4FAD5EA0L, 0x688FC31CL, 0xD1CFF191L, 0xB3A8C1ADL, 0x2F2F2218L, 0xBE0E1777L, 0xEA752DFEL, 0x8B021FA1L, 0xE5A0CC0FL, 0xB56F74E8L, 0x18ACF3D6L, 0xCE89E299L, 0xB4A84FE0L, 0xFD13E0B7L, 0x7CC43B81L, 0xD2ADA8D9L, 0x165FA266L, 0x80957705L, 0x93CC7314L, 0x211A1477L, 0xE6AD2065L, 0x77B5FA86L, 0xC75442F5L, 0xFB9D35CFL, 0xEBCDAF0CL, 0x7B3E89A0L, 0xD6411BD3L, 0xAE1E7E49L, 0x00250E2DL, 0x2071B35EL, 0x226800BBL, 0x57B8E0AFL, 0x2464369BL, 0xF009B91EL, 0x5563911DL, 0x59DFA6AAL, 0x78C14389L, 0xD95A537FL, 0x207D5BA2L, 0x02E5B9C5L, 0x83260376L, 0x6295CFA9L, 0x11C81968L, 0x4E734A41L, 0xB3472DCAL, 0x7B14A94AL, 0x1B510052L, 0x9A532915L, 0xD60F573FL, 0xBC9BC6E4L, 0x2B60A476L, 0x81E67400L, 0x08BA6FB5L, 0x571BE91FL, 0xF296EC6BL, 0x2A0DD915L, 0xB6636521L, 0xE7B9F9B6L, 0xFF34052EL, 0xC5855664L, 0x53B02D5DL, 0xA99F8FA1L, 0x08BA4799L, 0x6E85076AL}, {0x4B7A70E9L, 0xB5B32944L, 0xDB75092EL, 0xC4192623L, 0xAD6EA6B0L, 0x49A7DF7DL, 0x9CEE60B8L, 0x8FEDB266L, 0xECAA8C71L, 0x699A17FFL, 0x5664526CL, 0xC2B19EE1L, 0x193602A5L, 0x75094C29L, 0xA0591340L, 0xE4183A3EL, 0x3F54989AL, 0x5B429D65L, 0x6B8FE4D6L, 0x99F73FD6L, 0xA1D29C07L, 0xEFE830F5L, 0x4D2D38E6L, 0xF0255DC1L, 0x4CDD2086L, 0x8470EB26L, 0x6382E9C6L, 0x021ECC5EL, 0x09686B3FL, 0x3EBAEFC9L, 0x3C971814L, 0x6B6A70A1L, 0x687F3584L, 0x52A0E286L, 0xB79C5305L, 0xAA500737L, 0x3E07841CL, 0x7FDEAE5CL, 0x8E7D44ECL, 0x5716F2B8L, 0xB03ADA37L, 0xF0500C0DL, 0xF01C1F04L, 0x0200B3FFL, 0xAE0CF51AL, 0x3CB574B2L, 0x25837A58L, 0xDC0921BDL, 0xD19113F9L, 0x7CA92FF6L, 0x94324773L, 0x22F54701L, 0x3AE5E581L, 0x37C2DADCL, 0xC8B57634L, 0x9AF3DDA7L, 0xA9446146L, 0x0FD0030EL, 0xECC8C73EL, 0xA4751E41L, 0xE238CD99L, 0x3BEA0E2FL, 0x3280BBA1L, 0x183EB331L, 0x4E548B38L, 0x4F6DB908L, 0x6F420D03L, 0xF60A04BFL, 0x2CB81290L, 0x24977C79L, 0x5679B072L, 0xBCAF89AFL, 0xDE9A771FL, 0xD9930810L, 0xB38BAE12L, 0xDCCF3F2EL, 0x5512721FL, 0x2E6B7124L, 0x501ADDE6L, 0x9F84CD87L, 0x7A584718L, 0x7408DA17L, 0xBC9F9ABCL, 0xE94B7D8CL, 0xEC7AEC3AL, 0xDB851DFAL, 0x63094366L, 0xC464C3D2L, 0xEF1C1847L, 0x3215D908L, 0xDD433B37L, 0x24C2BA16L, 0x12A14D43L, 0x2A65C451L, 0x50940002L, 0x133AE4DDL, 0x71DFF89EL, 0x10314E55L, 0x81AC77D6L, 0x5F11199BL, 0x043556F1L, 0xD7A3C76BL, 0x3C11183BL, 0x5924A509L, 0xF28FE6EDL, 0x97F1FBFAL, 0x9EBABF2CL, 0x1E153C6EL, 0x86E34570L, 0xEAE96FB1L, 0x860E5E0AL, 0x5A3E2AB3L, 0x771FE71CL, 0x4E3D06FAL, 0x2965DCB9L, 0x99E71D0FL, 0x803E89D6L, 0x5266C825L, 0x2E4CC978L, 0x9C10B36AL, 0xC6150EBAL, 0x94E2EA78L, 0xA5FC3C53L, 0x1E0A2DF4L, 0xF2F74EA7L, 0x361D2B3DL, 0x1939260FL, 0x19C27960L, 0x5223A708L, 0xF71312B6L, 0xEBADFE6EL, 0xEAC31F66L, 0xE3BC4595L, 0xA67BC883L, 0xB17F37D1L, 0x018CFF28L, 0xC332DDEFL, 0xBE6C5AA5L, 0x65582185L, 0x68AB9802L, 0xEECEA50FL, 0xDB2F953BL, 0x2AEF7DADL, 0x5B6E2F84L, 0x1521B628L, 0x29076170L, 0xECDD4775L, 0x619F1510L, 0x13CCA830L, 0xEB61BD96L, 0x0334FE1EL, 0xAA0363CFL, 0xB5735C90L, 0x4C70A239L, 0xD59E9E0BL, 0xCBAADE14L, 0xEECC86BCL, 0x60622CA7L, 0x9CAB5CABL, 0xB2F3846EL, 0x648B1EAFL, 0x19BDF0CAL, 0xA02369B9L, 0x655ABB50L, 0x40685A32L, 0x3C2AB4B3L, 0x319EE9D5L, 0xC021B8F7L, 0x9B540B19L, 0x875FA099L, 0x95F7997EL, 0x623D7DA8L, 0xF837889AL, 0x97E32D77L, 0x11ED935FL, 0x16681281L, 0x0E358829L, 0xC7E61FD6L, 0x96DEDFA1L, 0x7858BA99L, 0x57F584A5L, 0x1B227263L, 0x9B83C3FFL, 0x1AC24696L, 0xCDB30AEBL, 0x532E3054L, 0x8FD948E4L, 0x6DBC3128L, 0x58EBF2EFL, 0x34C6FFEAL, 0xFE28ED61L, 0xEE7C3C73L, 0x5D4A14D9L, 0xE864B7E3L, 0x42105D14L, 0x203E13E0L, 0x45EEE2B6L, 0xA3AAABEAL, 0xDB6C4F15L, 0xFACB4FD0L, 0xC742F442L, 0xEF6ABBB5L, 0x654F3B1DL, 0x41CD2105L, 0xD81E799EL, 0x86854DC7L, 0xE44B476AL, 0x3D816250L, 0xCF62A1F2L, 0x5B8D2646L, 0xFC8883A0L, 0xC1C7B6A3L, 0x7F1524C3L, 0x69CB7492L, 0x47848A0BL, 0x5692B285L, 0x095BBF00L, 0xAD19489DL, 0x1462B174L, 0x23820E00L, 0x58428D2AL, 0x0C55F5EAL, 0x1DADF43EL, 0x233F7061L, 0x3372F092L, 0x8D937E41L, 0xD65FECF1L, 0x6C223BDBL, 0x7CDE3759L, 0xCBEE7460L, 0x4085F2A7L, 0xCE77326EL, 0xA6078084L, 0x19F8509EL, 0xE8EFD855L, 0x61D99735L, 0xA969A7AAL, 0xC50C06C2L, 0x5A04ABFCL, 0x800BCADCL, 0x9E447A2EL, 0xC3453484L, 0xFDD56705L, 0x0E1E9EC9L, 0xDB73DBD3L, 0x105588CDL, 0x675FDA79L, 0xE3674340L, 0xC5C43465L, 0x713E38D8L, 0x3D28F89EL, 0xF16DFF20L, 0x153E21E7L, 0x8FB03D4AL, 0xE6E39F2BL, 0xDB83ADF7L},
	{0xE93D5A68L, 0x948140F7L, 0xF64C261CL, 0x94692934L, 0x411520F7L, 0x7602D4F7L, 0xBCF46B2EL, 0xD4A20068L, 0xD4082471L, 0x3320F46AL, 0x43B7D4B7L, 0x500061AFL, 0x1E39F62EL, 0x97244546L, 0x14214F74L, 0xBF8B8840L, 0x4D95FC1DL, 0x96B591AFL, 0x70F4DDD3L, 0x66A02F45L, 0xBFBC09ECL, 0x03BD9785L, 0x7FAC6DD0L, 0x31CB8504L, 0x96EB27B3L, 0x55FD3941L, 0xDA2547E6L, 0xABCA0A9AL, 0x28507825L, 0x530429F4L, 0x0A2C86DAL, 0xE9B66DFBL, 0x68DC1462L, 0xD7486900L, 0x680EC0A4L, 0x27A18DEEL, 0x4F3FFEA2L, 0xE887AD8CL, 0xB58CE006L, 0x7AF4D6B6L, 0xAACE1E7CL, 0xD3375FECL, 0xCE78A399L, 0x406B2A42L, 0x20FE9E35L, 0xD9F385B9L, 0xEE39D7ABL, 0x3B124E8BL, 0x1DC9FAF7L, 0x4B6D1856L, 0x26A36631L, 0xEAE397B2L, 0x3A6EFA74L, 0xDD5B4332L, 0x6841E7F7L, 0xCA7820FBL, 0xFB0AF54EL, 0xD8FEB397L, 0x454056ACL, 0xBA489527L, 0x55533A3AL, 0x20838D87L, 0xFE6BA9B7L, 0xD096954BL, 0x55A867BCL, 0xA1159A58L, 0xCCA92963L, 0x99E1DB33L, 0xA62A4A56L, 0x3F3125F9L, 0x5EF47E1CL, 0x9029317CL, 0xFDF8E802L, 0x04272F70L, 0x80BB155CL, 0x05282CE3L, 0x95C11548L, 0xE4C66D22L, 0x48C1133FL, 0xC70F86DCL, 0x07F9C9EEL, 0x41041F0FL, 0x404779A4L, 0x5D886E17L, 0x325F51EBL, 0xD59BC0D1L, 0xF2BCC18FL, 0x41113564L, 0x257B7834L, 0x602A9C60L, 0xDFF8E8A3L, 0x1F636C1BL, 0x0E12B4C2L, 0x02E1329EL, 0xAF664FD1L, 0xCAD18115L, 0x6B2395E0L, 0x333E92E1L, 0x3B240B62L, 0xEEBEB922L, 0x85B2A20EL, 0xE6BA0D99L, 0xDE720C8CL, 0x2DA2F728L, 0xD0127845L, 0x95B794FDL, 0x647D0862L, 0xE7CCF5F0L, 0x5449A36FL, 0x877D48FAL, 0xC39DFD27L, 0xF33E8D1EL, 0x0A476341L, 0x992EFF74L, 0x3A6F6EABL, 0xF4F8FD37L, 0xA812DC60L, 0xA1EBDDF8L, 0x991BE14CL, 0xDB6E6B0DL, 0xC67B5510L, 0x6D672C37L, 0x2765D43BL, 0xDCD0E804L, 0xF1290DC7L, 0xCC00FFA3L, 0xB5390F92L, 0x690FED0BL, 0x667B9FFBL, 0xCEDB7D9CL, 0xA091CF0BL, 0xD9155EA3L, 0xBB132F88L, 0x515BAD24L, 0x7B9479BFL, 0x763BD6EBL, 0x37392EB3L, 0xCC115979L, 0x8026E297L, 0xF42E312DL, 0x6842ADA7L, 0xC66A2B3BL, 0x12754CCCL, 0x782EF11CL, 0x6A124237L, 0xB79251E7L, 0x06A1BBE6L, 0x4BFB6350L, 0x1A6B1018L, 0x11CAEDFAL, 0x3D25BDD8L, 0xE2E1C3C9L, 0x44421659L, 0x0A121386L, 0xD90CEC6EL, 0xD5ABEA2AL, 0x64AF674EL, 0xDA86A85FL, 0xBEBFE988L, 0x64E4C3FEL, 0x9DBC8057L, 0xF0F7C086L, 0x60787BF8L, 0x6003604DL, 0xD1FD8346L, 0xF6381FB0L, 0x7745AE04L, 0xD736FCCCL, 0x83426B33L, 0xF01EAB71L, 0xB0804187L, 0x3C005E5FL, 0x77A057BEL, 0xBDE8AE24L, 0x55464299L, 0xBF582E61L, 0x4E58F48FL, 0xF2DDFDA2L, 0xF474EF38L, 0x8789BDC2L, 0x5366F9C3L, 0xC8B38E74L, 0xB475F255L, 0x46FCD9B9L, 0x7AEB2661L, 0x8B1DDF84L, 0x846A0E79L, 0x915F95E2L, 0x466E598EL, 0x20B45770L, 0x8CD55591L, 0xC902DE4CL, 0xB90BACE1L, 0xBB8205D0L, 0x11A86248L, 0x7574A99EL, 0xB77F19B6L, 0xE0A9DC09L, 0x662D09A1L, 0xC4324633L, 0xE85A1F02L, 0x09F0BE8CL, 0x4A99A025L, 0x1D6EFE10L, 0x1AB93D1DL, 0x0BA5A4DFL, 0xA186F20FL, 0x2868F169L, 0xDCB7DA83L, 0x573906FEL, 0xA1E2CE9BL, 0x4FCD7F52L, 0x50115E01L, 0xA70683FAL, 0xA002B5C4L, 0x0DE6D027L, 0x9AF88C27L, 0x773F8641L, 0xC3604C06L, 0x61A806B5L, 0xF0177A28L, 0xC0F586E0L, 0x006058AAL, 0x30DC7D62L, 0x11E69ED7L, 0x2338EA63L, 0x53C2DD94L, 0xC2C21634L, 0xBBCBEE56L, 0x90BCB6DEL, 0xEBFC7DA1L, 0xCE591D76L, 0x6F05E409L, 0x4B7C0188L, 0x39720A3DL, 0x7C927C24L, 0x86E3725FL, 0x724D9DB9L, 0x1AC15BB4L, 0xD39EB8FCL, 0xED545578L, 0x08FCA5B5L, 0xD83D7CD3L, 0x4DAD0FC4L, 0x1E50EF5EL, 0xB161E6F8L, 0xA28514D9L, 0x6C51133CL, 0x6FD5C7E7L, 0x56E14EC4L, 0x362ABFCEL, 0xDDC6C837L, 0xD79A3234L, 0x92638212L, 0x670EFA8EL, 0x406000E0L}, {0x3A39CE37L, 0xD3FAF5CFL, 0xABC27737L, 0x5AC52D1BL, 0x5CB0679EL, 0x4FA33742L, 0xD3822740L, 0x99BC9BBEL, 0xD5118E9DL, 0xBF0F7315L, 0xD62D1C7EL, 0xC700C47BL, 0xB78C1B6BL, 0x21A19045L, 0xB26EB1BEL, 0x6A366EB4L, 0x5748AB2FL, 0xBC946E79L, 0xC6A376D2L, 0x6549C2C8L, 0x530FF8EEL, 0x468DDE7DL, 0xD5730A1DL, 0x4CD04DC6L, 0x2939BBDBL, 0xA9BA4650L, 0xAC9526E8L, 0xBE5EE304L, 0xA1FAD5F0L, 0x6A2D519AL, 0x63EF8CE2L, 0x9A86EE22L, 0xC089C2B8L, 0x43242EF6L, 0xA51E03AAL, 0x9CF2D0A4L, 0x83C061BAL, 0x9BE96A4DL, 0x8FE51550L, 0xBA645BD6L, 0x2826A2F9L, 0xA73A3AE1L, 0x4BA99586L, 0xEF5562E9L, 0xC72FEFD3L, 0xF752F7DAL, 0x3F046F69L, 0x77FA0A59L, 0x80E4A915L, 0x87B08601L, 0x9B09E6ADL, 0x3B3EE593L, 0xE990FD5AL, 0x9E34D797L, 0x2CF0B7D9L, 0x022B8B51L, 0x96D5AC3AL, 0x017DA67DL, 0xD1CF3ED6L, 0x7C7D2D28L, 0x1F9F25CFL, 0xADF2B89BL, 0x5AD6B472L, 0x5A88F54CL, 0xE029AC71L, 0xE019A5E6L, 0x47B0ACFDL, 0xED93FA9BL, 0xE8D3C48DL, 0x283B57CCL, 0xF8D56629L, 0x79132E28L, 0x785F0191L, 0xED756055L, 0xF7960E44L, 0xE3D35E8CL, 0x15056DD4L, 0x88F46DBAL, 0x03A16125L, 0x0564F0BDL, 0xC3EB9E15L, 0x3C9057A2L, 0x97271AECL, 0xA93A072AL, 0x1B3F6D9BL, 0x1E6321F5L, 0xF59C66FBL, 0x26DCF319L, 0x7533D928L, 0xB155FDF5L, 0x03563482L, 0x8ABA3CBBL, 0x28517711L, 0xC20AD9F8L, 0xABCC5167L, 0xCCAD925FL, 0x4DE81751L, 0x3830DC8EL, 0x379D5862L, 0x9320F991L, 0xEA7A90C2L, 0xFB3E7BCEL, 0x5121CE64L, 0x774FBE32L, 0xA8B6E37EL, 0xC3293D46L, 0x48DE5369L, 0x6413E680L, 0xA2AE0810L, 0xDD6DB224L, 0x69852DFDL, 0x09072166L, 0xB39A460AL, 0x6445C0DDL, 0x586CDECFL, 0x1C20C8AEL, 0x5BBEF7DDL, 0x1B588D40L, 0xCCD2017FL, 0x6BB4E3BBL, 0xDDA26A7EL, 0x3A59FF45L, 0x3E350A44L, 0xBCB4CDD5L, 0x72EACEA8L, 0xFA6484BBL, 0x8D6612AEL, 0xBF3C6F47L, 0xD29BE463L, 0x542F5D9EL, 0xAEC2771BL, 0xF64E6370L, 0x740E0D8DL, 0xE75B1357L, 0xF8721671L, 0xAF537D5DL, 0x4040CB08L, 0x4EB4E2CCL, 0x34D2466AL, 0x0115AF84L, 0xE1B00428L, 0x95983A1DL, 0x06B89FB4L, 0xCE6EA048L, 0x6F3F3B82L, 0x3520AB82L, 0x011A1D4BL, 0x277227F8L, 0x611560B1L, 0xE7933FDCL, 0xBB3A792BL, 0x344525BDL, 0xA08839E1L, 0x51CE794BL, 0x2F32C9B7L, 0xA01FBAC9L, 0xE01CC87EL, 0xBCC7D1F6L, 0xCF0111C3L, 0xA1E8AAC7L, 0x1A908749L, 0xD44FBD9AL, 0xD0DADECBL, 0xD50ADA38L, 0x0339C32AL, 0xC6913667L, 0x8DF9317CL, 0xE0B12B4FL, 0xF79E59B7L, 0x43F5BB3AL, 0xF2D519FFL, 0x27D9459CL, 0xBF97222CL, 0x15E6FC2AL, 0x0F91FC71L, 0x9B941525L, 0xFAE59361L, 0xCEB69CEBL, 0xC2A86459L, 0x12BAA8D1L, 0xB6C1075EL, 0xE3056A0CL, 0x10D25065L, 0xCB03A442L, 0xE0EC6E0EL, 0x1698DB3BL, 0x4C98A0BEL, 0x3278E964L, 0x9F1F9532L, 0xE0D392DFL, 0xD3A0342BL, 0x8971F21EL, 0x1B0A7441L, 0x4BA3348CL, 0xC5BE7120L, 0xC37632D8L, 0xDF359F8DL, 0x9B992F2EL, 0xE60B6F47L, 0x0FE3F11DL, 0xE54CDA54L, 0x1EDAD891L, 0xCE6279CFL, 0xCD3E7E6FL, 0x1618B166L, 0xFD2C1D05L, 0x848FD2C5L, 0xF6FB2299L, 0xF523F357L, 0xA6327623L, 0x93A83531L, 0x56CCCD02L, 0xACF08162L, 0x5A75EBB5L, 0x6E163697L, 0x88D273CCL, 0xDE966292L, 0x81B949D0L, 0x4C50901BL, 0x71C65614L, 0xE6C6C7BDL, 0x327A140AL, 0x45E1D006L, 0xC3F27B9AL, 0xC9AA53FDL, 0x62A80F00L, 0xBB25BFE2L, 0x35BDD2F6L, 0x71126905L, 0xB2040222L, 0xB6CBCF7CL, 0xCD769C2BL, 0x53113EC0L, 0x1640E3D3L, 0x38ABBD60L, 0x2547ADF0L, 0xBA38209CL, 0xF746CE76L, 0x77AFA1C5L, 0x20756060L, 0x85CBFE4EL, 0x8AE88DD8L, 0x7AAAF9B0L, 0x4CF9AA7EL, 0x1948C25CL, 0x02FB8A8CL, 0x01C36AE4L, 0xD6EBE1F9L, 0x90D4F869L, 0xA65CDEA0L, 0x3F09252DL, 0xC208E69FL, 0xB74E6132L, 0xCE77E25BL, 0x578FDFE3L, 0x3AC372E6L}
};
typedef struct
{
	i32 nr;
	u32 rk[68];
} mbedtls_camellia_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = (u8 *) v;
	while (n--)
	{
		*p++ = 0;
	}
}

static const u8 SIGMA_CHARS[6][8] = {{0xa0, 0x9e, 0x66, 0x7f, 0x3b, 0xcc, 0x90, 0x8b}, {0xb6, 0x7a, 0xe8, 0x58, 0x4c, 0xaa, 0x73, 0xb2}, {0xc6, 0xef, 0x37, 0x2f, 0xe9, 0x4f, 0x82, 0xbe}, {0x54, 0xff, 0x53, 0xa5, 0xf1, 0xd3, 0x6f, 0x1c}, {0x10, 0xe5, 0x27, 0xfa, 0xde, 0x68, 0x2d, 0x1d}, {0xb0, 0x56, 0x88, 0xc2, 0xb3, 0xe6, 0xc1, 0xfd}};
static const u8 FSb[256] = {112, 130, 44, 236, 179, 39, 192, 229, 228, 133, 87, 53, 234, 12, 174, 65, 35, 239, 107, 147, 69, 25, 165, 33, 237, 14, 79, 78, 29, 101, 146, 189, 134, 184, 175, 143, 124, 235, 31, 206, 62, 48, 220, 95, 94, 197, 11, 26, 166, 225, 57, 202, 213, 71, 93, 61, 217, 1, 90, 214, 81, 86, 108, 77, 139, 13, 154, 102, 251, 204, 176, 45, 116, 18, 43, 32, 240, 177, 132, 153, 223, 76, 203, 194, 52, 126, 118, 5, 109, 183, 169, 49, 209, 23, 4, 215, 20, 88, 58, 97, 222, 27, 17, 28, 50, 15, 156, 22, 83, 24, 242, 34, 254, 68, 207, 178, 195, 181, 122, 145, 36, 8, 232, 168, 96, 252, 105, 80, 170, 208, 160, 125, 161, 137, 98, 151, 84, 91, 30, 149, 224, 255, 100, 210, 16, 196, 0, 72, 163, 247, 117, 219, 138, 3, 230, 218, 9, 63, 221, 148, 135, 92, 131, 2, 205, 74, 144, 51, 115, 103, 246, 243, 157, 127, 191, 226, 82, 155, 216, 38, 200, 55, 198, 59, 129, 150, 111, 75, 19, 190, 99, 46, 233, 121, 167, 140, 159, 110, 188, 142, 41, 245, 249, 182, 47, 253, 180, 89, 120, 152, 6, 106, 231, 70, 113, 186, 212, 37, 171, 66, 136, 162, 141, 250, 114, 7, 185, 85, 248, 238, 172, 10, 54, 73, 42, 104, 60, 56, 241, 164, 64, 40, 211, 123, 187, 201, 67, 193, 21, 227, 173, 244, 119, 199, 128, 158};
static const u8 FSb2[256] = {224, 5, 88, 217, 103, 78, 129, 203, 201, 11, 174, 106, 213, 24, 93, 130, 70, 223, 214, 39, 138, 50, 75, 66, 219, 28, 158, 156, 58, 202, 37, 123, 13, 113, 95, 31, 248, 215, 62, 157, 124, 96, 185, 190, 188, 139, 22, 52, 77, 195, 114, 149, 171, 142, 186, 122, 179, 2, 180, 173, 162, 172, 216, 154, 23, 26, 53, 204, 247, 153, 97, 90, 232, 36, 86, 64, 225, 99, 9, 51, 191, 152, 151, 133, 104, 252, 236, 10, 218, 111, 83, 98, 163, 46, 8, 175, 40, 176, 116, 194, 189, 54, 34, 56, 100, 30, 57, 44, 166, 48, 229, 68, 253, 136, 159, 101, 135, 107, 244, 35, 72, 16, 209, 81, 192, 249, 210, 160, 85, 161, 65, 250, 67, 19, 196, 47, 168, 182, 60, 43, 193, 255, 200, 165, 32, 137, 0, 144, 71, 239, 234, 183, 21, 6, 205, 181, 18, 126, 187, 41, 15, 184, 7, 4, 155, 148, 33, 102, 230, 206, 237, 231, 59, 254, 127, 197, 164, 55, 177, 76, 145, 110, 141, 118, 3, 45, 222, 150, 38, 125, 198, 92, 211, 242, 79, 25, 63, 220, 121, 29, 82, 235, 243, 109, 94, 251, 105, 178, 240, 49, 12, 212, 207, 140, 226, 117, 169, 74, 87, 132, 17, 69, 27, 245, 228, 14, 115, 170, 241, 221, 89, 20, 108, 146, 84, 208, 120, 112, 227, 73, 128, 80, 167, 246, 119, 147, 134, 131, 42, 199, 91, 233, 238, 143, 1, 61};
static const u8 FSb3[256] = {56, 65, 22, 118, 217, 147, 96, 242, 114, 194, 171, 154, 117, 6, 87, 160, 145, 247, 181, 201, 162, 140, 210, 144, 246, 7, 167, 39, 142, 178, 73, 222, 67, 92, 215, 199, 62, 245, 143, 103, 31, 24, 110, 175, 47, 226, 133, 13, 83, 240, 156, 101, 234, 163, 174, 158, 236, 128, 45, 107, 168, 43, 54, 166, 197, 134, 77, 51, 253, 102, 88, 150, 58, 9, 149, 16, 120, 216, 66, 204, 239, 38, 229, 97, 26, 63, 59, 130, 182, 219, 212, 152, 232, 139, 2, 235, 10, 44, 29, 176, 111, 141, 136, 14, 25, 135, 78, 11, 169, 12, 121, 17, 127, 34, 231, 89, 225, 218, 61, 200, 18, 4, 116, 84, 48, 126, 180, 40, 85, 104, 80, 190, 208, 196, 49, 203, 42, 173, 15, 202, 112, 255, 50, 105, 8, 98, 0, 36, 209, 251, 186, 237, 69, 129, 115, 109, 132, 159, 238, 74, 195, 46, 193, 1, 230, 37, 72, 153, 185, 179, 123, 249, 206, 191, 223, 113, 41, 205, 108, 19, 100, 155, 99, 157, 192, 75, 183, 165, 137, 95, 177, 23, 244, 188, 211, 70, 207, 55, 94, 71, 148, 250, 252, 91, 151, 254, 90, 172, 60, 76, 3, 53, 243, 35, 184, 93, 106, 146, 213, 33, 68, 81, 198, 125, 57, 131, 220, 170, 124, 119, 86, 5, 27, 164, 21, 52, 30, 28, 248, 82, 32, 20, 233, 189, 221, 228, 161, 224, 138, 241, 214, 122, 187, 227, 64, 79};
static const u8 FSb4[256] = {112, 44, 179, 192, 228, 87, 234, 174, 35, 107, 69, 165, 237, 79, 29, 146, 134, 175, 124, 31, 62, 220, 94, 11, 166, 57, 213, 93, 217, 90, 81, 108, 139, 154, 251, 176, 116, 43, 240, 132, 223, 203, 52, 118, 109, 169, 209, 4, 20, 58, 222, 17, 50, 156, 83, 242, 254, 207, 195, 122, 36, 232, 96, 105, 170, 160, 161, 98, 84, 30, 224, 100, 16, 0, 163, 117, 138, 230, 9, 221, 135, 131, 205, 144, 115, 246, 157, 191, 82, 216, 200, 198, 129, 111, 19, 99, 233, 167, 159, 188, 41, 249, 47, 180, 120, 6, 231, 113, 212, 171, 136, 141, 114, 185, 248, 172, 54, 42, 60, 241, 64, 211, 187, 67, 21, 173, 119, 128, 130, 236, 39, 229, 133, 53, 12, 65, 239, 147, 25, 33, 14, 78, 101, 189, 184, 143, 235, 206, 48, 95, 197, 26, 225, 202, 71, 61, 1, 214, 86, 77, 13, 102, 204, 45, 18, 32, 177, 153, 76, 194, 126, 5, 183, 49, 23, 215, 88, 97, 27, 28, 15, 22, 24, 34, 68, 178, 181, 145, 8, 168, 252, 80, 208, 125, 137, 151, 91, 149, 255, 210, 196, 72, 247, 219, 3, 218, 63, 148, 92, 2, 74, 51, 103, 243, 127, 226, 155, 38, 55, 59, 150, 75, 190, 46, 121, 140, 110, 142, 245, 182, 253, 89, 152, 106, 70, 186, 37, 66, 162, 250, 7, 85, 238, 10, 73, 104, 56, 164, 40, 123, 201, 193, 227, 244, 199, 158};
static const u8 shifts[2][4][4] = {{{1, 1, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0}}, {{1, 0, 1, 1}, {1, 1, 0, 1}, {1, 1, 1, 0}, {1, 1, 0, 1}}};
static const i8 indexes[2][4][20] = {{{0, 1, 2, 3, 8, 9, 10, 11, 38, 39, 36, 37, 23, 20, 21, 22, 27, -1, -1, 26}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, 5, 6, 7, 12, 13, 14, 15, 16, 17, 18, 19, -1, 24, 25, -1, 31, 28, 29, 30}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, {{0, 1, 2, 3, 61, 62, 63, 60, -1, -1, -1, -1, 27, 24, 25, 26, 35, 32, 33, 34}, {-1, -1, -1, -1, 8, 9, 10, 11, 16, 17, 18, 19, -1, -1, -1, -1, 39, 36, 37, 38}, {-1, -1, -1, -1, 12, 13, 14, 15, 58, 59, 56, 57, 31, 28, 29, 30, -1, -1, -1, -1}, {4, 5, 6, 7, 65, 66, 67, 64, 20, 21, 22, 23, -1, -1, -1, -1, 43, 40, 41, 42}}};
static const i8 transposes[2][20] = {{21, 22, 23, 20, -1, -1, -1, -1, 18, 19, 16, 17, 11, 8, 9, 10, 15, 12, 13, 14}, {25, 26, 27, 24, 29, 30, 31, 28, 18, 19, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1}};
fn camellia_feistel(const u32 x[2], const u32 k[2], u32 z[2])
{
	u32 I0, I1;
	I0 = x[0] ^ k[0];
	I1 = x[1] ^ k[1];
	I0 = ((u32) FSb[((I0 >> 24) & 0xFF)] << 24) | ((u32) FSb2[((I0 >> 16) & 0xFF)] << 16) | ((u32) FSb3[((I0 >> 8) & 0xFF)] << 8) | ((u32) FSb4[((I0) &0xFF)]);
	I1 = ((u32) FSb2[((I1 >> 24) & 0xFF)] << 24) | ((u32) FSb3[((I1 >> 16) & 0xFF)] << 16) | ((u32) FSb4[((I1 >> 8) & 0xFF)] << 8) | ((u32) FSb[((I1) &0xFF)]);
	I0 ^= (I1 << 8) | (I1 >> 24);
	I1 ^= (I0 << 16) | (I0 >> 16);
	I0 ^= (I1 >> 8) | (I1 << 24);
	I1 ^= (I0 >> 8) | (I0 << 24);
	z[0] ^= I1;
	z[1] ^= I0;
}

pub fn mbedtls_camellia_init(mbedtls_camellia_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_camellia_context));
}

pub fn mbedtls_camellia_free(mbedtls_camellia_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_camellia_context));
}

pub fn mbedtls_camellia_setkey_enc(mbedtls_camellia_context * ctx, const u8 * key, u32 keybits) -> i32
{
	i32 idx;
	usize i;
	u32 * RK;
	u8 t[64];
	u32 SIGMA[6][2];
	u32 KC[16];
	u32 TK[20];
	RK = ctx.rk;
	memset(t, 0, 64);
	memset(RK, 0, sizeof(ctx.rk));
	switch (keybits)
	{
		case 128:
		ctx.nr = 3;
		idx = 0;
		break;

		case 192:
		case 256:
		ctx.nr = 4;
		idx = 1;
		break;

	default:
		return -0x0024;
	}
	for (i = 0; i < keybits / 8; ++i)
	{
		t[i] = key[i];
	}
	if keybits == 192
	{
		for (i = 0; i < 8; i++)
		{
			t[24 + i] = ~t[16 + i];
		}
	}
	for (i = 0; i < 6; i++)
	{
		{
			(SIGMA[i][0]) = ((u32)(SIGMA_CHARS[i])[(0)] << 24) | ((u32)(SIGMA_CHARS[i])[(0) + 1] << 16) | ((u32)(SIGMA_CHARS[i])[(0) + 2] << 8) | ((u32)(SIGMA_CHARS[i])[(0) + 3]);
		};
		{
			(SIGMA[i][1]) = ((u32)(SIGMA_CHARS[i])[(4)] << 24) | ((u32)(SIGMA_CHARS[i])[(4) + 1] << 16) | ((u32)(SIGMA_CHARS[i])[(4) + 2] << 8) | ((u32)(SIGMA_CHARS[i])[(4) + 3]);
		};
	}
	memset(KC, 0, sizeof(KC));
	for (i = 0; i < 8; i++)
	{
		(KC[i]) = ((u32)(t)[(i * 4)] << 24) | ((u32)(t)[(i * 4) + 1] << 16) | ((u32)(t)[(i * 4) + 2] << 8) | ((u32)(t)[(i * 4) + 3]);
	};
	for (i = 0; i < 4; ++i)
	{
		KC[8 + i] = KC[i] ^ KC[4 + i];
	}
	camellia_feistel(KC + 8, SIGMA[0], KC + 10);
	camellia_feistel(KC + 10, SIGMA[1], KC + 8);
	for (i = 0; i < 4; ++i)
	{
		KC[8 + i] ^= KC[i];
	}
	camellia_feistel(KC + 8, SIGMA[2], KC + 10);
	camellia_feistel(KC + 10, SIGMA[3], KC + 8);
	if keybits > 128
	{
		for (i = 0; i < 4; ++i)
		{
			KC[12 + i] = KC[4 + i] ^ KC[8 + i];
		}
		camellia_feistel(KC + 12, SIGMA[4], KC + 14);
		camellia_feistel(KC + 14, SIGMA[5], KC + 12);
	}
	{
		TK[0] = KC[(0) * 4 + 0];
		TK[1] = KC[(0) * 4 + 1];
		TK[2] = KC[(0) * 4 + 2];
		TK[3] = KC[(0) * 4 + 3];
		for (i = 1; i <= 4; i++)
			if shifts[(idx)][(0)][i - 1]
			{
				(TK + i * 4)[0] = (TK)[0] << ((15 * i) % 32) ^ (TK)[1] >> (32 - ((15 * i) % 32));
				(TK + i * 4)[1] = (TK)[1] << ((15 * i) % 32) ^ (TK)[2] >> (32 - ((15 * i) % 32));
				(TK + i * 4)[2] = (TK)[2] << ((15 * i) % 32) ^ (TK)[3] >> (32 - ((15 * i) % 32));
				(TK + i * 4)[3] = (TK)[3] << ((15 * i) % 32) ^ (TK)[0] >> (32 - ((15 * i) % 32));
			};
		for (i = 0; i < 20; i++)
			if indexes[(idx)][(0)][i] != -1
			{
				RK[indexes[(idx)][(0)][i]] = TK[i];
			}
	};
	if keybits > 128
	{
		{
			TK[0] = KC[(1) * 4 + 0];
			TK[1] = KC[(1) * 4 + 1];
			TK[2] = KC[(1) * 4 + 2];
			TK[3] = KC[(1) * 4 + 3];
			for (i = 1; i <= 4; i++)
				if shifts[(idx)][(1)][i - 1]
				{
					(TK + i * 4)[0] = (TK)[0] << ((15 * i) % 32) ^ (TK)[1] >> (32 - ((15 * i) % 32));
					(TK + i * 4)[1] = (TK)[1] << ((15 * i) % 32) ^ (TK)[2] >> (32 - ((15 * i) % 32));
					(TK + i * 4)[2] = (TK)[2] << ((15 * i) % 32) ^ (TK)[3] >> (32 - ((15 * i) % 32));
					(TK + i * 4)[3] = (TK)[3] << ((15 * i) % 32) ^ (TK)[0] >> (32 - ((15 * i) % 32));
				};
			for (i = 0; i < 20; i++)
				if indexes[(idx)][(1)][i] != -1
				{
					RK[indexes[(idx)][(1)][i]] = TK[i];
				}
		};
	}
	{
		TK[0] = KC[(2) * 4 + 0];
		TK[1] = KC[(2) * 4 + 1];
		TK[2] = KC[(2) * 4 + 2];
		TK[3] = KC[(2) * 4 + 3];
		for (i = 1; i <= 4; i++)
			if shifts[(idx)][(2)][i - 1]
			{
				(TK + i * 4)[0] = (TK)[0] << ((15 * i) % 32) ^ (TK)[1] >> (32 - ((15 * i) % 32));
				(TK + i * 4)[1] = (TK)[1] << ((15 * i) % 32) ^ (TK)[2] >> (32 - ((15 * i) % 32));
				(TK + i * 4)[2] = (TK)[2] << ((15 * i) % 32) ^ (TK)[3] >> (32 - ((15 * i) % 32));
				(TK + i * 4)[3] = (TK)[3] << ((15 * i) % 32) ^ (TK)[0] >> (32 - ((15 * i) % 32));
			};
		for (i = 0; i < 20; i++)
			if indexes[(idx)][(2)][i] != -1
			{
				RK[indexes[(idx)][(2)][i]] = TK[i];
			}
	};
	if keybits > 128
	{
		{
			TK[0] = KC[(3) * 4 + 0];
			TK[1] = KC[(3) * 4 + 1];
			TK[2] = KC[(3) * 4 + 2];
			TK[3] = KC[(3) * 4 + 3];
			for (i = 1; i <= 4; i++)
				if shifts[(idx)][(3)][i - 1]
				{
					(TK + i * 4)[0] = (TK)[0] << ((15 * i) % 32) ^ (TK)[1] >> (32 - ((15 * i) % 32));
					(TK + i * 4)[1] = (TK)[1] << ((15 * i) % 32) ^ (TK)[2] >> (32 - ((15 * i) % 32));
					(TK + i * 4)[2] = (TK)[2] << ((15 * i) % 32) ^ (TK)[3] >> (32 - ((15 * i) % 32));
					(TK + i * 4)[3] = (TK)[3] << ((15 * i) % 32) ^ (TK)[0] >> (32 - ((15 * i) % 32));
				};
			for (i = 0; i < 20; i++)
				if indexes[(idx)][(3)][i] != -1
				{
					RK[indexes[(idx)][(3)][i]] = TK[i];
				}
		};
	}
	for (i = 0; i < 20; i++)
	{
		if transposes[idx][i] != -1
		{
			RK[32 + 12 * idx + i] = RK[transposes[idx][i]];
		}
	}
	return 0;
}

pub fn mbedtls_camellia_setkey_dec(mbedtls_camellia_context * ctx, const u8 * key, u32 keybits) -> i32
{
	i32 idx, ret;
	usize i;
	mbedtls_camellia_context cty;
	u32 * RK;
	u32 * SK;
	mbedtls_camellia_init(&cty);
	if (ret = mbedtls_camellia_setkey_enc(&cty, key, keybits)) != 0
	{
		goto exit;
	}
	ctx.nr = cty.nr;
	idx = (ctx.nr == 4);
	RK = ctx.rk;
	SK = cty.rk + 24 * 2 + 8 * idx * 2;
	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;
	for (i = 22 + 8 * idx, SK -= 6; i > 0; i--, SK -= 4)
	{
		*RK++ = *SK++;
		*RK++ = *SK++;
	}
	SK -= 2;
	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;
exit:
	mbedtls_camellia_free(&cty);
	return ret;
}

pub fn mbedtls_camellia_crypt_ecb(mbedtls_camellia_context * ctx, i32 mode, const u8 input[16], u8 output[16]) -> i32
{
	i32 NR;
	u32 *RK, X[4];
	((void) mode);
	NR = ctx.nr;
	RK = ctx.rk;
	{
		(X[0]) = ((u32)(input)[(0)] << 24) | ((u32)(input)[(0) + 1] << 16) | ((u32)(input)[(0) + 2] << 8) | ((u32)(input)[(0) + 3]);
	};
	{
		(X[1]) = ((u32)(input)[(4)] << 24) | ((u32)(input)[(4) + 1] << 16) | ((u32)(input)[(4) + 2] << 8) | ((u32)(input)[(4) + 3]);
	};
	{
		(X[2]) = ((u32)(input)[(8)] << 24) | ((u32)(input)[(8) + 1] << 16) | ((u32)(input)[(8) + 2] << 8) | ((u32)(input)[(8) + 3]);
	};
	{
		(X[3]) = ((u32)(input)[(12)] << 24) | ((u32)(input)[(12) + 1] << 16) | ((u32)(input)[(12) + 2] << 8) | ((u32)(input)[(12) + 3]);
	};
	X[0] ^= *RK++;
	X[1] ^= *RK++;
	X[2] ^= *RK++;
	X[3] ^= *RK++;
	while (NR)
	{
		--NR;
		camellia_feistel(X, RK, X + 2);
		RK += 2;
		camellia_feistel(X + 2, RK, X);
		RK += 2;
		camellia_feistel(X, RK, X + 2);
		RK += 2;
		camellia_feistel(X + 2, RK, X);
		RK += 2;
		camellia_feistel(X, RK, X + 2);
		RK += 2;
		camellia_feistel(X + 2, RK, X);
		RK += 2;
		if NR
		{
			{
				(X[1]) = ((((X[0]) & (RK[0])) << 1) | (((X[0]) & (RK[0])) >> 31)) ^ (X[1]);
				(X[0]) = ((X[1]) | (RK[1])) ^ (X[0]);
			};
			RK += 2;
			{
				(X[2]) = ((X[3]) | (RK[1])) ^ (X[2]);
				(X[3]) = ((((X[2]) & (RK[0])) << 1) | (((X[2]) & (RK[0])) >> 31)) ^ (X[3]);
			};
			RK += 2;
		}
	}
	X[2] ^= *RK++;
	X[3] ^= *RK++;
	X[0] ^= *RK++;
	X[1] ^= *RK++;
	{
		(output)[(0)] = (i8) ((X[2]) >> 24);
		(output)[(0) + 1] = (i8) ((X[2]) >> 16);
		(output)[(0) + 2] = (i8) ((X[2]) >> 8);
		(output)[(0) + 3] = (i8) ((X[2]));
	};
	{
		(output)[(4)] = (i8) ((X[3]) >> 24);
		(output)[(4) + 1] = (i8) ((X[3]) >> 16);
		(output)[(4) + 2] = (i8) ((X[3]) >> 8);
		(output)[(4) + 3] = (i8) ((X[3]));
	};
	{
		(output)[(8)] = (i8) ((X[0]) >> 24);
		(output)[(8) + 1] = (i8) ((X[0]) >> 16);
		(output)[(8) + 2] = (i8) ((X[0]) >> 8);
		(output)[(8) + 3] = (i8) ((X[0]));
	};
	{
		(output)[(12)] = (i8) ((X[1]) >> 24);
		(output)[(12) + 1] = (i8) ((X[1]) >> 16);
		(output)[(12) + 2] = (i8) ((X[1]) >> 8);
		(output)[(12) + 3] = (i8) ((X[1]));
	};
	return 0;
}

pub fn mbedtls_camellia_crypt_cbc(mbedtls_camellia_context * ctx, i32 mode, usize length, u8 iv[16], const u8 * input, u8 * output) -> i32
{
	i32 i;
	u8 temp[16];
	if length % 16
	{
		return -0x0026;
	}
	if mode == 0
	{
		while (length > 0)
		{
			memcpy(temp, input, 16);
			mbedtls_camellia_crypt_ecb(ctx, mode, input, output);
			for (i = 0; i < 16; i++)
			{
				output[i] = (i8) (output[i] ^ iv[i]);
			}
			memcpy(iv, temp, 16);
			input += 16;
			output += 16;
			length -= 16;
		}
	}
	else
	{
		while (length > 0)
		{
			for (i = 0; i < 16; i++)
			{
				output[i] = (i8) (input[i] ^ iv[i]);
			}
			mbedtls_camellia_crypt_ecb(ctx, mode, output, output);
			memcpy(iv, output, 16);
			input += 16;
			output += 16;
			length -= 16;
		}
	}
	return 0;
}

pub fn mbedtls_camellia_crypt_cfb128(mbedtls_camellia_context * ctx, i32 mode, usize length, usize * iv_off, u8 iv[16], const u8 * input, u8 * output) -> i32
{
	i32 c;
	usize n = *iv_off;
	if mode == 0
	{
		while (length--)
		{
			if n == 0
			{
				mbedtls_camellia_crypt_ecb(ctx, 1, iv, iv);
			}
			c = *input++;
			*output++ = (i8) (c ^ iv[n]);
			iv[n] = (i8) c;
			n = (n + 1) & 0x0F;
		}
	}
	else
	{
		while (length--)
		{
			if n == 0
			{
				mbedtls_camellia_crypt_ecb(ctx, 1, iv, iv);
			}
			iv[n] = *output++ = (i8) (iv[n] ^ *input++);
			n = (n + 1) & 0x0F;
		}
	}
	*iv_off = n;
	return 0;
}

pub fn mbedtls_camellia_crypt_ctr(mbedtls_camellia_context * ctx, usize length, usize * nc_off, u8 nonce_counter[16], u8 stream_block[16], const u8 * input, u8 * output) -> i32
{
	i32 c, i;
	usize n = *nc_off;
	while (length--)
	{
		if n == 0
		{
			mbedtls_camellia_crypt_ecb(ctx, 1, nonce_counter, stream_block);
			for (i = 16; i > 0; i--)
				if ++nonce_counter[i - 1] != 0
				{
					break;

				}
		}
		c = *input++;
		*output++ = (i8) (c ^ stream_block[n]);
		n = (n + 1) & 0x0F;
	}
	*nc_off = n;
	return 0;
}

static const u8 camellia_test_ecb_key[3][2][32] =
{
	{{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}, {{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}, {{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
};
static const u8 camellia_test_ecb_plain[2][16] = {{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10}, {0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
static const u8 camellia_test_ecb_cipher[3][2][16] = {{{0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73, 0x08, 0x57, 0x06, 0x56, 0x48, 0xea, 0xbe, 0x43}, {0x38, 0x3C, 0x6C, 0x2A, 0xAB, 0xEF, 0x7F, 0xDE, 0x25, 0xCD, 0x47, 0x0B, 0xF7, 0x74, 0xA3, 0x31}}, {{0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8, 0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09, 0xb9}, {0xD1, 0x76, 0x3F, 0xC0, 0x19, 0xD7, 0x7C, 0xC9, 0x30, 0xBF, 0xF2, 0xA5, 0x6F, 0x7C, 0x93, 0x64}}, {{0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c, 0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75, 0x09}, {0x05, 0x03, 0xFB, 0x10, 0xAB, 0x24, 0x1E, 0x7C, 0xF4, 0x5D, 0x8C, 0xDE, 0xEE, 0x47, 0x43, 0x35}}};
static const u8 camellia_test_cbc_key[3][32] = {{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C}, {0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B}, {0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4}};
static const u8 camellia_test_cbc_iv[16] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
static const u8 camellia_test_cbc_plain[3][16] = {{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A}, {0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C, 0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51}, {0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11, 0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF}};
static const u8 camellia_test_cbc_cipher[3][3][16] = {{{0x16, 0x07, 0xCF, 0x49, 0x4B, 0x36, 0xBB, 0xF0, 0x0D, 0xAE, 0xB0, 0xB5, 0x03, 0xC8, 0x31, 0xAB}, {0xA2, 0xF2, 0xCF, 0x67, 0x16, 0x29, 0xEF, 0x78, 0x40, 0xC5, 0xA5, 0xDF, 0xB5, 0x07, 0x48, 0x87}, {0x0F, 0x06, 0x16, 0x50, 0x08, 0xCF, 0x8B, 0x8B, 0x5A, 0x63, 0x58, 0x63, 0x62, 0x54, 0x3E, 0x54}}, {{0x2A, 0x48, 0x30, 0xAB, 0x5A, 0xC4, 0xA1, 0xA2, 0x40, 0x59, 0x55, 0xFD, 0x21, 0x95, 0xCF, 0x93}, {0x5D, 0x5A, 0x86, 0x9B, 0xD1, 0x4C, 0xE5, 0x42, 0x64, 0xF8, 0x92, 0xA6, 0xDD, 0x2E, 0xC3, 0xD5}, {0x37, 0xD3, 0x59, 0xC3, 0x34, 0x98, 0x36, 0xD8, 0x84, 0xE3, 0x10, 0xAD, 0xDF, 0x68, 0xC4, 0x49}}, {{0xE6, 0xCF, 0xA3, 0x5F, 0xC0, 0x2B, 0x13, 0x4A, 0x4D, 0x2C, 0x0B, 0x67, 0x37, 0xAC, 0x3E, 0xDA}, {0x36, 0xCB, 0xEB, 0x73, 0xBD, 0x50, 0x4B, 0x40, 0x70, 0xB1, 0xB7, 0xDE, 0x2B, 0x21, 0xEB, 0x50}, {0xE3, 0x1A, 0x60, 0x55, 0x29, 0x7D, 0x96, 0xCA, 0x33, 0x30, 0xCD, 0xF1, 0xB1, 0x86, 0x0A, 0x83}}};
static const u8 camellia_test_ctr_key[3][16] = {{0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC, 0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E}, {0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7, 0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63}, {0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8, 0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC}};
static const u8 camellia_test_ctr_nonce_counter[3][16] = {{0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}, {0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59, 0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01}, {0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F, 0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01}};
static const u8 camellia_test_ctr_pt[3][48] = {{0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67}, {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}, {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23}};
static const u8 camellia_test_ctr_ct[3][48] = {{0xD0, 0x9D, 0xC2, 0x9A, 0x82, 0x14, 0x61, 0x9A, 0x20, 0x87, 0x7C, 0x76, 0xDB, 0x1F, 0x0B, 0x3F}, {0xDB, 0xF3, 0xC7, 0x8D, 0xC0, 0x83, 0x96, 0xD4, 0xDA, 0x7C, 0x90, 0x77, 0x65, 0xBB, 0xCB, 0x44, 0x2B, 0x8E, 0x8E, 0x0F, 0x31, 0xF0, 0xDC, 0xA7, 0x2C, 0x74, 0x17, 0xE3, 0x53, 0x60, 0xE0, 0x48}, {0xB1, 0x9D, 0x1F, 0xCD, 0xCB, 0x75, 0xEB, 0x88, 0x2F, 0x84, 0x9C, 0xE2, 0x4D, 0x85, 0xCF, 0x73, 0x9C, 0xE6, 0x4B, 0x2B, 0x5C, 0x9D, 0x73, 0xF1, 0x4F, 0x2D, 0x5D, 0x9D, 0xCE, 0x98, 0x89, 0xCD, 0xDF, 0x50, 0x86, 0x96}};
static const i32 camellia_test_ctr_len[3] = {16, 32, 36};
pub fn mbedtls_camellia_self_test(i32 verbose) -> i32
{
	i32 i, j, u, v;
	u8 key[32];
	u8 buf[64];
	u8 src[16];
	u8 dst[16];
	u8 iv[16];
	usize offset, len;
	u8 nonce_counter[16];
	u8 stream_block[16];
	mbedtls_camellia_context ctx;
	memset(key, 0, 32);
	for (j = 0; j < 6; j++)
	{
		u = j >> 1;
		v = j & 1;
		if verbose != 0
		{
			printf("  CAMELLIA-ECB-%3d (%s): ", 128 + u * 64, (v == 0) ? "dec" : "enc");
		}
		for (i = 0; i < 2; i++)
		{
			memcpy(key, camellia_test_ecb_key[u][i], 16 + 8 * u);
			if v == 0
			{
				mbedtls_camellia_setkey_dec(&ctx, key, 128 + u * 64);
				memcpy(src, camellia_test_ecb_cipher[u][i], 16);
				memcpy(dst, camellia_test_ecb_plain[i], 16);
			}
			else
			{
				mbedtls_camellia_setkey_enc(&ctx, key, 128 + u * 64);
				memcpy(src, camellia_test_ecb_plain[i], 16);
				memcpy(dst, camellia_test_ecb_cipher[u][i], 16);
			}
			mbedtls_camellia_crypt_ecb(&ctx, v, src, buf);
			if memcmp(buf, dst, 16) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
	for (j = 0; j < 6; j++)
	{
		u = j >> 1;
		v = j & 1;
		if verbose != 0
		{
			printf("  CAMELLIA-CBC-%3d (%s): ", 128 + u * 64, (v == 0) ? "dec" : "enc");
		}
		memcpy(src, camellia_test_cbc_iv, 16);
		memcpy(dst, camellia_test_cbc_iv, 16);
		memcpy(key, camellia_test_cbc_key[u], 16 + 8 * u);
		if v == 0
		{
			mbedtls_camellia_setkey_dec(&ctx, key, 128 + u * 64);
		}
		else
		{
			mbedtls_camellia_setkey_enc(&ctx, key, 128 + u * 64);
		}
		for (i = 0; i < 3; i++)
		{
			if v == 0
			{
				memcpy(iv, src, 16);
				memcpy(src, camellia_test_cbc_cipher[u][i], 16);
				memcpy(dst, camellia_test_cbc_plain[i], 16);
			}
			else
			{
				memcpy(iv, dst, 16);
				memcpy(src, camellia_test_cbc_plain[i], 16);
				memcpy(dst, camellia_test_cbc_cipher[u][i], 16);
			}
			mbedtls_camellia_crypt_cbc(&ctx, v, 16, iv, src, buf);
			if memcmp(buf, dst, 16) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
	for (i = 0; i < 6; i++)
	{
		u = i >> 1;
		v = i & 1;
		if verbose != 0
		{
			printf("  CAMELLIA-CTR-128 (%s): ", (v == 0) ? "dec" : "enc");
		}
		memcpy(nonce_counter, camellia_test_ctr_nonce_counter[u], 16);
		memcpy(key, camellia_test_ctr_key[u], 16);
		offset = 0;
		mbedtls_camellia_setkey_enc(&ctx, key, 128);
		if v == 0
		{
			len = camellia_test_ctr_len[u];
			memcpy(buf, camellia_test_ctr_ct[u], len);
			mbedtls_camellia_crypt_ctr(&ctx, len, &offset, nonce_counter, stream_block, buf, buf);
			if memcmp(buf, camellia_test_ctr_pt[u], len) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
		}
		else
		{
			len = camellia_test_ctr_len[u];
			memcpy(buf, camellia_test_ctr_pt[u], len);
			mbedtls_camellia_crypt_ctr(&ctx, len, &offset, nonce_counter, stream_block, buf, buf);
			if memcmp(buf, camellia_test_ctr_ct[u], len) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
	return 0;
}

typedef enum
{
	MBEDTLS_CIPHER_ID_NONE = 0,
	MBEDTLS_CIPHER_ID_NULL,
	MBEDTLS_CIPHER_ID_AES,
	MBEDTLS_CIPHER_ID_DES,
	MBEDTLS_CIPHER_ID_3DES,
	MBEDTLS_CIPHER_ID_CAMELLIA,
	MBEDTLS_CIPHER_ID_BLOWFISH,
	MBEDTLS_CIPHER_ID_ARC4,
} mbedtls_cipher_id_t;
typedef enum
{
	MBEDTLS_CIPHER_NONE = 0,
	MBEDTLS_CIPHER_NULL,
	MBEDTLS_CIPHER_AES_128_ECB,
	MBEDTLS_CIPHER_AES_192_ECB,
	MBEDTLS_CIPHER_AES_256_ECB,
	MBEDTLS_CIPHER_AES_128_CBC,
	MBEDTLS_CIPHER_AES_192_CBC,
	MBEDTLS_CIPHER_AES_256_CBC,
	MBEDTLS_CIPHER_AES_128_CFB128,
	MBEDTLS_CIPHER_AES_192_CFB128,
	MBEDTLS_CIPHER_AES_256_CFB128,
	MBEDTLS_CIPHER_AES_128_CTR,
	MBEDTLS_CIPHER_AES_192_CTR,
	MBEDTLS_CIPHER_AES_256_CTR,
	MBEDTLS_CIPHER_AES_128_GCM,
	MBEDTLS_CIPHER_AES_192_GCM,
	MBEDTLS_CIPHER_AES_256_GCM,
	MBEDTLS_CIPHER_CAMELLIA_128_ECB,
	MBEDTLS_CIPHER_CAMELLIA_192_ECB,
	MBEDTLS_CIPHER_CAMELLIA_256_ECB,
	MBEDTLS_CIPHER_CAMELLIA_128_CBC,
	MBEDTLS_CIPHER_CAMELLIA_192_CBC,
	MBEDTLS_CIPHER_CAMELLIA_256_CBC,
	MBEDTLS_CIPHER_CAMELLIA_128_CFB128,
	MBEDTLS_CIPHER_CAMELLIA_192_CFB128,
	MBEDTLS_CIPHER_CAMELLIA_256_CFB128,
	MBEDTLS_CIPHER_CAMELLIA_128_CTR,
	MBEDTLS_CIPHER_CAMELLIA_192_CTR,
	MBEDTLS_CIPHER_CAMELLIA_256_CTR,
	MBEDTLS_CIPHER_CAMELLIA_128_GCM,
	MBEDTLS_CIPHER_CAMELLIA_192_GCM,
	MBEDTLS_CIPHER_CAMELLIA_256_GCM,
	MBEDTLS_CIPHER_DES_ECB,
	MBEDTLS_CIPHER_DES_CBC,
	MBEDTLS_CIPHER_DES_EDE_ECB,
	MBEDTLS_CIPHER_DES_EDE_CBC,
	MBEDTLS_CIPHER_DES_EDE3_ECB,
	MBEDTLS_CIPHER_DES_EDE3_CBC,
	MBEDTLS_CIPHER_BLOWFISH_ECB,
	MBEDTLS_CIPHER_BLOWFISH_CBC,
	MBEDTLS_CIPHER_BLOWFISH_CFB64,
	MBEDTLS_CIPHER_BLOWFISH_CTR,
	MBEDTLS_CIPHER_ARC4_128,
	MBEDTLS_CIPHER_AES_128_CCM,
	MBEDTLS_CIPHER_AES_192_CCM,
	MBEDTLS_CIPHER_AES_256_CCM,
	MBEDTLS_CIPHER_CAMELLIA_128_CCM,
	MBEDTLS_CIPHER_CAMELLIA_192_CCM,
	MBEDTLS_CIPHER_CAMELLIA_256_CCM,
} mbedtls_cipher_type_t;
typedef enum
{
	MBEDTLS_MODE_NONE = 0,
	MBEDTLS_MODE_ECB,
	MBEDTLS_MODE_CBC,
	MBEDTLS_MODE_CFB,
	MBEDTLS_MODE_OFB,
	MBEDTLS_MODE_CTR,
	MBEDTLS_MODE_GCM,
	MBEDTLS_MODE_STREAM,
	MBEDTLS_MODE_CCM,
} mbedtls_cipher_mode_t;
typedef enum
{
	MBEDTLS_PADDING_PKCS7 = 0,
	MBEDTLS_PADDING_ONE_AND_ZEROS,
	MBEDTLS_PADDING_ZEROS_AND_LEN,
	MBEDTLS_PADDING_ZEROS,
	MBEDTLS_PADDING_NONE,
} mbedtls_cipher_padding_t;
typedef enum
{
	MBEDTLS_OPERATION_NONE = -1,
	MBEDTLS_DECRYPT = 0,
	MBEDTLS_ENCRYPT,
} mbedtls_operation_t;
enum
{
	MBEDTLS_KEY_LENGTH_NONE = 0,
	MBEDTLS_KEY_LENGTH_DES = 64,
	MBEDTLS_KEY_LENGTH_DES_EDE = 128,
	MBEDTLS_KEY_LENGTH_DES_EDE3 = 192,
};
typedef struct mbedtls_cipher_base_t mbedtls_cipher_base_t;
typedef struct
{
	mbedtls_cipher_type_t type;
	mbedtls_cipher_mode_t mode;
	u32 key_bitlen;
	const i8 * name;
	u32 iv_size;
	i32 flags;
	u32 block_size;
	const mbedtls_cipher_base_t * base;
} mbedtls_cipher_info_t;
typedef struct
{
	const mbedtls_cipher_info_t * cipher_info;
	i32 key_bitlen;
	mbedtls_operation_t operation;
	void (*add_padding)(u8 * output, usize olen, usize data_len);
	i32 (*get_padding)(u8 * input, usize ilen, usize * data_len);
	u8 unprocessed_data[16];
	usize unprocessed_len;
	u8 iv[16];
	usize iv_size;
	void * cipher_ctx;
} mbedtls_cipher_context_t;

fn u32 mbedtls_cipher_get_block_size(const mbedtls_cipher_context_t * ctx) -> inline
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return 0;
	}
	return ctx.cipher_info.block_size;
}

fn mbedtls_cipher_mode_t mbedtls_cipher_get_cipher_mode(const mbedtls_cipher_context_t * ctx) -> inline
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return MBEDTLS_MODE_NONE;
	}
	return ctx.cipher_info.mode;
}

fn i32 mbedtls_cipher_get_iv_size(const mbedtls_cipher_context_t * ctx) -> inline
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return 0;
	}
	if ctx.iv_size != 0
	{
		return (int) ctx.iv_size;
	}
	return (int) ctx.cipher_info.iv_size;
}

fn mbedtls_cipher_type_t mbedtls_cipher_get_type(const mbedtls_cipher_context_t * ctx) -> inline
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return MBEDTLS_CIPHER_NONE;
	}
	return ctx.cipher_info.type;
}

fn const i8 * mbedtls_cipher_get_name(const mbedtls_cipher_context_t * ctx) -> inline
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return 0;
	}
	return ctx.cipher_info.name;
}

fn i32 mbedtls_cipher_get_key_bitlen(const mbedtls_cipher_context_t * ctx) -> inline
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return MBEDTLS_KEY_LENGTH_NONE;
	}
	return (int) ctx.cipher_info.key_bitlen;
}

fn mbedtls_operation_t mbedtls_cipher_get_operation(const mbedtls_cipher_context_t * ctx) -> inline
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return MBEDTLS_OPERATION_NONE;
	}
	return ctx.operation;
}

typedef struct
{
	mbedtls_cipher_context_t cipher_ctx;
} mbedtls_ccm_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = (u8 *) v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_ccm_init(mbedtls_ccm_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_ccm_context));
}

pub fn mbedtls_ccm_setkey(mbedtls_ccm_context * ctx, mbedtls_cipher_id_t cipher, const u8 * key, u32 keybits) -> i32
{
	i32 ret;
	const mbedtls_cipher_info_t * cipher_info;
	cipher_info = mbedtls_cipher_info_from_values(cipher, keybits, MBEDTLS_MODE_ECB);
	if cipher_info == NULL
	{
		return -0x000D;
	}
	if cipher_info.block_size != 16
	{
		return -0x000D;
	}
	mbedtls_cipher_free(&ctx.cipher_ctx);
	if (ret = mbedtls_cipher_setup(&ctx.cipher_ctx, cipher_info)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_cipher_setkey(&ctx.cipher_ctx, key, keybits, MBEDTLS_ENCRYPT)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_ccm_free(mbedtls_ccm_context * ctx)
{
	mbedtls_cipher_free(&ctx.cipher_ctx);
	zeroize(ctx, sizeof(mbedtls_ccm_context));
}

fn ccm_auth_crypt(mbedtls_ccm_context * ctx, i32 mode, usize length, const u8 * iv, usize iv_len, const u8 * add, usize add_len, const u8 * input, u8 * output, u8 * tag, usize tag_len) -> i32
{
	i32 ret;
	u8 i;
	u8 q;
	usize len_left, olen;
	u8 b[16];
	u8 y[16];
	u8 ctr[16];
	const u8 * src;
	u8 * dst;
	if tag_len < 4 || tag_len > 16 || tag_len % 2 != 0
	{
		return -0x000D;
	}
	if iv_len < 7 || iv_len > 13
	{
		return -0x000D;
	}
	if add_len > 0xFF00
	{
		return -0x000D;
	}
	q = 16 - 1 - (i8) iv_len;
	b[0] = 0;
	b[0] |= (add_len > 0) << 6;
	b[0] |= ((tag_len - 2) / 2) << 3;
	b[0] |= q - 1;
	memcpy(b + 1, iv, iv_len);
	for (i = 0, len_left = length; i < q; i++, len_left >>= 8)
	{
		b[15 - i] = (i8) (len_left & 0xFF);
	}
	if len_left > 0
	{
		return -0x000D;
	}
	memset(y, 0, 16);
	for (i = 0; i < 16; i++)
	{
		y[i] ^= b[i];
	}
	if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, y, 16, y, &olen)) != 0
	{
		return ret;
	}
	;
	if add_len > 0
	{
		usize use_len;
		len_left = add_len;
		src = add;
		memset(b, 0, 16);
		b[0] = (i8) ((add_len >> 8) & 0xFF);
		b[1] = (i8) ((add_len) &0xFF);
		use_len = len_left < 16 - 2 ? len_left : 16 - 2;
		memcpy(b + 2, src, use_len);
		len_left -= use_len;
		src += use_len;
		for (i = 0; i < 16; i++)
		{
			y[i] ^= b[i];
		}
		if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, y, 16, y, &olen)) != 0
		{
			return ret;
		}
		;
		while (len_left > 0)
		{
			use_len = len_left > 16 ? 16 : len_left;
			memset(b, 0, 16);
			memcpy(b, src, use_len);
			for (i = 0; i < 16; i++)
			{
				y[i] ^= b[i];
			}
			if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, y, 16, y, &olen)) != 0
			{
				return ret;
			}
			;
			len_left -= use_len;
			src += use_len;
		}
	}
	ctr[0] = q - 1;
	memcpy(ctr + 1, iv, iv_len);
	memset(ctr + 1 + iv_len, 0, q);
	ctr[15] = 1;
	len_left = length;
	src = input;
	dst = output;
	while (len_left > 0)
	{
		usize use_len = len_left > 16 ? 16 : len_left;
		if mode == 0
		{
			memset(b, 0, 16);
			memcpy(b, src, use_len);
			for (i = 0; i < 16; i++)
			{
				y[i] ^= b[i];
			}
			if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, y, 16, y, &olen)) != 0
			{
				return ret;
			}
			;
		}
		if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, ctr, 16, b, &olen)) != 0
		{
			return ret;
		}
		for (i = 0; i < use_len; i++)
		{
			dst[i] = src[i] ^ b[i];
		}
		;
		if mode == 1
		{
			memset(b, 0, 16);
			memcpy(b, dst, use_len);
			for (i = 0; i < 16; i++)
			{
				y[i] ^= b[i];
			}
			if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, y, 16, y, &olen)) != 0
			{
				return ret;
			}
			;
		}
		dst += use_len;
		src += use_len;
		len_left -= use_len;
		for (i = 0; i < q; i++)
			if ++ctr[15 - i] != 0
			{
				break;

			}
	}
	for (i = 0; i < q; i++)
	{
		ctr[15 - i] = 0;
	}
	if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, ctr, 16, b, &olen)) != 0
	{
		return ret;
	}
	for (i = 0; i < 16; i++)
	{
		y[i] = y[i] ^ b[i];
	}
	;
	memcpy(tag, y, tag_len);
	return 0;
}

pub fn mbedtls_ccm_encrypt_and_tag(mbedtls_ccm_context * ctx, usize length, const u8 * iv, usize iv_len, const u8 * add, usize add_len, const u8 * input, u8 * output, u8 * tag, usize tag_len) -> i32
{
	return ccm_auth_crypt(ctx, 0, length, iv, iv_len, add, add_len, input, output, tag, tag_len);
}

pub fn mbedtls_ccm_auth_decrypt(mbedtls_ccm_context * ctx, usize length, const u8 * iv, usize iv_len, const u8 * add, usize add_len, const u8 * input, u8 * output, const u8 * tag, usize tag_len) -> i32
{
	i32 ret;
	u8 check_tag[16];
	u8 i;
	i32 diff;
	if (ret = ccm_auth_crypt(ctx, 1, length, iv, iv_len, add, add_len, input, output, check_tag, tag_len)) != 0
	{
		return ret;
	}
	for (diff = 0, i = 0; i < tag_len; i++)
	{
		diff |= tag[i] ^ check_tag[i];
	}
	if diff != 0
	{
		zeroize(output, length);
		return -0x000F;
	}
	return 0;
}

static const u8 key[] = {0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f};
static const u8 iv[] = {0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b};
static const u8 ad[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13};
static const u8 msg[] =
{
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
};
static const usize iv_len[3] = {7, 8, 12};
static const usize add_len[3] = {8, 16, 20};
static const usize msg_len[3] = {4, 16, 24};
static const usize tag_len[3] = {4, 6, 8};
static const u8 res[3][32] = {{0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d}, {0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62, 0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d, 0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd}, {0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a, 0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b, 0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5, 0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51}};
pub fn mbedtls_ccm_self_test(i32 verbose) -> i32
{
	mbedtls_ccm_context ctx;
	u8 out[32];
	usize i;
	i32 ret;
	mbedtls_ccm_init(&ctx);
	if mbedtls_ccm_setkey(&ctx, MBEDTLS_CIPHER_ID_AES, key, 8 * sizeof key) != 0
	{
		if verbose != 0
		{
			printf("  CCM: setup failed");
		}
		return 1;
	}
	for (i = 0; i < 3; i++)
	{
		if verbose != 0
		{
			printf("  CCM-AES #%u: ", (i32 int) i + 1);
		}
		ret = mbedtls_ccm_encrypt_and_tag(&ctx, msg_len[i], iv, iv_len[i], ad, add_len[i], msg, out, out + msg_len[i], tag_len[i]);
		if ret != 0 || memcmp(out, res[i], msg_len[i] + tag_len[i]) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			return 1;
		}
		ret = mbedtls_ccm_auth_decrypt(&ctx, msg_len[i], iv, iv_len[i], ad, add_len[i], res[i], out, res[i] + msg_len[i], tag_len[i]);
		if ret != 0 || memcmp(out, msg, msg_len[i]) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			return 1;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	mbedtls_ccm_free(&ctx);
	if verbose != 0
	{
		printf("\n");
	}
	return 0;
}

static  i8 mbedtls_test_cas_pem[];
static  usize mbedtls_test_cas_pem_len;
static  i8 * mbedtls_test_cas[];
static  usize mbedtls_test_cas_len[];
static  i8 * mbedtls_test_ca_crt;
static  usize mbedtls_test_ca_crt_len;
static  i8 * mbedtls_test_ca_key;
static  usize mbedtls_test_ca_key_len;
static  i8 * mbedtls_test_ca_pwd;
static  usize mbedtls_test_ca_pwd_len;
static  i8 * mbedtls_test_srv_crt;
static  usize mbedtls_test_srv_crt_len;
static  i8 * mbedtls_test_srv_key;
static  usize mbedtls_test_srv_key_len;
static  i8 * mbedtls_test_cli_crt;
static  usize mbedtls_test_cli_crt_len;
static  i8 * mbedtls_test_cli_key;
static  usize mbedtls_test_cli_key_len;
static  i8 mbedtls_test_ca_crt_ec[];
static  usize mbedtls_test_ca_crt_ec_len;
static  i8 mbedtls_test_ca_key_ec[];
static  usize mbedtls_test_ca_key_ec_len;
static  i8 mbedtls_test_ca_pwd_ec[];
static  usize mbedtls_test_ca_pwd_ec_len;
static  i8 mbedtls_test_srv_crt_ec[];
static  usize mbedtls_test_srv_crt_ec_len;
static  i8 mbedtls_test_srv_key_ec[];
static  usize mbedtls_test_srv_key_ec_len;
static  i8 mbedtls_test_cli_crt_ec[];
static  usize mbedtls_test_cli_crt_ec_len;
static  i8 mbedtls_test_cli_key_ec[];
static  usize mbedtls_test_cli_key_ec_len;
static  i8 mbedtls_test_ca_crt_rsa[];
static  usize mbedtls_test_ca_crt_rsa_len;
static  i8 mbedtls_test_ca_key_rsa[];
static  usize mbedtls_test_ca_key_rsa_len;
static  i8 mbedtls_test_ca_pwd_rsa[];
static  usize mbedtls_test_ca_pwd_rsa_len;
static  i8 mbedtls_test_srv_crt_rsa[];
static  usize mbedtls_test_srv_crt_rsa_len;
static  i8 mbedtls_test_srv_key_rsa[];
static  usize mbedtls_test_srv_key_rsa_len;
static  i8 mbedtls_test_cli_crt_rsa[];
static  usize mbedtls_test_cli_crt_rsa_len;
static  i8 mbedtls_test_cli_key_rsa[];
static  usize mbedtls_test_cli_key_rsa_len;
struct mbedtls_cipher_base_t
{
	mbedtls_cipher_id_t cipher;
	i32 (*ecb_func)(void * ctx, mbedtls_operation_t mode, const u8 * input, u8 * output);
	i32 (*cbc_func)(void * ctx, mbedtls_operation_t mode, usize length, u8 * iv, const u8 * input, u8 * output);
	i32 (*cfb_func)(void * ctx, mbedtls_operation_t mode, usize length, usize * iv_off, u8 * iv, const u8 * input, u8 * output);
	i32 (*ctr_func)(void * ctx, usize length, usize * nc_off, u8 * nonce_counter, u8 * stream_block, const u8 * input, u8 * output);
	i32 (*setkey_enc_func)(void * ctx, const u8 * key, u32 key_bitlen);
	i32 (*setkey_dec_func)(void * ctx, const u8 * key, u32 key_bitlen);
	void * (*ctx_alloc_func)(void);
	void (*ctx_free_func)(void * ctx);
};
typedef struct
{
	mbedtls_cipher_type_t type;
	const mbedtls_cipher_info_t * info;
} mbedtls_cipher_definition_t;
static  mbedtls_cipher_definition_t mbedtls_cipher_definitions[];
static i32 mbedtls_cipher_supported[];
typedef struct
{
	mbedtls_cipher_context_t cipher_ctx;
	u64 HL[16];
	u64 HH[16];
	u64 len;
	u64 add_len;
	u8 base_ectr[16];
	u8 y[16];
	u8 buf[16];
	i32 mode;
} mbedtls_gcm_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = (u8 *) v;
	while (n--)
	{
		*p++ = 0;
	}
}

static i32 supported_init = 0;
pub fn i32 * mbedtls_cipher_list() -> const
{
	const mbedtls_cipher_definition_t * def;
	i32 * type;
	if !supported_init
	{
		def = mbedtls_cipher_definitions;
		type = mbedtls_cipher_supported;
		while (def.type != 0)
		{
			*type++ = (*def++).type;
		}
		*type = 0;
		supported_init = 1;
	}
	return mbedtls_cipher_supported;
}

pub fn mbedtls_cipher_info_t * mbedtls_cipher_info_from_type(const mbedtls_cipher_type_t cipher_type) -> const
{
	const mbedtls_cipher_definition_t * def;
	for (def = mbedtls_cipher_definitions; def.info != NULL; def++)
		if def.type == cipher_type
		{
			return def.info;
		}
	return NULL;
}

pub fn mbedtls_cipher_info_t * mbedtls_cipher_info_from_string(const i8 * cipher_name) -> const
{
	const mbedtls_cipher_definition_t * def;
	if NULL == cipher_name
	{
		return NULL;
	}
	for (def = mbedtls_cipher_definitions; def.info != NULL; def++)
		if !strcmp(def.info.name, cipher_name)
		{
			return def.info;
		}
	return NULL;
}

pub fn mbedtls_cipher_info_t * mbedtls_cipher_info_from_values(const mbedtls_cipher_id_t cipher_id, i32 key_bitlen, const mbedtls_cipher_mode_t mode) -> const
{
	const mbedtls_cipher_definition_t * def;
	for (def = mbedtls_cipher_definitions; def.info != NULL; def++)
		if def.info.base.cipher == cipher_id && def.info.key_bitlen == (unsigned) key_bitlen && def.info.mode == mode
		{
			return def.info;
		}
	return NULL;
}

pub fn mbedtls_cipher_init(mbedtls_cipher_context_t * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
}

pub fn mbedtls_cipher_free(mbedtls_cipher_context_t * ctx)
{
	if ctx == NULL
	{
		return;
	}
	if ctx.cipher_ctx
	{
		ctx.cipher_info.base.ctx_free_func(ctx.cipher_ctx);
	}
	zeroize(ctx, sizeof(mbedtls_cipher_context_t));
}

pub fn mbedtls_cipher_setup(mbedtls_cipher_context_t * ctx, const mbedtls_cipher_info_t * cipher_info) -> i32
{
	if NULL == cipher_info || NULL == ctx
	{
		return -0x6100;
	}
	memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
	if NULL == (ctx.cipher_ctx = cipher_info.base.ctx_alloc_func())
	{
		return -0x6180;
	}
	ctx.cipher_info = cipher_info;
	(void) mbedtls_cipher_set_padding_mode(ctx, MBEDTLS_PADDING_PKCS7);
	return 0;
}

pub fn mbedtls_cipher_setkey(mbedtls_cipher_context_t * ctx, const u8 * key, i32 key_bitlen, const mbedtls_operation_t operation) -> i32
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return -0x6100;
	}
	if (ctx.cipher_info.flags & 0x02) == 0 && (int) ctx.cipher_info.key_bitlen != key_bitlen
	{
		return -0x6100;
	}
	ctx.key_bitlen = key_bitlen;
	ctx.operation = operation;
	if MBEDTLS_ENCRYPT == operation || MBEDTLS_MODE_CFB == ctx.cipher_info.mode || MBEDTLS_MODE_CTR == ctx.cipher_info.mode
	{
		return ctx.cipher_info.base.setkey_enc_func(ctx.cipher_ctx, key, ctx.key_bitlen);
	}
	if MBEDTLS_DECRYPT == operation
	{
		return ctx.cipher_info.base.setkey_dec_func(ctx.cipher_ctx, key, ctx.key_bitlen);
	}
	return -0x6100;
}

pub fn mbedtls_cipher_set_iv(mbedtls_cipher_context_t * ctx, const u8 * iv, usize iv_len) -> i32
{
	usize actual_iv_size;
	if NULL == ctx || NULL == ctx.cipher_info || NULL == iv
	{
		return -0x6100;
	}
	if iv_len > 16
	{
		return -0x6080;
	}
	if (ctx.cipher_info.flags & 0x01) != 0
	{
		actual_iv_size = iv_len;
	}
	else
	{
		actual_iv_size = ctx.cipher_info.iv_size;
		if actual_iv_size > iv_len
		{
			return -0x6100;
		}
	}
	memcpy(ctx.iv, iv, actual_iv_size);
	ctx.iv_size = actual_iv_size;
	return 0;
}

pub fn mbedtls_cipher_reset(mbedtls_cipher_context_t * ctx) -> i32
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return -0x6100;
	}
	ctx.unprocessed_len = 0;
	return 0;
}

pub fn mbedtls_cipher_update_ad(mbedtls_cipher_context_t * ctx, const u8 * ad, usize ad_len) -> i32
{
	if NULL == ctx || NULL == ctx.cipher_info
	{
		return -0x6100;
	}
	if MBEDTLS_MODE_GCM == ctx.cipher_info.mode
	{
		return mbedtls_gcm_starts((mbedtls_gcm_context *) ctx.cipher_ctx, ctx.operation, ctx.iv, ctx.iv_size, ad, ad_len);
	}
	return 0;
}

pub fn mbedtls_cipher_update(mbedtls_cipher_context_t * ctx, const u8 * input, usize ilen, u8 * output, usize * olen) -> i32
{
	i32 ret;
	usize block_size = 0;
	if NULL == ctx || NULL == ctx.cipher_info || NULL == olen
	{
		return -0x6100;
	}
	*olen = 0;
	block_size = mbedtls_cipher_get_block_size(ctx);
	if ctx.cipher_info.mode == MBEDTLS_MODE_ECB
	{
		if ilen != block_size
		{
			return -0x6280;
		}
		*olen = ilen;
		if 0 != (ret = ctx.cipher_info.base.ecb_func(ctx.cipher_ctx, ctx.operation, input, output))
		{
			return ret;
		}
		return 0;
	}
	if ctx.cipher_info.mode == MBEDTLS_MODE_GCM
	{
		*olen = ilen;
		return mbedtls_gcm_update((mbedtls_gcm_context *) ctx.cipher_ctx, ilen, input, output);
	}
	if 0 == block_size
	{
		return -0x6380;
	}
	if input == output && (ctx.unprocessed_len != 0 || ilen % block_size)
	{
		return -0x6100;
	}
	if ctx.cipher_info.mode == MBEDTLS_MODE_CBC
	{
		usize copy_len = 0;
		if (ctx.operation == MBEDTLS_DECRYPT && ilen + ctx.unprocessed_len <= block_size) || (ctx.operation == MBEDTLS_ENCRYPT && ilen + ctx.unprocessed_len < block_size)
		{
			memcpy(&(ctx.unprocessed_data[ctx.unprocessed_len]), input, ilen);
			ctx.unprocessed_len += ilen;
			return 0;
		}
		if 0 != ctx.unprocessed_len
		{
			copy_len = block_size - ctx.unprocessed_len;
			memcpy(&(ctx.unprocessed_data[ctx.unprocessed_len]), input, copy_len);
			if 0 != (ret = ctx.cipher_info.base.cbc_func(ctx.cipher_ctx, ctx.operation, block_size, ctx.iv, ctx.unprocessed_data, output))
			{
				return ret;
			}
			*olen += block_size;
			output += block_size;
			ctx.unprocessed_len = 0;
			input += copy_len;
			ilen -= copy_len;
		}
		if 0 != ilen
		{
			if 0 == block_size
			{
				return -0x6380;
			}
			copy_len = ilen % block_size;
			if copy_len == 0 && ctx.operation == MBEDTLS_DECRYPT
			{
				copy_len = block_size;
			}
			memcpy(ctx.unprocessed_data, &(input[ilen - copy_len]), copy_len);
			ctx.unprocessed_len += copy_len;
			ilen -= copy_len;
		}
		if ilen
		{
			if 0 != (ret = ctx.cipher_info.base.cbc_func(ctx.cipher_ctx, ctx.operation, ilen, ctx.iv, input, output))
			{
				return ret;
			}
			*olen += ilen;
		}
		return 0;
	}
	if ctx.cipher_info.mode == MBEDTLS_MODE_CFB
	{
		if 0 != (ret = ctx.cipher_info.base.cfb_func(ctx.cipher_ctx, ctx.operation, ilen, &ctx.unprocessed_len, ctx.iv, input, output))
		{
			return ret;
		}
		*olen = ilen;
		return 0;
	}
	if ctx.cipher_info.mode == MBEDTLS_MODE_CTR
	{
		if 0 != (ret = ctx.cipher_info.base.ctr_func(ctx.cipher_ctx, ilen, &ctx.unprocessed_len, ctx.iv, ctx.unprocessed_data, input, output))
		{
			return ret;
		}
		*olen = ilen;
		return 0;
	}
	return -0x6080;
}

fn add_pkcs_padding(u8 * output, usize output_len, usize data_len)
{
	usize padding_len = output_len - data_len;
	u8 i;
	for (i = 0; i < padding_len; i++)
	{
		output[data_len + i] = (i8) padding_len;
	}
}

fn get_pkcs_padding(u8 * input, usize input_len, usize * data_len) -> i32
{
	usize i, pad_idx;
	u8 padding_len, bad = 0;
	if NULL == input || NULL == data_len
	{
		return -0x6100;
	}
	padding_len = input[input_len - 1];
	*data_len = input_len - padding_len;
	bad |= padding_len > input_len;
	bad |= padding_len == 0;
	pad_idx = input_len - padding_len;
	for (i = 0; i < input_len; i++)
	{
		bad |= (input[i] ^ padding_len) * (i >= pad_idx);
	}
	return -0x6200 * (bad != 0);
}

fn add_one_and_zeros_padding(u8 * output, usize output_len, usize data_len)
{
	usize padding_len = output_len - data_len;
	u8 i = 0;
	output[data_len] = 0x80;
	for (i = 1; i < padding_len; i++)
	{
		output[data_len + i] = 0x00;
	}
}

fn get_one_and_zeros_padding(u8 * input, usize input_len, usize * data_len) -> i32
{
	usize i;
	u8 done = 0, prev_done, bad;
	if NULL == input || NULL == data_len
	{
		return -0x6100;
	}
	bad = 0xFF;
	*data_len = 0;
	for (i = input_len; i > 0; i--)
	{
		prev_done = done;
		done |= (input[i - 1] != 0);
		*data_len |= (i - 1) * (done != prev_done);
		bad &= (input[i - 1] ^ 0x80) | (done == prev_done);
	}
	return -0x6200 * (bad != 0);
}

fn add_zeros_and_len_padding(u8 * output, usize output_len, usize data_len)
{
	usize padding_len = output_len - data_len;
	u8 i = 0;
	for (i = 1; i < padding_len; i++)
	{
		output[data_len + i - 1] = 0x00;
	}
	output[output_len - 1] = (i8) padding_len;
}

fn get_zeros_and_len_padding(u8 * input, usize input_len, usize * data_len) -> i32
{
	usize i, pad_idx;
	u8 padding_len, bad = 0;
	if NULL == input || NULL == data_len
	{
		return -0x6100;
	}
	padding_len = input[input_len - 1];
	*data_len = input_len - padding_len;
	bad |= padding_len > input_len;
	bad |= padding_len == 0;
	pad_idx = input_len - padding_len;
	for (i = 0; i < input_len - 1; i++)
	{
		bad |= input[i] * (i >= pad_idx);
	}
	return -0x6200 * (bad != 0);
}

fn add_zeros_padding(u8 * output, usize output_len, usize data_len)
{
	usize i;
	for (i = data_len; i < output_len; i++)
	{
		output[i] = 0x00;
	}
}

fn get_zeros_padding(u8 * input, usize input_len, usize * data_len) -> i32
{
	usize i;
	u8 done = 0, prev_done;
	if NULL == input || NULL == data_len
	{
		return -0x6100;
	}
	*data_len = 0;
	for (i = input_len; i > 0; i--)
	{
		prev_done = done;
		done |= (input[i - 1] != 0);
		*data_len |= i * (done != prev_done);
	}
	return 0;
}

fn get_no_padding(u8 * input, usize input_len, usize * data_len) -> i32
{
	if NULL == input || NULL == data_len
	{
		return -0x6100;
	}
	*data_len = input_len;
	return 0;
}

pub fn mbedtls_cipher_finish(mbedtls_cipher_context_t * ctx, u8 * output, usize * olen) -> i32
{
	if NULL == ctx || NULL == ctx.cipher_info || NULL == olen
	{
		return -0x6100;
	}
	*olen = 0;
	if MBEDTLS_MODE_CFB == ctx.cipher_info.mode || MBEDTLS_MODE_CTR == ctx.cipher_info.mode || MBEDTLS_MODE_GCM == ctx.cipher_info.mode || MBEDTLS_MODE_STREAM == ctx.cipher_info.mode
	{
		return 0;
	}
	if MBEDTLS_MODE_ECB == ctx.cipher_info.mode
	{
		if ctx.unprocessed_len != 0
		{
			return -0x6280;
		}
		return 0;
	}
	if MBEDTLS_MODE_CBC == ctx.cipher_info.mode
	{
		i32 ret = 0;
		if MBEDTLS_ENCRYPT == ctx.operation
		{
			if NULL == ctx.add_padding
			{
				if 0 != ctx.unprocessed_len
				{
					return -0x6280;
				}
				return 0;
			}
			ctx.add_padding(ctx.unprocessed_data, mbedtls_cipher_get_iv_size(ctx), ctx.unprocessed_len);
		}
		else
			if mbedtls_cipher_get_block_size(ctx) != ctx.unprocessed_len
			{
				if NULL == ctx.add_padding && 0 == ctx.unprocessed_len
				{
					return 0;
				}
				return -0x6280;
			}
		if 0 != (ret = ctx.cipher_info.base.cbc_func(ctx.cipher_ctx, ctx.operation, mbedtls_cipher_get_block_size(ctx), ctx.iv, ctx.unprocessed_data, output))
		{
			return ret;
		}
		if MBEDTLS_DECRYPT == ctx.operation
		{
			return ctx.get_padding(output, mbedtls_cipher_get_block_size(ctx), olen);
		}
		*olen = mbedtls_cipher_get_block_size(ctx);
		return 0;
	}
	return -0x6080;
}

pub fn mbedtls_cipher_set_padding_mode(mbedtls_cipher_context_t * ctx, mbedtls_cipher_padding_t mode) -> i32
{
	if NULL == ctx || MBEDTLS_MODE_CBC != ctx.cipher_info.mode
	{
		return -0x6100;
	}
	switch (mode)
	{
		case MBEDTLS_PADDING_PKCS7:
		ctx.add_padding = add_pkcs_padding;
		ctx.get_padding = get_pkcs_padding;
		break;

		case MBEDTLS_PADDING_ONE_AND_ZEROS:
		ctx.add_padding = add_one_and_zeros_padding;
		ctx.get_padding = get_one_and_zeros_padding;
		break;

		case MBEDTLS_PADDING_ZEROS_AND_LEN:
		ctx.add_padding = add_zeros_and_len_padding;
		ctx.get_padding = get_zeros_and_len_padding;
		break;

		case MBEDTLS_PADDING_ZEROS:
		ctx.add_padding = add_zeros_padding;
		ctx.get_padding = get_zeros_padding;
		break;

		case MBEDTLS_PADDING_NONE:
		ctx.add_padding = NULL;
		ctx.get_padding = get_no_padding;
		break;

	default:
		return -0x6080;
	}
	return 0;
}

pub fn mbedtls_cipher_write_tag(mbedtls_cipher_context_t * ctx, u8 * tag, usize tag_len) -> i32
{
	if NULL == ctx || NULL == ctx.cipher_info || NULL == tag
	{
		return -0x6100;
	}
	if MBEDTLS_ENCRYPT != ctx.operation
	{
		return -0x6100;
	}
	if MBEDTLS_MODE_GCM == ctx.cipher_info.mode
	{
		return mbedtls_gcm_finish((mbedtls_gcm_context *) ctx.cipher_ctx, tag, tag_len);
	}
	return 0;
}

pub fn mbedtls_cipher_check_tag(mbedtls_cipher_context_t * ctx, const u8 * tag, usize tag_len) -> i32
{
	i32 ret;
	if NULL == ctx || NULL == ctx.cipher_info || MBEDTLS_DECRYPT != ctx.operation
	{
		return -0x6100;
	}
	if MBEDTLS_MODE_GCM == ctx.cipher_info.mode
	{
		u8 check_tag[16];
		usize i;
		i32 diff;
		if tag_len > sizeof(check_tag)
		{
			return -0x6100;
		}
		if 0 != (ret = mbedtls_gcm_finish((mbedtls_gcm_context *) ctx.cipher_ctx, check_tag, tag_len))
		{
			return ret;
		}
		for (diff = 0, i = 0; i < tag_len; i++)
		{
			diff |= tag[i] ^ check_tag[i];
		}
		if diff != 0
		{
			return -0x6300;
		}
		return 0;
	}
	return 0;
}

pub fn mbedtls_cipher_crypt(mbedtls_cipher_context_t * ctx, const u8 * iv, usize iv_len, const u8 * input, usize ilen, u8 * output, usize * olen) -> i32
{
	i32 ret;
	usize finish_olen;
	if (ret = mbedtls_cipher_set_iv(ctx, iv, iv_len)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_cipher_reset(ctx)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_cipher_update(ctx, input, ilen, output, olen)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_cipher_finish(ctx, output + *olen, &finish_olen)) != 0
	{
		return ret;
	}
	*olen += finish_olen;
	return 0;
}

pub fn mbedtls_cipher_auth_encrypt(mbedtls_cipher_context_t * ctx, const u8 * iv, usize iv_len, const u8 * ad, usize ad_len, const u8 * input, usize ilen, u8 * output, usize * olen, u8 * tag, usize tag_len) -> i32
{
	if MBEDTLS_MODE_GCM == ctx.cipher_info.mode
	{
		*olen = ilen;
		return mbedtls_gcm_crypt_and_tag(ctx.cipher_ctx, 1, ilen, iv, iv_len, ad, ad_len, input, output, tag_len, tag);
	}
	if MBEDTLS_MODE_CCM == ctx.cipher_info.mode
	{
		*olen = ilen;
		return mbedtls_ccm_encrypt_and_tag(ctx.cipher_ctx, ilen, iv, iv_len, ad, ad_len, input, output, tag, tag_len);
	}
	return -0x6080;
}

pub fn mbedtls_cipher_auth_decrypt(mbedtls_cipher_context_t * ctx, const u8 * iv, usize iv_len, const u8 * ad, usize ad_len, const u8 * input, usize ilen, u8 * output, usize * olen, const u8 * tag, usize tag_len) -> i32
{
	if MBEDTLS_MODE_GCM == ctx.cipher_info.mode
	{
		i32 ret;
		*olen = ilen;
		ret = mbedtls_gcm_auth_decrypt(ctx.cipher_ctx, ilen, iv, iv_len, ad, ad_len, tag, tag_len, input, output);
		if ret == -0x0012
		{
			ret = -0x6300;
		}
		return ret;
	}
	if MBEDTLS_MODE_CCM == ctx.cipher_info.mode
	{
		i32 ret;
		*olen = ilen;
		ret = mbedtls_ccm_auth_decrypt(ctx.cipher_ctx, ilen, iv, iv_len, ad, ad_len, input, output, tag, tag_len);
		if ret == -0x000F
		{
			ret = -0x6300;
		}
		return ret;
	}
	return -0x6080;
}

typedef struct
{
	u32 sk[32];
} mbedtls_des_context;
typedef struct
{
	u32 sk[96];
} mbedtls_des3_context;

fn * gcm_ctx_alloc()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_gcm_context));
	if ctx != NULL
	{
		mbedtls_gcm_init((mbedtls_gcm_context *) ctx);
	}
	return ctx;
}

fn gcm_ctx_free(void * ctx)
{
	mbedtls_gcm_free(ctx);
	mbedtls_free(ctx);
}

fn * ccm_ctx_alloc()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_ccm_context));
	if ctx != NULL
	{
		mbedtls_ccm_init((mbedtls_ccm_context *) ctx);
	}
	return ctx;
}

fn ccm_ctx_free(void * ctx)
{
	mbedtls_ccm_free(ctx);
	mbedtls_free(ctx);
}

fn aes_crypt_ecb_wrap(void * ctx, mbedtls_operation_t operation, const u8 * input, u8 * output) -> i32
{
	return mbedtls_aes_crypt_ecb((mbedtls_aes_context *) ctx, operation, input, output);
}

fn aes_crypt_cbc_wrap(void * ctx, mbedtls_operation_t operation, usize length, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_aes_crypt_cbc((mbedtls_aes_context *) ctx, operation, length, iv, input, output);
}

fn aes_crypt_cfb128_wrap(void * ctx, mbedtls_operation_t operation, usize length, usize * iv_off, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_aes_crypt_cfb128((mbedtls_aes_context *) ctx, operation, length, iv_off, iv, input, output);
}

fn aes_crypt_ctr_wrap(void * ctx, usize length, usize * nc_off, u8 * nonce_counter, u8 * stream_block, const u8 * input, u8 * output) -> i32
{
	return mbedtls_aes_crypt_ctr((mbedtls_aes_context *) ctx, length, nc_off, nonce_counter, stream_block, input, output);
}

fn aes_setkey_dec_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_aes_setkey_dec((mbedtls_aes_context *) ctx, key, key_bitlen);
}

fn aes_setkey_enc_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_aes_setkey_enc((mbedtls_aes_context *) ctx, key, key_bitlen);
}

fn * aes_ctx_alloc()
{
	mbedtls_aes_context * aes = mbedtls_calloc(1, sizeof(mbedtls_aes_context));
	if aes == NULL
	{
		return NULL;
	}
	mbedtls_aes_init(aes);
	return aes;
}

fn aes_ctx_free(void * ctx)
{
	mbedtls_aes_free((mbedtls_aes_context *) ctx);
	mbedtls_free(ctx);
}

static const mbedtls_cipher_base_t aes_info = {MBEDTLS_CIPHER_ID_AES, aes_crypt_ecb_wrap, aes_crypt_cbc_wrap, aes_crypt_cfb128_wrap, aes_crypt_ctr_wrap, aes_setkey_enc_wrap, aes_setkey_dec_wrap, aes_ctx_alloc, aes_ctx_free};
static const mbedtls_cipher_info_t aes_128_ecb_info = {MBEDTLS_CIPHER_AES_128_ECB, MBEDTLS_MODE_ECB, 128, "AES-128-ECB", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_192_ecb_info = {MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_MODE_ECB, 192, "AES-192-ECB", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_256_ecb_info = {MBEDTLS_CIPHER_AES_256_ECB, MBEDTLS_MODE_ECB, 256, "AES-256-ECB", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_128_cbc_info = {MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MODE_CBC, 128, "AES-128-CBC", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_192_cbc_info = {MBEDTLS_CIPHER_AES_192_CBC, MBEDTLS_MODE_CBC, 192, "AES-192-CBC", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_256_cbc_info = {MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MODE_CBC, 256, "AES-256-CBC", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_128_cfb128_info = {MBEDTLS_CIPHER_AES_128_CFB128, MBEDTLS_MODE_CFB, 128, "AES-128-CFB128", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_192_cfb128_info = {MBEDTLS_CIPHER_AES_192_CFB128, MBEDTLS_MODE_CFB, 192, "AES-192-CFB128", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_256_cfb128_info = {MBEDTLS_CIPHER_AES_256_CFB128, MBEDTLS_MODE_CFB, 256, "AES-256-CFB128", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_128_ctr_info = {MBEDTLS_CIPHER_AES_128_CTR, MBEDTLS_MODE_CTR, 128, "AES-128-CTR", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_192_ctr_info = {MBEDTLS_CIPHER_AES_192_CTR, MBEDTLS_MODE_CTR, 192, "AES-192-CTR", 16, 0, 16, &aes_info};
static const mbedtls_cipher_info_t aes_256_ctr_info = {MBEDTLS_CIPHER_AES_256_CTR, MBEDTLS_MODE_CTR, 256, "AES-256-CTR", 16, 0, 16, &aes_info};
fn gcm_aes_setkey_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_gcm_setkey((mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_AES, key, key_bitlen);
}

static const mbedtls_cipher_base_t gcm_aes_info =
{
	MBEDTLS_CIPHER_ID_AES, NULL, NULL, NULL, NULL, gcm_aes_setkey_wrap, gcm_aes_setkey_wrap, gcm_ctx_alloc, gcm_ctx_free,
};
static const mbedtls_cipher_info_t aes_128_gcm_info = {MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MODE_GCM, 128, "AES-128-GCM", 12, 0x01, 16, &gcm_aes_info};
static const mbedtls_cipher_info_t aes_192_gcm_info = {MBEDTLS_CIPHER_AES_192_GCM, MBEDTLS_MODE_GCM, 192, "AES-192-GCM", 12, 0x01, 16, &gcm_aes_info};
static const mbedtls_cipher_info_t aes_256_gcm_info = {MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MODE_GCM, 256, "AES-256-GCM", 12, 0x01, 16, &gcm_aes_info};
fn ccm_aes_setkey_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_ccm_setkey((mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_AES, key, key_bitlen);
}

static const mbedtls_cipher_base_t ccm_aes_info =
{
	MBEDTLS_CIPHER_ID_AES, NULL, NULL, NULL, NULL, ccm_aes_setkey_wrap, ccm_aes_setkey_wrap, ccm_ctx_alloc, ccm_ctx_free,
};
static const mbedtls_cipher_info_t aes_128_ccm_info = {MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MODE_CCM, 128, "AES-128-CCM", 12, 0x01, 16, &ccm_aes_info};
static const mbedtls_cipher_info_t aes_192_ccm_info = {MBEDTLS_CIPHER_AES_192_CCM, MBEDTLS_MODE_CCM, 192, "AES-192-CCM", 12, 0x01, 16, &ccm_aes_info};
static const mbedtls_cipher_info_t aes_256_ccm_info = {MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MODE_CCM, 256, "AES-256-CCM", 12, 0x01, 16, &ccm_aes_info};
fn camellia_crypt_ecb_wrap(void * ctx, mbedtls_operation_t operation, const u8 * input, u8 * output) -> i32
{
	return mbedtls_camellia_crypt_ecb((mbedtls_camellia_context *) ctx, operation, input, output);
}

fn camellia_crypt_cbc_wrap(void * ctx, mbedtls_operation_t operation, usize length, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_camellia_crypt_cbc((mbedtls_camellia_context *) ctx, operation, length, iv, input, output);
}

fn camellia_crypt_cfb128_wrap(void * ctx, mbedtls_operation_t operation, usize length, usize * iv_off, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_camellia_crypt_cfb128((mbedtls_camellia_context *) ctx, operation, length, iv_off, iv, input, output);
}

fn camellia_crypt_ctr_wrap(void * ctx, usize length, usize * nc_off, u8 * nonce_counter, u8 * stream_block, const u8 * input, u8 * output) -> i32
{
	return mbedtls_camellia_crypt_ctr((mbedtls_camellia_context *) ctx, length, nc_off, nonce_counter, stream_block, input, output);
}

fn camellia_setkey_dec_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_camellia_setkey_dec((mbedtls_camellia_context *) ctx, key, key_bitlen);
}

fn camellia_setkey_enc_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_camellia_setkey_enc((mbedtls_camellia_context *) ctx, key, key_bitlen);
}

fn * camellia_ctx_alloc()
{
	mbedtls_camellia_context * ctx;
	ctx = mbedtls_calloc(1, sizeof(mbedtls_camellia_context));
	if ctx == NULL
	{
		return NULL;
	}
	mbedtls_camellia_init(ctx);
	return ctx;
}

fn camellia_ctx_free(void * ctx)
{
	mbedtls_camellia_free((mbedtls_camellia_context *) ctx);
	mbedtls_free(ctx);
}

static const mbedtls_cipher_base_t camellia_info = {MBEDTLS_CIPHER_ID_CAMELLIA, camellia_crypt_ecb_wrap, camellia_crypt_cbc_wrap, camellia_crypt_cfb128_wrap, camellia_crypt_ctr_wrap, camellia_setkey_enc_wrap, camellia_setkey_dec_wrap, camellia_ctx_alloc, camellia_ctx_free};
static const mbedtls_cipher_info_t camellia_128_ecb_info = {MBEDTLS_CIPHER_CAMELLIA_128_ECB, MBEDTLS_MODE_ECB, 128, "CAMELLIA-128-ECB", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_192_ecb_info = {MBEDTLS_CIPHER_CAMELLIA_192_ECB, MBEDTLS_MODE_ECB, 192, "CAMELLIA-192-ECB", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_256_ecb_info = {MBEDTLS_CIPHER_CAMELLIA_256_ECB, MBEDTLS_MODE_ECB, 256, "CAMELLIA-256-ECB", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_128_cbc_info = {MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MODE_CBC, 128, "CAMELLIA-128-CBC", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_192_cbc_info = {MBEDTLS_CIPHER_CAMELLIA_192_CBC, MBEDTLS_MODE_CBC, 192, "CAMELLIA-192-CBC", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_256_cbc_info = {MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MODE_CBC, 256, "CAMELLIA-256-CBC", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_128_cfb128_info = {MBEDTLS_CIPHER_CAMELLIA_128_CFB128, MBEDTLS_MODE_CFB, 128, "CAMELLIA-128-CFB128", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_192_cfb128_info = {MBEDTLS_CIPHER_CAMELLIA_192_CFB128, MBEDTLS_MODE_CFB, 192, "CAMELLIA-192-CFB128", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_256_cfb128_info = {MBEDTLS_CIPHER_CAMELLIA_256_CFB128, MBEDTLS_MODE_CFB, 256, "CAMELLIA-256-CFB128", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_128_ctr_info = {MBEDTLS_CIPHER_CAMELLIA_128_CTR, MBEDTLS_MODE_CTR, 128, "CAMELLIA-128-CTR", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_192_ctr_info = {MBEDTLS_CIPHER_CAMELLIA_192_CTR, MBEDTLS_MODE_CTR, 192, "CAMELLIA-192-CTR", 16, 0, 16, &camellia_info};
static const mbedtls_cipher_info_t camellia_256_ctr_info = {MBEDTLS_CIPHER_CAMELLIA_256_CTR, MBEDTLS_MODE_CTR, 256, "CAMELLIA-256-CTR", 16, 0, 16, &camellia_info};
fn gcm_camellia_setkey_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_gcm_setkey((mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_CAMELLIA, key, key_bitlen);
}

static const mbedtls_cipher_base_t gcm_camellia_info =
{
	MBEDTLS_CIPHER_ID_CAMELLIA, NULL, NULL, NULL, NULL, gcm_camellia_setkey_wrap, gcm_camellia_setkey_wrap, gcm_ctx_alloc, gcm_ctx_free,
};
static const mbedtls_cipher_info_t camellia_128_gcm_info = {MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MODE_GCM, 128, "CAMELLIA-128-GCM", 12, 0x01, 16, &gcm_camellia_info};
static const mbedtls_cipher_info_t camellia_192_gcm_info = {MBEDTLS_CIPHER_CAMELLIA_192_GCM, MBEDTLS_MODE_GCM, 192, "CAMELLIA-192-GCM", 12, 0x01, 16, &gcm_camellia_info};
static const mbedtls_cipher_info_t camellia_256_gcm_info = {MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MODE_GCM, 256, "CAMELLIA-256-GCM", 12, 0x01, 16, &gcm_camellia_info};
fn ccm_camellia_setkey_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_ccm_setkey((mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_CAMELLIA, key, key_bitlen);
}

static const mbedtls_cipher_base_t ccm_camellia_info =
{
	MBEDTLS_CIPHER_ID_CAMELLIA, NULL, NULL, NULL, NULL, ccm_camellia_setkey_wrap, ccm_camellia_setkey_wrap, ccm_ctx_alloc, ccm_ctx_free,
};
static const mbedtls_cipher_info_t camellia_128_ccm_info = {MBEDTLS_CIPHER_CAMELLIA_128_CCM, MBEDTLS_MODE_CCM, 128, "CAMELLIA-128-CCM", 12, 0x01, 16, &ccm_camellia_info};
static const mbedtls_cipher_info_t camellia_192_ccm_info = {MBEDTLS_CIPHER_CAMELLIA_192_CCM, MBEDTLS_MODE_CCM, 192, "CAMELLIA-192-CCM", 12, 0x01, 16, &ccm_camellia_info};
static const mbedtls_cipher_info_t camellia_256_ccm_info = {MBEDTLS_CIPHER_CAMELLIA_256_CCM, MBEDTLS_MODE_CCM, 256, "CAMELLIA-256-CCM", 12, 0x01, 16, &ccm_camellia_info};
fn des_crypt_ecb_wrap(void * ctx, mbedtls_operation_t operation, const u8 * input, u8 * output) -> i32
{
	((void) operation);
	return mbedtls_des_crypt_ecb((mbedtls_des_context *) ctx, input, output);
}

fn des3_crypt_ecb_wrap(void * ctx, mbedtls_operation_t operation, const u8 * input, u8 * output) -> i32
{
	((void) operation);
	return mbedtls_des3_crypt_ecb((mbedtls_des3_context *) ctx, input, output);
}

fn des_crypt_cbc_wrap(void * ctx, mbedtls_operation_t operation, usize length, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_des_crypt_cbc((mbedtls_des_context *) ctx, operation, length, iv, input, output);
}

fn des3_crypt_cbc_wrap(void * ctx, mbedtls_operation_t operation, usize length, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_des3_crypt_cbc((mbedtls_des3_context *) ctx, operation, length, iv, input, output);
}

fn des_setkey_dec_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	((void) key_bitlen);
	return mbedtls_des_setkey_dec((mbedtls_des_context *) ctx, key);
}

fn des_setkey_enc_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	((void) key_bitlen);
	return mbedtls_des_setkey_enc((mbedtls_des_context *) ctx, key);
}

fn des3_set2key_dec_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	((void) key_bitlen);
	return mbedtls_des3_set2key_dec((mbedtls_des3_context *) ctx, key);
}

fn des3_set2key_enc_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	((void) key_bitlen);
	return mbedtls_des3_set2key_enc((mbedtls_des3_context *) ctx, key);
}

fn des3_set3key_dec_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	((void) key_bitlen);
	return mbedtls_des3_set3key_dec((mbedtls_des3_context *) ctx, key);
}

fn des3_set3key_enc_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	((void) key_bitlen);
	return mbedtls_des3_set3key_enc((mbedtls_des3_context *) ctx, key);
}

fn * des_ctx_alloc()
{
	mbedtls_des_context * des = mbedtls_calloc(1, sizeof(mbedtls_des_context));
	if des == NULL
	{
		return NULL;
	}
	mbedtls_des_init(des);
	return des;
}

fn des_ctx_free(void * ctx)
{
	mbedtls_des_free((mbedtls_des_context *) ctx);
	mbedtls_free(ctx);
}

fn * des3_ctx_alloc()
{
	mbedtls_des3_context * des3;
	des3 = mbedtls_calloc(1, sizeof(mbedtls_des3_context));
	if des3 == NULL
	{
		return NULL;
	}
	mbedtls_des3_init(des3);
	return des3;
}

fn des3_ctx_free(void * ctx)
{
	mbedtls_des3_free((mbedtls_des3_context *) ctx);
	mbedtls_free(ctx);
}

static const mbedtls_cipher_base_t des_info = {MBEDTLS_CIPHER_ID_DES, des_crypt_ecb_wrap, des_crypt_cbc_wrap, NULL, NULL, des_setkey_enc_wrap, des_setkey_dec_wrap, des_ctx_alloc, des_ctx_free};
static const mbedtls_cipher_info_t des_ecb_info = {MBEDTLS_CIPHER_DES_ECB, MBEDTLS_MODE_ECB, MBEDTLS_KEY_LENGTH_DES, "DES-ECB", 8, 0, 8, &des_info};
static const mbedtls_cipher_info_t des_cbc_info = {MBEDTLS_CIPHER_DES_CBC, MBEDTLS_MODE_CBC, MBEDTLS_KEY_LENGTH_DES, "DES-CBC", 8, 0, 8, &des_info};
static const mbedtls_cipher_base_t des_ede_info = {MBEDTLS_CIPHER_ID_DES, des3_crypt_ecb_wrap, des3_crypt_cbc_wrap, NULL, NULL, des3_set2key_enc_wrap, des3_set2key_dec_wrap, des3_ctx_alloc, des3_ctx_free};
static const mbedtls_cipher_info_t des_ede_ecb_info = {MBEDTLS_CIPHER_DES_EDE_ECB, MBEDTLS_MODE_ECB, MBEDTLS_KEY_LENGTH_DES_EDE, "DES-EDE-ECB", 8, 0, 8, &des_ede_info};
static const mbedtls_cipher_info_t des_ede_cbc_info = {MBEDTLS_CIPHER_DES_EDE_CBC, MBEDTLS_MODE_CBC, MBEDTLS_KEY_LENGTH_DES_EDE, "DES-EDE-CBC", 8, 0, 8, &des_ede_info};
static const mbedtls_cipher_base_t des_ede3_info = {MBEDTLS_CIPHER_ID_3DES, des3_crypt_ecb_wrap, des3_crypt_cbc_wrap, NULL, NULL, des3_set3key_enc_wrap, des3_set3key_dec_wrap, des3_ctx_alloc, des3_ctx_free};
static const mbedtls_cipher_info_t des_ede3_ecb_info = {MBEDTLS_CIPHER_DES_EDE3_ECB, MBEDTLS_MODE_ECB, MBEDTLS_KEY_LENGTH_DES_EDE3, "DES-EDE3-ECB", 8, 0, 8, &des_ede3_info};
static const mbedtls_cipher_info_t des_ede3_cbc_info = {MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MODE_CBC, MBEDTLS_KEY_LENGTH_DES_EDE3, "DES-EDE3-CBC", 8, 0, 8, &des_ede3_info};
fn blowfish_crypt_ecb_wrap(void * ctx, mbedtls_operation_t operation, const u8 * input, u8 * output) -> i32
{
	return mbedtls_blowfish_crypt_ecb((mbedtls_blowfish_context *) ctx, operation, input, output);
}

fn blowfish_crypt_cbc_wrap(void * ctx, mbedtls_operation_t operation, usize length, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_blowfish_crypt_cbc((mbedtls_blowfish_context *) ctx, operation, length, iv, input, output);
}

fn blowfish_crypt_cfb64_wrap(void * ctx, mbedtls_operation_t operation, usize length, usize * iv_off, u8 * iv, const u8 * input, u8 * output) -> i32
{
	return mbedtls_blowfish_crypt_cfb64((mbedtls_blowfish_context *) ctx, operation, length, iv_off, iv, input, output);
}

fn blowfish_crypt_ctr_wrap(void * ctx, usize length, usize * nc_off, u8 * nonce_counter, u8 * stream_block, const u8 * input, u8 * output) -> i32
{
	return mbedtls_blowfish_crypt_ctr((mbedtls_blowfish_context *) ctx, length, nc_off, nonce_counter, stream_block, input, output);
}

fn blowfish_setkey_wrap(void * ctx, const u8 * key, u32 key_bitlen) -> i32
{
	return mbedtls_blowfish_setkey((mbedtls_blowfish_context *) ctx, key, key_bitlen);
}

fn * blowfish_ctx_alloc()
{
	mbedtls_blowfish_context * ctx;
	ctx = mbedtls_calloc(1, sizeof(mbedtls_blowfish_context));
	if ctx == NULL
	{
		return NULL;
	}
	mbedtls_blowfish_init(ctx);
	return ctx;
}

fn blowfish_ctx_free(void * ctx)
{
	mbedtls_blowfish_free((mbedtls_blowfish_context *) ctx);
	mbedtls_free(ctx);
}

static const mbedtls_cipher_base_t blowfish_info = {MBEDTLS_CIPHER_ID_BLOWFISH, blowfish_crypt_ecb_wrap, blowfish_crypt_cbc_wrap, blowfish_crypt_cfb64_wrap, blowfish_crypt_ctr_wrap, blowfish_setkey_wrap, blowfish_setkey_wrap, blowfish_ctx_alloc, blowfish_ctx_free};
static const mbedtls_cipher_info_t blowfish_ecb_info = {MBEDTLS_CIPHER_BLOWFISH_ECB, MBEDTLS_MODE_ECB, 128, "BLOWFISH-ECB", 8, 0x02, 8, &blowfish_info};
static const mbedtls_cipher_info_t blowfish_cbc_info = {MBEDTLS_CIPHER_BLOWFISH_CBC, MBEDTLS_MODE_CBC, 128, "BLOWFISH-CBC", 8, 0x02, 8, &blowfish_info};
static const mbedtls_cipher_info_t blowfish_cfb64_info = {MBEDTLS_CIPHER_BLOWFISH_CFB64, MBEDTLS_MODE_CFB, 128, "BLOWFISH-CFB64", 8, 0x02, 8, &blowfish_info};
static const mbedtls_cipher_info_t blowfish_ctr_info = {MBEDTLS_CIPHER_BLOWFISH_CTR, MBEDTLS_MODE_CTR, 128, "BLOWFISH-CTR", 8, 0x02, 8, &blowfish_info};
const mbedtls_cipher_definition_t mbedtls_cipher_definitions[] = {{MBEDTLS_CIPHER_AES_128_ECB, &aes_128_ecb_info}, {MBEDTLS_CIPHER_AES_192_ECB, &aes_192_ecb_info}, {MBEDTLS_CIPHER_AES_256_ECB, &aes_256_ecb_info}, {MBEDTLS_CIPHER_AES_128_CBC, &aes_128_cbc_info}, {MBEDTLS_CIPHER_AES_192_CBC, &aes_192_cbc_info}, {MBEDTLS_CIPHER_AES_256_CBC, &aes_256_cbc_info}, {MBEDTLS_CIPHER_AES_128_CFB128, &aes_128_cfb128_info}, {MBEDTLS_CIPHER_AES_192_CFB128, &aes_192_cfb128_info}, {MBEDTLS_CIPHER_AES_256_CFB128, &aes_256_cfb128_info}, {MBEDTLS_CIPHER_AES_128_CTR, &aes_128_ctr_info}, {MBEDTLS_CIPHER_AES_192_CTR, &aes_192_ctr_info}, {MBEDTLS_CIPHER_AES_256_CTR, &aes_256_ctr_info}, {MBEDTLS_CIPHER_AES_128_GCM, &aes_128_gcm_info}, {MBEDTLS_CIPHER_AES_192_GCM, &aes_192_gcm_info}, {MBEDTLS_CIPHER_AES_256_GCM, &aes_256_gcm_info}, {MBEDTLS_CIPHER_AES_128_CCM, &aes_128_ccm_info}, {MBEDTLS_CIPHER_AES_192_CCM, &aes_192_ccm_info}, {MBEDTLS_CIPHER_AES_256_CCM, &aes_256_ccm_info}, {MBEDTLS_CIPHER_BLOWFISH_ECB, &blowfish_ecb_info}, {MBEDTLS_CIPHER_BLOWFISH_CBC, &blowfish_cbc_info}, {MBEDTLS_CIPHER_BLOWFISH_CFB64, &blowfish_cfb64_info}, {MBEDTLS_CIPHER_BLOWFISH_CTR, &blowfish_ctr_info}, {MBEDTLS_CIPHER_CAMELLIA_128_ECB, &camellia_128_ecb_info}, {MBEDTLS_CIPHER_CAMELLIA_192_ECB, &camellia_192_ecb_info}, {MBEDTLS_CIPHER_CAMELLIA_256_ECB, &camellia_256_ecb_info}, {MBEDTLS_CIPHER_CAMELLIA_128_CBC, &camellia_128_cbc_info}, {MBEDTLS_CIPHER_CAMELLIA_192_CBC, &camellia_192_cbc_info}, {MBEDTLS_CIPHER_CAMELLIA_256_CBC, &camellia_256_cbc_info}, {MBEDTLS_CIPHER_CAMELLIA_128_CFB128, &camellia_128_cfb128_info}, {MBEDTLS_CIPHER_CAMELLIA_192_CFB128, &camellia_192_cfb128_info}, {MBEDTLS_CIPHER_CAMELLIA_256_CFB128, &camellia_256_cfb128_info}, {MBEDTLS_CIPHER_CAMELLIA_128_CTR, &camellia_128_ctr_info}, {MBEDTLS_CIPHER_CAMELLIA_192_CTR, &camellia_192_ctr_info}, {MBEDTLS_CIPHER_CAMELLIA_256_CTR, &camellia_256_ctr_info}, {MBEDTLS_CIPHER_CAMELLIA_128_GCM, &camellia_128_gcm_info}, {MBEDTLS_CIPHER_CAMELLIA_192_GCM, &camellia_192_gcm_info}, {MBEDTLS_CIPHER_CAMELLIA_256_GCM, &camellia_256_gcm_info}, {MBEDTLS_CIPHER_CAMELLIA_128_CCM, &camellia_128_ccm_info}, {MBEDTLS_CIPHER_CAMELLIA_192_CCM, &camellia_192_ccm_info}, {MBEDTLS_CIPHER_CAMELLIA_256_CCM, &camellia_256_ccm_info}, {MBEDTLS_CIPHER_DES_ECB, &des_ecb_info}, {MBEDTLS_CIPHER_DES_EDE_ECB, &des_ede_ecb_info}, {MBEDTLS_CIPHER_DES_EDE3_ECB, &des_ede3_ecb_info}, {MBEDTLS_CIPHER_DES_CBC, &des_cbc_info}, {MBEDTLS_CIPHER_DES_EDE_CBC, &des_ede_cbc_info}, {MBEDTLS_CIPHER_DES_EDE3_CBC, &des_ede3_cbc_info}, {MBEDTLS_CIPHER_NONE, NULL}};
i32 mbedtls_cipher_supported[sizeof mbedtls_cipher_definitions / sizeof mbedtls_cipher_definitions[0]];
typedef struct
{
	pthread_mutex_t mutex;
	i8 is_valid;
} mbedtls_threading_mutex_t;

static mbedtls_threading_mutex_t mbedtls_threading_readdir_mutex;
static mbedtls_threading_mutex_t mbedtls_threading_gmtime_mutex;
typedef struct
{
	u8 counter[16];
	i32 reseed_counter;
	i32 prediction_resistance;
	usize entropy_len;
	i32 reseed_interval;
	mbedtls_aes_context aes_ctx;
	i32 (*f_entropy)(void *, u8 *, usize);
	void * p_entropy;
	mbedtls_threading_mutex_t mutex;
} mbedtls_ctr_drbg_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_ctr_drbg_init(mbedtls_ctr_drbg_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_ctr_drbg_context));
	mbedtls_mutex_init(&ctx.mutex);
}

pub fn mbedtls_ctr_drbg_seed_entropy_len(mbedtls_ctr_drbg_context * ctx, i32 (*f_entropy)(void *, u8 *, usize), void * p_entropy, const u8 * custom, usize len, usize entropy_len) -> i32
{
	i32 ret;
	u8 key[32];
	memset(key, 0, 32);
	mbedtls_aes_init(&ctx.aes_ctx);
	ctx.f_entropy = f_entropy;
	ctx.p_entropy = p_entropy;
	ctx.entropy_len = entropy_len;
	ctx.reseed_interval = 10000;
	mbedtls_aes_setkey_enc(&ctx.aes_ctx, key, (32 * 8));
	if (ret = mbedtls_ctr_drbg_reseed(ctx, custom, len)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_ctr_drbg_seed(mbedtls_ctr_drbg_context * ctx, i32 (*f_entropy)(void *, u8 *, usize), void * p_entropy, const u8 * custom, usize len) -> i32
{
	return mbedtls_ctr_drbg_seed_entropy_len(ctx, f_entropy, p_entropy, custom, len, 48);
}

pub fn mbedtls_ctr_drbg_free(mbedtls_ctr_drbg_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	mbedtls_mutex_free(&ctx.mutex);
	mbedtls_aes_free(&ctx.aes_ctx);
	zeroize(ctx, sizeof(mbedtls_ctr_drbg_context));
}

pub fn mbedtls_ctr_drbg_set_prediction_resistance(mbedtls_ctr_drbg_context * ctx, i32 resistance)
{
	ctx.prediction_resistance = resistance;
}

pub fn mbedtls_ctr_drbg_set_entropy_len(mbedtls_ctr_drbg_context * ctx, usize len)
{
	ctx.entropy_len = len;
}

pub fn mbedtls_ctr_drbg_set_reseed_interval(mbedtls_ctr_drbg_context * ctx, i32 interval)
{
	ctx.reseed_interval = interval;
}

fn block_cipher_df(u8 * output, const u8 * data, usize data_len) -> i32
{
	u8 buf[384 + 16 + 16];
	u8 tmp[(32 + 16)];
	u8 key[32];
	u8 chain[16];
	u8 *p, *iv;
	mbedtls_aes_context aes_ctx;
	i32 i, j;
	usize buf_len, use_len;
	if data_len > 384
	{
		return -0x0038;
	}
	memset(buf, 0, 384 + 16 + 16);
	mbedtls_aes_init(&aes_ctx);
	p = buf + 16;
	*p++ = (data_len >> 24) & 0xff;
	*p++ = (data_len >> 16) & 0xff;
	*p++ = (data_len >> 8) & 0xff;
	*p++ = (data_len) &0xff;
	p += 3;
	*p++ = (32 + 16);
	memcpy(p, data, data_len);
	p[data_len] = 0x80;
	buf_len = 16 + 8 + data_len + 1;
	for (i = 0; i < 32; i++)
	{
		key[i] = i;
	}
	mbedtls_aes_setkey_enc(&aes_ctx, key, (32 * 8));
	for (j = 0; j < (32 + 16); j += 16)
	{
		p = buf;
		memset(chain, 0, 16);
		use_len = buf_len;
		while (use_len > 0)
		{
			for (i = 0; i < 16; i++)
			{
				chain[i] ^= p[i];
			}
			p += 16;
			use_len -= (use_len >= 16) ? 16 : use_len;
			mbedtls_aes_crypt_ecb(&aes_ctx, 1, chain, chain);
		}
		memcpy(tmp + j, chain, 16);
		buf[3]++;
	}
	mbedtls_aes_setkey_enc(&aes_ctx, tmp, (32 * 8));
	iv = tmp + 32;
	p = output;
	for (j = 0; j < (32 + 16); j += 16)
	{
		mbedtls_aes_crypt_ecb(&aes_ctx, 1, iv, iv);
		memcpy(p, iv, 16);
		p += 16;
	}
	mbedtls_aes_free(&aes_ctx);
	return 0;
}

fn ctr_drbg_update_internal(mbedtls_ctr_drbg_context * ctx, const u8 data[(32 + 16)]) -> i32
{
	u8 tmp[(32 + 16)];
	u8 * p = tmp;
	i32 i, j;
	memset(tmp, 0, (32 + 16));
	for (j = 0; j < (32 + 16); j += 16)
	{
		for (i = 16; i > 0; i--)
			if ++ctx.counter[i - 1] != 0
			{
				break;

			}
		mbedtls_aes_crypt_ecb(&ctx.aes_ctx, 1, ctx.counter, p);
		p += 16;
	}
	for (i = 0; i < (32 + 16); i++)
	{
		tmp[i] ^= data[i];
	}
	mbedtls_aes_setkey_enc(&ctx.aes_ctx, tmp, (32 * 8));
	memcpy(ctx.counter, tmp + 32, 16);
	return 0;
}

pub fn mbedtls_ctr_drbg_update(mbedtls_ctr_drbg_context * ctx, const u8 * additional, usize add_len)
{
	u8 add_input[(32 + 16)];
	if add_len > 0
	{
		if add_len > 384
		{
			add_len = 384;
		}
		block_cipher_df(add_input, additional, add_len);
		ctr_drbg_update_internal(ctx, add_input);
	}
}

pub fn mbedtls_ctr_drbg_reseed(mbedtls_ctr_drbg_context * ctx, const u8 * additional, usize len) -> i32
{
	u8 seed[384];
	usize seedlen = 0;
	if ctx.entropy_len + len > 384
	{
		return -0x0038;
	}
	memset(seed, 0, 384);
	if 0 != ctx.f_entropy(ctx.p_entropy, seed, ctx.entropy_len)
	{
		return -0x0034;
	}
	seedlen += ctx.entropy_len;
	if additional && len
	{
		memcpy(seed + seedlen, additional, len);
		seedlen += len;
	}
	block_cipher_df(seed, seed, seedlen);
	ctr_drbg_update_internal(ctx, seed);
	ctx.reseed_counter = 1;
	return 0;
}

pub fn mbedtls_ctr_drbg_random_with_add(void * p_rng, u8 * output, usize output_len, const u8 * additional, usize add_len) -> i32
{
	i32 ret = 0;
	mbedtls_ctr_drbg_context * ctx = (mbedtls_ctr_drbg_context *) p_rng;
	u8 add_input[(32 + 16)];
	u8 * p = output;
	u8 tmp[16];
	i32 i;
	usize use_len;
	if output_len > 1024
	{
		return -0x0036;
	}
	if add_len > 256
	{
		return -0x0038;
	}
	memset(add_input, 0, (32 + 16));
	if ctx.reseed_counter > ctx.reseed_interval || ctx.prediction_resistance
	{
		if (ret = mbedtls_ctr_drbg_reseed(ctx, additional, add_len)) != 0
		{
			return ret;
		}
		add_len = 0;
	}
	if add_len > 0
	{
		block_cipher_df(add_input, additional, add_len);
		ctr_drbg_update_internal(ctx, add_input);
	}
	while (output_len > 0)
	{
		for (i = 16; i > 0; i--)
			if ++ctx.counter[i - 1] != 0
			{
				break;

			}
		mbedtls_aes_crypt_ecb(&ctx.aes_ctx, 1, ctx.counter, tmp);
		use_len = (output_len > 16) ? 16 : output_len;
		memcpy(p, tmp, use_len);
		p += use_len;
		output_len -= use_len;
	}
	ctr_drbg_update_internal(ctx, add_input);
	ctx.reseed_counter++;
	return 0;
}

pub fn mbedtls_ctr_drbg_random(void * p_rng, u8 * output, usize output_len) -> i32
{
	i32 ret;
	mbedtls_ctr_drbg_context * ctx = (mbedtls_ctr_drbg_context *) p_rng;
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	ret = mbedtls_ctr_drbg_random_with_add(ctx, output, output_len, NULL, 0);
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

pub fn mbedtls_ctr_drbg_write_seed_file(mbedtls_ctr_drbg_context * ctx, const i8 * path) -> i32
{
	i32 ret = -0x003A;
	FILE * f;
	u8 buf[256];
	if (f = fopen(path, "wb")) == NULL
	{
		return -0x003A;
	}
	if (ret = mbedtls_ctr_drbg_random(ctx, buf, 256)) != 0
	{
		goto exit;
	}
	if fwrite(buf, 1, 256, f) != 256
	{
		ret = -0x003A;
		goto exit;
	}
	ret = 0;
exit:
	fclose(f);
	return ret;
}

pub fn mbedtls_ctr_drbg_update_seed_file(mbedtls_ctr_drbg_context * ctx, const i8 * path) -> i32
{
	FILE * f;
	usize n;
	u8 buf[256];
	if (f = fopen(path, "rb")) == NULL
	{
		return -0x003A;
	}
	fseek(f, 0, SEEK_END);
	n = (usize) ftell(f);
	fseek(f, 0, SEEK_SET);
	if n > 256
	{
		fclose(f);
		return -0x0038;
	}
	if fread(buf, 1, n, f) != n
	{
		fclose(f);
		return -0x003A;
	}
	fclose(f);
	mbedtls_ctr_drbg_update(ctx, buf, n);
	return mbedtls_ctr_drbg_write_seed_file(ctx, path);
}

static const u8 entropy_source_pr[96] = {0xc1, 0x80, 0x81, 0xa6, 0x5d, 0x44, 0x02, 0x16, 0x19, 0xb3, 0xf1, 0x80, 0xb1, 0xc9, 0x20, 0x02, 0x6a, 0x54, 0x6f, 0x0c, 0x70, 0x81, 0x49, 0x8b, 0x6e, 0xa6, 0x62, 0x52, 0x6d, 0x51, 0xb1, 0xcb, 0x58, 0x3b, 0xfa, 0xd5, 0x37, 0x5f, 0xfb, 0xc9, 0xff, 0x46, 0xd2, 0x19, 0xc7, 0x22, 0x3e, 0x95, 0x45, 0x9d, 0x82, 0xe1, 0xe7, 0x22, 0x9f, 0x63, 0x31, 0x69, 0xd2, 0x6b, 0x57, 0x47, 0x4f, 0xa3, 0x37, 0xc9, 0x98, 0x1c, 0x0b, 0xfb, 0x91, 0x31, 0x4d, 0x55, 0xb9, 0xe9, 0x1c, 0x5a, 0x5e, 0xe4, 0x93, 0x92, 0xcf, 0xc5, 0x23, 0x12, 0xd5, 0x56, 0x2c, 0x4a, 0x6e, 0xff, 0xdc, 0x10, 0xd0, 0x68};
static const u8 entropy_source_nopr[64] = {0x5a, 0x19, 0x4d, 0x5e, 0x2b, 0x31, 0x58, 0x14, 0x54, 0xde, 0xf6, 0x75, 0xfb, 0x79, 0x58, 0xfe, 0xc7, 0xdb, 0x87, 0x3e, 0x56, 0x89, 0xfc, 0x9d, 0x03, 0x21, 0x7c, 0x68, 0xd8, 0x03, 0x38, 0x20, 0xf9, 0xe6, 0x5e, 0x04, 0xd8, 0x56, 0xf3, 0xa9, 0xc4, 0x4a, 0x4c, 0xbd, 0xc1, 0xd0, 0x08, 0x46, 0xf5, 0x98, 0x3d, 0x77, 0x1c, 0x1b, 0x13, 0x7e, 0x4e, 0x0f, 0x9d, 0x8e, 0xf4, 0x09, 0xf9, 0x2e};
static const u8 nonce_pers_pr[16] = {0xd2, 0x54, 0xfc, 0xff, 0x02, 0x1e, 0x69, 0xd2, 0x29, 0xc9, 0xcf, 0xad, 0x85, 0xfa, 0x48, 0x6c};
static const u8 nonce_pers_nopr[16] = {0x1b, 0x54, 0xb8, 0xff, 0x06, 0x42, 0xbf, 0xf5, 0x21, 0xf1, 0x5c, 0x1c, 0x0b, 0x66, 0x5f, 0x3f};
static const u8 result_pr[16] = {0x34, 0x01, 0x16, 0x56, 0xb4, 0x29, 0x00, 0x8f, 0x35, 0x63, 0xec, 0xb5, 0xf2, 0x59, 0x07, 0x23};
static const u8 result_nopr[16] = {0xa0, 0x54, 0x30, 0x3d, 0x8a, 0x7e, 0xa9, 0x88, 0x9d, 0x90, 0x3e, 0x07, 0x7c, 0x6f, 0x21, 0x8f};
static usize test_offset;
fn ctr_drbg_self_test_entropy(void * data, u8 * buf, usize len) -> i32
{
	const u8 * p = data;
	memcpy(buf, p + test_offset, len);
	test_offset += len;
	return 0;
}

pub fn mbedtls_ctr_drbg_self_test(i32 verbose) -> i32
{
	mbedtls_ctr_drbg_context ctx;
	u8 buf[16];
	mbedtls_ctr_drbg_init(&ctx);
	if verbose != 0
	{
		printf("  CTR_DRBG (PR = TRUE) : ");
	}
	test_offset = 0;
	if (mbedtls_ctr_drbg_seed_entropy_len(&ctx, ctr_drbg_self_test_entropy, (void *) entropy_source_pr, nonce_pers_pr, 16, 32)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	mbedtls_ctr_drbg_set_prediction_resistance(&ctx, 1);
	if (mbedtls_ctr_drbg_random(&ctx, buf, 16)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_ctr_drbg_random(&ctx, buf, 16)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (memcmp(buf, result_pr, 16)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	mbedtls_ctr_drbg_free(&ctx);
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  CTR_DRBG (PR = FALSE): ");
	}
	mbedtls_ctr_drbg_init(&ctx);
	test_offset = 0;
	if (mbedtls_ctr_drbg_seed_entropy_len(&ctx, ctr_drbg_self_test_entropy, (void *) entropy_source_nopr, nonce_pers_nopr, 16, 32)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_ctr_drbg_random(&ctx, buf, 16)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_ctr_drbg_reseed(&ctx, NULL, 0)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_ctr_drbg_random(&ctx, buf, 16)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (memcmp(buf, result_nopr, 16)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	mbedtls_ctr_drbg_free(&ctx);
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("\n");
	}
	return 0;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = (u8 *) v;
	while (n--)
	{
		*p++ = 0;
	}
}

static const u32 SB1[64] = {0x01010400, 0x00000000, 0x00010000, 0x01010404, 0x01010004, 0x00010404, 0x00000004, 0x00010000, 0x00000400, 0x01010400, 0x01010404, 0x00000400, 0x01000404, 0x01010004, 0x01000000, 0x00000004, 0x00000404, 0x01000400, 0x01000400, 0x00010400, 0x00010400, 0x01010000, 0x01010000, 0x01000404, 0x00010004, 0x01000004, 0x01000004, 0x00010004, 0x00000000, 0x00000404, 0x00010404, 0x01000000, 0x00010000, 0x01010404, 0x00000004, 0x01010000, 0x01010400, 0x01000000, 0x01000000, 0x00000400, 0x01010004, 0x00010000, 0x00010400, 0x01000004, 0x00000400, 0x00000004, 0x01000404, 0x00010404, 0x01010404, 0x00010004, 0x01010000, 0x01000404, 0x01000004, 0x00000404, 0x00010404, 0x01010400, 0x00000404, 0x01000400, 0x01000400, 0x00000000, 0x00010004, 0x00010400, 0x00000000, 0x01010004};
static const u32 SB2[64] = {0x80108020, 0x80008000, 0x00008000, 0x00108020, 0x00100000, 0x00000020, 0x80100020, 0x80008020, 0x80000020, 0x80108020, 0x80108000, 0x80000000, 0x80008000, 0x00100000, 0x00000020, 0x80100020, 0x00108000, 0x00100020, 0x80008020, 0x00000000, 0x80000000, 0x00008000, 0x00108020, 0x80100000, 0x00100020, 0x80000020, 0x00000000, 0x00108000, 0x00008020, 0x80108000, 0x80100000, 0x00008020, 0x00000000, 0x00108020, 0x80100020, 0x00100000, 0x80008020, 0x80100000, 0x80108000, 0x00008000, 0x80100000, 0x80008000, 0x00000020, 0x80108020, 0x00108020, 0x00000020, 0x00008000, 0x80000000, 0x00008020, 0x80108000, 0x00100000, 0x80000020, 0x00100020, 0x80008020, 0x80000020, 0x00100020, 0x00108000, 0x00000000, 0x80008000, 0x00008020, 0x80000000, 0x80100020, 0x80108020, 0x00108000};
static const u32 SB3[64] = {0x00000208, 0x08020200, 0x00000000, 0x08020008, 0x08000200, 0x00000000, 0x00020208, 0x08000200, 0x00020008, 0x08000008, 0x08000008, 0x00020000, 0x08020208, 0x00020008, 0x08020000, 0x00000208, 0x08000000, 0x00000008, 0x08020200, 0x00000200, 0x00020200, 0x08020000, 0x08020008, 0x00020208, 0x08000208, 0x00020200, 0x00020000, 0x08000208, 0x00000008, 0x08020208, 0x00000200, 0x08000000, 0x08020200, 0x08000000, 0x00020008, 0x00000208, 0x00020000, 0x08020200, 0x08000200, 0x00000000, 0x00000200, 0x00020008, 0x08020208, 0x08000200, 0x08000008, 0x00000200, 0x00000000, 0x08020008, 0x08000208, 0x00020000, 0x08000000, 0x08020208, 0x00000008, 0x00020208, 0x00020200, 0x08000008, 0x08020000, 0x08000208, 0x00000208, 0x08020000, 0x00020208, 0x00000008, 0x08020008, 0x00020200};
static const u32 SB4[64] = {0x00802001, 0x00002081, 0x00002081, 0x00000080, 0x00802080, 0x00800081, 0x00800001, 0x00002001, 0x00000000, 0x00802000, 0x00802000, 0x00802081, 0x00000081, 0x00000000, 0x00800080, 0x00800001, 0x00000001, 0x00002000, 0x00800000, 0x00802001, 0x00000080, 0x00800000, 0x00002001, 0x00002080, 0x00800081, 0x00000001, 0x00002080, 0x00800080, 0x00002000, 0x00802080, 0x00802081, 0x00000081, 0x00800080, 0x00800001, 0x00802000, 0x00802081, 0x00000081, 0x00000000, 0x00000000, 0x00802000, 0x00002080, 0x00800080, 0x00800081, 0x00000001, 0x00802001, 0x00002081, 0x00002081, 0x00000080, 0x00802081, 0x00000081, 0x00000001, 0x00002000, 0x00800001, 0x00002001, 0x00802080, 0x00800081, 0x00002001, 0x00002080, 0x00800000, 0x00802001, 0x00000080, 0x00800000, 0x00002000, 0x00802080};
static const u32 SB5[64] = {0x00000100, 0x02080100, 0x02080000, 0x42000100, 0x00080000, 0x00000100, 0x40000000, 0x02080000, 0x40080100, 0x00080000, 0x02000100, 0x40080100, 0x42000100, 0x42080000, 0x00080100, 0x40000000, 0x02000000, 0x40080000, 0x40080000, 0x00000000, 0x40000100, 0x42080100, 0x42080100, 0x02000100, 0x42080000, 0x40000100, 0x00000000, 0x42000000, 0x02080100, 0x02000000, 0x42000000, 0x00080100, 0x00080000, 0x42000100, 0x00000100, 0x02000000, 0x40000000, 0x02080000, 0x42000100, 0x40080100, 0x02000100, 0x40000000, 0x42080000, 0x02080100, 0x40080100, 0x00000100, 0x02000000, 0x42080000, 0x42080100, 0x00080100, 0x42000000, 0x42080100, 0x02080000, 0x00000000, 0x40080000, 0x42000000, 0x00080100, 0x02000100, 0x40000100, 0x00080000, 0x00000000, 0x40080000, 0x02080100, 0x40000100};
static const u32 SB6[64] = {0x20000010, 0x20400000, 0x00004000, 0x20404010, 0x20400000, 0x00000010, 0x20404010, 0x00400000, 0x20004000, 0x00404010, 0x00400000, 0x20000010, 0x00400010, 0x20004000, 0x20000000, 0x00004010, 0x00000000, 0x00400010, 0x20004010, 0x00004000, 0x00404000, 0x20004010, 0x00000010, 0x20400010, 0x20400010, 0x00000000, 0x00404010, 0x20404000, 0x00004010, 0x00404000, 0x20404000, 0x20000000, 0x20004000, 0x00000010, 0x20400010, 0x00404000, 0x20404010, 0x00400000, 0x00004010, 0x20000010, 0x00400000, 0x20004000, 0x20000000, 0x00004010, 0x20000010, 0x20404010, 0x00404000, 0x20400000, 0x00404010, 0x20404000, 0x00000000, 0x20400010, 0x00000010, 0x00004000, 0x20400000, 0x00404010, 0x00004000, 0x00400010, 0x20004010, 0x00000000, 0x20404000, 0x20000000, 0x00400010, 0x20004010};
static const u32 SB7[64] = {0x00200000, 0x04200002, 0x04000802, 0x00000000, 0x00000800, 0x04000802, 0x00200802, 0x04200800, 0x04200802, 0x00200000, 0x00000000, 0x04000002, 0x00000002, 0x04000000, 0x04200002, 0x00000802, 0x04000800, 0x00200802, 0x00200002, 0x04000800, 0x04000002, 0x04200000, 0x04200800, 0x00200002, 0x04200000, 0x00000800, 0x00000802, 0x04200802, 0x00200800, 0x00000002, 0x04000000, 0x00200800, 0x04000000, 0x00200800, 0x00200000, 0x04000802, 0x04000802, 0x04200002, 0x04200002, 0x00000002, 0x00200002, 0x04000000, 0x04000800, 0x00200000, 0x04200800, 0x00000802, 0x00200802, 0x04200800, 0x00000802, 0x04000002, 0x04200802, 0x04200000, 0x00200800, 0x00000000, 0x00000002, 0x04200802, 0x00000000, 0x00200802, 0x04200000, 0x00000800, 0x04000002, 0x04000800, 0x00000800, 0x00200002};
static const u32 SB8[64] = {0x10001040, 0x00001000, 0x00040000, 0x10041040, 0x10000000, 0x10001040, 0x00000040, 0x10000000, 0x00040040, 0x10040000, 0x10041040, 0x00041000, 0x10041000, 0x00041040, 0x00001000, 0x00000040, 0x10040000, 0x10000040, 0x10001000, 0x00001040, 0x00041000, 0x00040040, 0x10040040, 0x10041000, 0x00001040, 0x00000000, 0x00000000, 0x10040040, 0x10000040, 0x10001000, 0x00041040, 0x00040000, 0x00041040, 0x00040000, 0x10041000, 0x00001000, 0x00000040, 0x10040040, 0x00001000, 0x00041040, 0x10001000, 0x00000040, 0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x00040000, 0x10001040, 0x00000000, 0x10041040, 0x00040040, 0x10000040, 0x10040000, 0x10001000, 0x10001040, 0x00000000, 0x10041040, 0x00041000, 0x00041000, 0x00001040, 0x00001040, 0x00040040, 0x10000000, 0x10041000};
static const u32 LHs[16] = {0x00000000, 0x00000001, 0x00000100, 0x00000101, 0x00010000, 0x00010001, 0x00010100, 0x00010101, 0x01000000, 0x01000001, 0x01000100, 0x01000101, 0x01010000, 0x01010001, 0x01010100, 0x01010101};
static const u32 RHs[16] =
{
	0x00000000, 0x01000000, 0x00010000, 0x01010000, 0x00000100, 0x01000100, 0x00010100, 0x01010100, 0x00000001, 0x01000001, 0x00010001, 0x01010001, 0x00000101, 0x01000101, 0x00010101, 0x01010101,
};
pub fn mbedtls_des_init(mbedtls_des_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_des_context));
}

pub fn mbedtls_des_free(mbedtls_des_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_des_context));
}

pub fn mbedtls_des3_init(mbedtls_des3_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_des3_context));
}

pub fn mbedtls_des3_free(mbedtls_des3_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_des3_context));
}

static const u8 odd_parity_table[128] = {1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59, 61, 62, 64, 67, 69, 70, 73, 74, 76, 79, 81, 82, 84, 87, 88, 91, 93, 94, 97, 98, 100, 103, 104, 107, 109, 110, 112, 115, 117, 118, 121, 122, 124, 127, 128, 131, 133, 134, 137, 138, 140, 143, 145, 146, 148, 151, 152, 155, 157, 158, 161, 162, 164, 167, 168, 171, 173, 174, 176, 179, 181, 182, 185, 186, 188, 191, 193, 194, 196, 199, 200, 203, 205, 206, 208, 211, 213, 214, 217, 218, 220, 223, 224, 227, 229, 230, 233, 234, 236, 239, 241, 242, 244, 247, 248, 251, 253, 254};
pub fn mbedtls_des_key_set_parity(u8 key[8])
{
	i32 i;
	for (i = 0; i < 8; i++)
	{
		key[i] = odd_parity_table[key[i] / 2];
	}
}

pub fn mbedtls_des_key_check_key_parity(const u8 key[8]) -> i32
{
	i32 i;
	for (i = 0; i < 8; i++)
		if key[i] != odd_parity_table[key[i] / 2]
		{
			return 1;
		}
	return 0;
}

static const u8 weak_key_table[16][8] = {{0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}, {0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE}, {0x1F, 0x1F, 0x1F, 0x1F, 0x0E, 0x0E, 0x0E, 0x0E}, {0xE0, 0xE0, 0xE0, 0xE0, 0xF1, 0xF1, 0xF1, 0xF1}, {0x01, 0x1F, 0x01, 0x1F, 0x01, 0x0E, 0x01, 0x0E}, {0x1F, 0x01, 0x1F, 0x01, 0x0E, 0x01, 0x0E, 0x01}, {0x01, 0xE0, 0x01, 0xE0, 0x01, 0xF1, 0x01, 0xF1}, {0xE0, 0x01, 0xE0, 0x01, 0xF1, 0x01, 0xF1, 0x01}, {0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE}, {0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01}, {0x1F, 0xE0, 0x1F, 0xE0, 0x0E, 0xF1, 0x0E, 0xF1}, {0xE0, 0x1F, 0xE0, 0x1F, 0xF1, 0x0E, 0xF1, 0x0E}, {0x1F, 0xFE, 0x1F, 0xFE, 0x0E, 0xFE, 0x0E, 0xFE}, {0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x0E, 0xFE, 0x0E}, {0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1, 0xFE}, {0xFE, 0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1}};
pub fn mbedtls_des_key_check_weak(const u8 key[8]) -> i32
{
	i32 i;
	for (i = 0; i < 16; i++)
		if memcmp(weak_key_table[i], key, 8) == 0
		{
			return 1;
		}
	return 0;
}

pub fn mbedtls_des_setkey(u32 SK[32], const u8 key[8])
{
	i32 i;
	u32 X, Y, T;
	{
		(X) = ((u32)(key)[(0)] << 24) | ((u32)(key)[(0) + 1] << 16) | ((u32)(key)[(0) + 2] << 8) | ((u32)(key)[(0) + 3]);
	};
	{
		(Y) = ((u32)(key)[(4)] << 24) | ((u32)(key)[(4) + 1] << 16) | ((u32)(key)[(4) + 2] << 8) | ((u32)(key)[(4) + 3]);
	};
	T = ((Y >> 4) ^ X) & 0x0F0F0F0F;
	X ^= T;
	Y ^= (T << 4);
	T = ((Y) ^ X) & 0x10101010;
	X ^= T;
	Y ^= (T);
	X = (LHs[(X) &0xF] << 3) | (LHs[(X >> 8) & 0xF] << 2) | (LHs[(X >> 16) & 0xF] << 1) | (LHs[(X >> 24) & 0xF]) | (LHs[(X >> 5) & 0xF] << 7) | (LHs[(X >> 13) & 0xF] << 6) | (LHs[(X >> 21) & 0xF] << 5) | (LHs[(X >> 29) & 0xF] << 4);
	Y = (RHs[(Y >> 1) & 0xF] << 3) | (RHs[(Y >> 9) & 0xF] << 2) | (RHs[(Y >> 17) & 0xF] << 1) | (RHs[(Y >> 25) & 0xF]) | (RHs[(Y >> 4) & 0xF] << 7) | (RHs[(Y >> 12) & 0xF] << 6) | (RHs[(Y >> 20) & 0xF] << 5) | (RHs[(Y >> 28) & 0xF] << 4);
	X &= 0x0FFFFFFF;
	Y &= 0x0FFFFFFF;
	for (i = 0; i < 16; i++)
	{
		if i < 2 || i == 8 || i == 15
		{
			X = ((X << 1) | (X >> 27)) & 0x0FFFFFFF;
			Y = ((Y << 1) | (Y >> 27)) & 0x0FFFFFFF;
		}
		else
		{
			X = ((X << 2) | (X >> 26)) & 0x0FFFFFFF;
			Y = ((Y << 2) | (Y >> 26)) & 0x0FFFFFFF;
		}
		*SK++ = ((X << 4) & 0x24000000) | ((X << 28) & 0x10000000) | ((X << 14) & 0x08000000) | ((X << 18) & 0x02080000) | ((X << 6) & 0x01000000) | ((X << 9) & 0x00200000) | ((X >> 1) & 0x00100000) | ((X << 10) & 0x00040000) | ((X << 2) & 0x00020000) | ((X >> 10) & 0x00010000) | ((Y >> 13) & 0x00002000) | ((Y >> 4) & 0x00001000) | ((Y << 6) & 0x00000800) | ((Y >> 1) & 0x00000400) | ((Y >> 14) & 0x00000200) | ((Y) &0x00000100) | ((Y >> 5) & 0x00000020) | ((Y >> 10) & 0x00000010) | ((Y >> 3) & 0x00000008) | ((Y >> 18) & 0x00000004) | ((Y >> 26) & 0x00000002) | ((Y >> 24) & 0x00000001);
		*SK++ = ((X << 15) & 0x20000000) | ((X << 17) & 0x10000000) | ((X << 10) & 0x08000000) | ((X << 22) & 0x04000000) | ((X >> 2) & 0x02000000) | ((X << 1) & 0x01000000) | ((X << 16) & 0x00200000) | ((X << 11) & 0x00100000) | ((X << 3) & 0x00080000) | ((X >> 6) & 0x00040000) | ((X << 15) & 0x00020000) | ((X >> 4) & 0x00010000) | ((Y >> 2) & 0x00002000) | ((Y << 8) & 0x00001000) | ((Y >> 14) & 0x00000808) | ((Y >> 9) & 0x00000400) | ((Y) &0x00000200) | ((Y << 7) & 0x00000100) | ((Y >> 7) & 0x00000020) | ((Y >> 3) & 0x00000011) | ((Y << 2) & 0x00000004) | ((Y >> 21) & 0x00000002);
	}
}

pub fn mbedtls_des_setkey_enc(mbedtls_des_context * ctx, const u8 key[8]) -> i32
{
	mbedtls_des_setkey(ctx.sk, key);
	return 0;
}

pub fn mbedtls_des_setkey_dec(mbedtls_des_context * ctx, const u8 key[8]) -> i32
{
	i32 i;
	mbedtls_des_setkey(ctx.sk, key);
	for (i = 0; i < 16; i += 2)
	{
		{
			u32 t = ctx.sk[i];
			ctx.sk[i] = ctx.sk[30 - i];
			ctx.sk[30 - i] = t;
			t = 0;
		};
		{
			u32 t = ctx.sk[i + 1];
			ctx.sk[i + 1] = ctx.sk[31 - i];
			ctx.sk[31 - i] = t;
			t = 0;
		};
	}
	return 0;
}

fn des3_set2key(u32 esk[96], u32 dsk[96], const u8 key[8 * 2])
{
	i32 i;
	mbedtls_des_setkey(esk, key);
	mbedtls_des_setkey(dsk + 32, key + 8);
	for (i = 0; i < 32; i += 2)
	{
		dsk[i] = esk[30 - i];
		dsk[i + 1] = esk[31 - i];
		esk[i + 32] = dsk[62 - i];
		esk[i + 33] = dsk[63 - i];
		esk[i + 64] = esk[i];
		esk[i + 65] = esk[i + 1];
		dsk[i + 64] = dsk[i];
		dsk[i + 65] = dsk[i + 1];
	}
}

pub fn mbedtls_des3_set2key_enc(mbedtls_des3_context * ctx, const u8 key[8 * 2]) -> i32
{
	u32 sk[96];
	des3_set2key(ctx.sk, sk, key);
	zeroize(sk, sizeof(sk));
	return 0;
}

pub fn mbedtls_des3_set2key_dec(mbedtls_des3_context * ctx, const u8 key[8 * 2]) -> i32
{
	u32 sk[96];
	des3_set2key(sk, ctx.sk, key);
	zeroize(sk, sizeof(sk));
	return 0;
}

fn des3_set3key(u32 esk[96], u32 dsk[96], const u8 key[24])
{
	i32 i;
	mbedtls_des_setkey(esk, key);
	mbedtls_des_setkey(dsk + 32, key + 8);
	mbedtls_des_setkey(esk + 64, key + 16);
	for (i = 0; i < 32; i += 2)
	{
		dsk[i] = esk[94 - i];
		dsk[i + 1] = esk[95 - i];
		esk[i + 32] = dsk[62 - i];
		esk[i + 33] = dsk[63 - i];
		dsk[i + 64] = esk[30 - i];
		dsk[i + 65] = esk[31 - i];
	}
}

pub fn mbedtls_des3_set3key_enc(mbedtls_des3_context * ctx, const u8 key[8 * 3]) -> i32
{
	u32 sk[96];
	des3_set3key(ctx.sk, sk, key);
	zeroize(sk, sizeof(sk));
	return 0;
}

pub fn mbedtls_des3_set3key_dec(mbedtls_des3_context * ctx, const u8 key[8 * 3]) -> i32
{
	u32 sk[96];
	des3_set3key(sk, ctx.sk, key);
	zeroize(sk, sizeof(sk));
	return 0;
}

pub fn mbedtls_des_crypt_ecb(mbedtls_des_context * ctx, const u8 input[8], u8 output[8]) -> i32
{
	i32 i;
	u32 X, Y, T, *SK;
	SK = ctx.sk;
	{
		(X) = ((u32)(input)[(0)] << 24) | ((u32)(input)[(0) + 1] << 16) | ((u32)(input)[(0) + 2] << 8) | ((u32)(input)[(0) + 3]);
	};
	{
		(Y) = ((u32)(input)[(4)] << 24) | ((u32)(input)[(4) + 1] << 16) | ((u32)(input)[(4) + 2] << 8) | ((u32)(input)[(4) + 3]);
	};
	{
		T = ((X >> 4) ^ Y) & 0x0F0F0F0F;
		Y ^= T;
		X ^= (T << 4);
		T = ((X >> 16) ^ Y) & 0x0000FFFF;
		Y ^= T;
		X ^= (T << 16);
		T = ((Y >> 2) ^ X) & 0x33333333;
		X ^= T;
		Y ^= (T << 2);
		T = ((Y >> 8) ^ X) & 0x00FF00FF;
		X ^= T;
		Y ^= (T << 8);
		Y = ((Y << 1) | (Y >> 31)) & 0xFFFFFFFF;
		T = (X ^ Y) & 0xAAAAAAAA;
		Y ^= T;
		X ^= T;
		X = ((X << 1) | (X >> 31)) & 0xFFFFFFFF;
	};
	for (i = 0; i < 8; i++)
	{
		{
			T = *SK++ ^ Y;
			X ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((Y << 28) | (Y >> 4));
			X ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
		{
			T = *SK++ ^ X;
			Y ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((X << 28) | (X >> 4));
			Y ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
	}
	{
		Y = ((Y << 31) | (Y >> 1)) & 0xFFFFFFFF;
		T = (Y ^ X) & 0xAAAAAAAA;
		Y ^= T;
		X ^= T;
		X = ((X << 31) | (X >> 1)) & 0xFFFFFFFF;
		T = ((X >> 8) ^ Y) & 0x00FF00FF;
		Y ^= T;
		X ^= (T << 8);
		T = ((X >> 2) ^ Y) & 0x33333333;
		Y ^= T;
		X ^= (T << 2);
		T = ((Y >> 16) ^ X) & 0x0000FFFF;
		X ^= T;
		Y ^= (T << 16);
		T = ((Y >> 4) ^ X) & 0x0F0F0F0F;
		X ^= T;
		Y ^= (T << 4);
	};
	{
		(output)[(0)] = (i8) ((Y) >> 24);
		(output)[(0) + 1] = (i8) ((Y) >> 16);
		(output)[(0) + 2] = (i8) ((Y) >> 8);
		(output)[(0) + 3] = (i8) ((Y));
	};
	{
		(output)[(4)] = (i8) ((X) >> 24);
		(output)[(4) + 1] = (i8) ((X) >> 16);
		(output)[(4) + 2] = (i8) ((X) >> 8);
		(output)[(4) + 3] = (i8) ((X));
	};
	return 0;
}

pub fn mbedtls_des_crypt_cbc(mbedtls_des_context * ctx, i32 mode, usize length, u8 iv[8], const u8 * input, u8 * output) -> i32
{
	i32 i;
	u8 temp[8];
	if length % 8
	{
		return -0x0032;
	}
	if mode == 1
	{
		while (length > 0)
		{
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (input[i] ^ iv[i]);
			}
			mbedtls_des_crypt_ecb(ctx, output, output);
			memcpy(iv, output, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	else
	{
		while (length > 0)
		{
			memcpy(temp, input, 8);
			mbedtls_des_crypt_ecb(ctx, input, output);
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (output[i] ^ iv[i]);
			}
			memcpy(iv, temp, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	return 0;
}

pub fn mbedtls_des3_crypt_ecb(mbedtls_des3_context * ctx, const u8 input[8], u8 output[8]) -> i32
{
	i32 i;
	u32 X, Y, T, *SK;
	SK = ctx.sk;
	{
		(X) = ((u32)(input)[(0)] << 24) | ((u32)(input)[(0) + 1] << 16) | ((u32)(input)[(0) + 2] << 8) | ((u32)(input)[(0) + 3]);
	};
	{
		(Y) = ((u32)(input)[(4)] << 24) | ((u32)(input)[(4) + 1] << 16) | ((u32)(input)[(4) + 2] << 8) | ((u32)(input)[(4) + 3]);
	};
	{
		T = ((X >> 4) ^ Y) & 0x0F0F0F0F;
		Y ^= T;
		X ^= (T << 4);
		T = ((X >> 16) ^ Y) & 0x0000FFFF;
		Y ^= T;
		X ^= (T << 16);
		T = ((Y >> 2) ^ X) & 0x33333333;
		X ^= T;
		Y ^= (T << 2);
		T = ((Y >> 8) ^ X) & 0x00FF00FF;
		X ^= T;
		Y ^= (T << 8);
		Y = ((Y << 1) | (Y >> 31)) & 0xFFFFFFFF;
		T = (X ^ Y) & 0xAAAAAAAA;
		Y ^= T;
		X ^= T;
		X = ((X << 1) | (X >> 31)) & 0xFFFFFFFF;
	};
	for (i = 0; i < 8; i++)
	{
		{
			T = *SK++ ^ Y;
			X ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((Y << 28) | (Y >> 4));
			X ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
		{
			T = *SK++ ^ X;
			Y ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((X << 28) | (X >> 4));
			Y ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
	}
	for (i = 0; i < 8; i++)
	{
		{
			T = *SK++ ^ X;
			Y ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((X << 28) | (X >> 4));
			Y ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
		{
			T = *SK++ ^ Y;
			X ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((Y << 28) | (Y >> 4));
			X ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
	}
	for (i = 0; i < 8; i++)
	{
		{
			T = *SK++ ^ Y;
			X ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((Y << 28) | (Y >> 4));
			X ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
		{
			T = *SK++ ^ X;
			Y ^= SB8[(T) &0x3F] ^ SB6[(T >> 8) & 0x3F] ^ SB4[(T >> 16) & 0x3F] ^ SB2[(T >> 24) & 0x3F];
			T = *SK++ ^ ((X << 28) | (X >> 4));
			Y ^= SB7[(T) &0x3F] ^ SB5[(T >> 8) & 0x3F] ^ SB3[(T >> 16) & 0x3F] ^ SB1[(T >> 24) & 0x3F];
		};
	}
	{
		Y = ((Y << 31) | (Y >> 1)) & 0xFFFFFFFF;
		T = (Y ^ X) & 0xAAAAAAAA;
		Y ^= T;
		X ^= T;
		X = ((X << 31) | (X >> 1)) & 0xFFFFFFFF;
		T = ((X >> 8) ^ Y) & 0x00FF00FF;
		Y ^= T;
		X ^= (T << 8);
		T = ((X >> 2) ^ Y) & 0x33333333;
		Y ^= T;
		X ^= (T << 2);
		T = ((Y >> 16) ^ X) & 0x0000FFFF;
		X ^= T;
		Y ^= (T << 16);
		T = ((Y >> 4) ^ X) & 0x0F0F0F0F;
		X ^= T;
		Y ^= (T << 4);
	};
	{
		(output)[(0)] = (i8) ((Y) >> 24);
		(output)[(0) + 1] = (i8) ((Y) >> 16);
		(output)[(0) + 2] = (i8) ((Y) >> 8);
		(output)[(0) + 3] = (i8) ((Y));
	};
	{
		(output)[(4)] = (i8) ((X) >> 24);
		(output)[(4) + 1] = (i8) ((X) >> 16);
		(output)[(4) + 2] = (i8) ((X) >> 8);
		(output)[(4) + 3] = (i8) ((X));
	};
	return 0;
}

pub fn mbedtls_des3_crypt_cbc(mbedtls_des3_context * ctx, i32 mode, usize length, u8 iv[8], const u8 * input, u8 * output) -> i32
{
	i32 i;
	u8 temp[8];
	if length % 8
	{
		return -0x0032;
	}
	if mode == 1
	{
		while (length > 0)
		{
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (input[i] ^ iv[i]);
			}
			mbedtls_des3_crypt_ecb(ctx, output, output);
			memcpy(iv, output, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	else
	{
		while (length > 0)
		{
			memcpy(temp, input, 8);
			mbedtls_des3_crypt_ecb(ctx, input, output);
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (output[i] ^ iv[i]);
			}
			memcpy(iv, temp, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	return 0;
}

static const u8 des3_test_keys[24] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23};
static const u8 des3_test_buf[8] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
static const u8 des3_test_ecb_dec[3][8] = {{0xCD, 0xD6, 0x4F, 0x2F, 0x94, 0x27, 0xC1, 0x5D}, {0x69, 0x96, 0xC8, 0xFA, 0x47, 0xA2, 0xAB, 0xEB}, {0x83, 0x25, 0x39, 0x76, 0x44, 0x09, 0x1A, 0x0A}};
static const u8 des3_test_ecb_enc[3][8] = {{0x6A, 0x2A, 0x19, 0xF4, 0x1E, 0xCA, 0x85, 0x4B}, {0x03, 0xE6, 0x9F, 0x5B, 0xFA, 0x58, 0xEB, 0x42}, {0xDD, 0x17, 0xE8, 0xB8, 0xB4, 0x37, 0xD2, 0x32}};
static const u8 des3_test_iv[8] =
{
	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
};
static const u8 des3_test_cbc_dec[3][8] = {{0x12, 0x9F, 0x40, 0xB9, 0xD2, 0x00, 0x56, 0xB3}, {0x47, 0x0E, 0xFC, 0x9A, 0x6B, 0x8E, 0xE3, 0x93}, {0xC5, 0xCE, 0xCF, 0x63, 0xEC, 0xEC, 0x51, 0x4C}};
static const u8 des3_test_cbc_enc[3][8] = {{0x54, 0xF1, 0x5A, 0xF6, 0xEB, 0xE3, 0xA4, 0xB4}, {0x35, 0x76, 0x11, 0x56, 0x5F, 0xA1, 0x8E, 0x4D}, {0xCB, 0x19, 0x1F, 0x85, 0xD1, 0xED, 0x84, 0x39}};
pub fn mbedtls_des_self_test(i32 verbose) -> i32
{
	i32 i, j, u, v, ret = 0;
	mbedtls_des_context ctx;
	mbedtls_des3_context ctx3;
	u8 buf[8];
	u8 prv[8];
	u8 iv[8];
	mbedtls_des_init(&ctx);
	mbedtls_des3_init(&ctx3);
	for (i = 0; i < 6; i++)
	{
		u = i >> 1;
		v = i & 1;
		if verbose != 0
		{
			printf("  DES%c-ECB-%3d (%s): ", (u == 0) ? ' ' : '3', 56 + u * 56, (v == 0) ? "dec" : "enc");
		}
		memcpy(buf, des3_test_buf, 8);
		switch (i)
		{
			case 0:
			mbedtls_des_setkey_dec(&ctx, des3_test_keys);
			break;

			case 1:
			mbedtls_des_setkey_enc(&ctx, des3_test_keys);
			break;

			case 2:
			mbedtls_des3_set2key_dec(&ctx3, des3_test_keys);
			break;

			case 3:
			mbedtls_des3_set2key_enc(&ctx3, des3_test_keys);
			break;

			case 4:
			mbedtls_des3_set3key_dec(&ctx3, des3_test_keys);
			break;

			case 5:
			mbedtls_des3_set3key_enc(&ctx3, des3_test_keys);
			break;

		default:
			return 1;
		}
		for (j = 0; j < 10000; j++)
		{
			if u == 0
			{
				mbedtls_des_crypt_ecb(&ctx, buf, buf);
			}
			else
			{
				mbedtls_des3_crypt_ecb(&ctx3, buf, buf);
			}
		}
		if (v == 0 && memcmp(buf, des3_test_ecb_dec[u], 8) != 0) || (v != 0 && memcmp(buf, des3_test_ecb_enc[u], 8) != 0)
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			ret = 1;
			goto exit;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
	for (i = 0; i < 6; i++)
	{
		u = i >> 1;
		v = i & 1;
		if verbose != 0
		{
			printf("  DES%c-CBC-%3d (%s): ", (u == 0) ? ' ' : '3', 56 + u * 56, (v == 0) ? "dec" : "enc");
		}
		memcpy(iv, des3_test_iv, 8);
		memcpy(prv, des3_test_iv, 8);
		memcpy(buf, des3_test_buf, 8);
		switch (i)
		{
			case 0:
			mbedtls_des_setkey_dec(&ctx, des3_test_keys);
			break;

			case 1:
			mbedtls_des_setkey_enc(&ctx, des3_test_keys);
			break;

			case 2:
			mbedtls_des3_set2key_dec(&ctx3, des3_test_keys);
			break;

			case 3:
			mbedtls_des3_set2key_enc(&ctx3, des3_test_keys);
			break;

			case 4:
			mbedtls_des3_set3key_dec(&ctx3, des3_test_keys);
			break;

			case 5:
			mbedtls_des3_set3key_enc(&ctx3, des3_test_keys);
			break;

		default:
			return 1;
		}
		if v == 0
		{
			for (j = 0; j < 10000; j++)
			{
				if u == 0
				{
					mbedtls_des_crypt_cbc(&ctx, v, 8, iv, buf, buf);
				}
				else
				{
					mbedtls_des3_crypt_cbc(&ctx3, v, 8, iv, buf, buf);
				}
			}
		}
		else
		{
			for (j = 0; j < 10000; j++)
			{
				u8 tmp[8];
				if u == 0
				{
					mbedtls_des_crypt_cbc(&ctx, v, 8, iv, buf, buf);
				}
				else
				{
					mbedtls_des3_crypt_cbc(&ctx3, v, 8, iv, buf, buf);
				}
				memcpy(tmp, prv, 8);
				memcpy(prv, buf, 8);
				memcpy(buf, tmp, 8);
			}
			memcpy(buf, prv, 8);
		}
		if (v == 0 && memcmp(buf, des3_test_cbc_dec[u], 8) != 0) || (v != 0 && memcmp(buf, des3_test_cbc_enc[u], 8) != 0)
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			ret = 1;
			goto exit;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
exit:
	mbedtls_des_free(&ctx);
	mbedtls_des3_free(&ctx3);
	return ret;
}

typedef struct
{
	usize len;
	mbedtls_mpi P;
	mbedtls_mpi G;
	mbedtls_mpi X;
	mbedtls_mpi GX;
	mbedtls_mpi GY;
	mbedtls_mpi K;
	mbedtls_mpi RP;
	mbedtls_mpi Vi;
	mbedtls_mpi Vf;
	mbedtls_mpi pX;
} mbedtls_dhm_context;

typedef struct
{
	u8 * buf;
	usize buflen;
	u8 * info;
} mbedtls_pem_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

fn dhm_read_bignum(mbedtls_mpi * X, u8 ** p, const u8 * end) -> i32
{
	i32 ret, n;
	if end - *p < 2
	{
		return -0x3080;
	}
	n = ((*p)[0] << 8) | (*p)[1];
	(*p) += 2;
	if (int) (end - *p) < n
	{
		return -0x3080;
	}
	if (ret = mbedtls_mpi_read_binary(X, *p, n)) != 0
	{
		return -0x3100 + ret;
	}
	(*p) += n;
	return 0;
}

fn dhm_check_range(const mbedtls_mpi * param, const mbedtls_mpi * P) -> i32
{
	mbedtls_mpi L, U;
	i32 ret = -0x3080;
	mbedtls_mpi_init(&L);
	mbedtls_mpi_init(&U);
	do
	{
		if (ret = mbedtls_mpi_lset(&L, 2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_int(&U, P, 2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_mpi(param, &L) >= 0 && mbedtls_mpi_cmp_mpi(param, &U) <= 0
	{
		ret = 0;
	}
cleanup:
	mbedtls_mpi_free(&L);
	mbedtls_mpi_free(&U);
	return ret;
}

pub fn mbedtls_dhm_init(mbedtls_dhm_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_dhm_context));
}

pub fn mbedtls_dhm_read_params(mbedtls_dhm_context * ctx, u8 ** p, const u8 * end) -> i32
{
	i32 ret;
	if (ret = dhm_read_bignum(&ctx.P, p, end)) != 0 || (ret = dhm_read_bignum(&ctx.G, p, end)) != 0 || (ret = dhm_read_bignum(&ctx.GY, p, end)) != 0
	{
		return ret;
	}
	if (ret = dhm_check_range(&ctx.GY, &ctx.P)) != 0
	{
		return ret;
	}
	ctx.len = mbedtls_mpi_size(&ctx.P);
	return 0;
}

pub fn mbedtls_dhm_make_params(mbedtls_dhm_context * ctx, i32 x_size, u8 * output, usize * olen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret, count = 0;
	usize n1, n2, n3;
	u8 * p;
	if mbedtls_mpi_cmp_int(&ctx.P, 0) == 0
	{
		return -0x3080;
	}
	do
	{
		mbedtls_mpi_fill_random(&ctx.X, x_size, f_rng, p_rng);
		while (mbedtls_mpi_cmp_mpi(&ctx.X, &ctx.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_shift_r(&ctx.X, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		if count++ > 10
		{
			return -0x3180;
		}
	}
	while (dhm_check_range(&ctx.X, &ctx.P) != 0);
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&ctx.GX, &ctx.G, &ctx.X, &ctx.P, &ctx.RP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if (ret = dhm_check_range(&ctx.GX, &ctx.P)) != 0
	{
		return ret;
	}
	n1 = mbedtls_mpi_size(&ctx.P);
	n2 = mbedtls_mpi_size(&ctx.G);
	n3 = mbedtls_mpi_size(&ctx.GX);
	p = output;
	do
	{
		if (ret = mbedtls_mpi_write_binary(&ctx.P, p + 2, n1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*p++ = (i8) (n1 >> 8);
	*p++ = (i8) (n1);
	p += n1;
	;
	do
	{
		if (ret = mbedtls_mpi_write_binary(&ctx.G, p + 2, n2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*p++ = (i8) (n2 >> 8);
	*p++ = (i8) (n2);
	p += n2;
	;
	do
	{
		if (ret = mbedtls_mpi_write_binary(&ctx.GX, p + 2, n3)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*p++ = (i8) (n3 >> 8);
	*p++ = (i8) (n3);
	p += n3;
	;
	*olen = p - output;
	ctx.len = n1;
cleanup:
	if ret != 0
	{
		return -0x3180 + ret;
	}
	return 0;
}

pub fn mbedtls_dhm_read_public(mbedtls_dhm_context * ctx, const u8 * input, usize ilen) -> i32
{
	i32 ret;
	if ctx == NULL || ilen < 1 || ilen > ctx.len
	{
		return -0x3080;
	}
	if (ret = mbedtls_mpi_read_binary(&ctx.GY, input, ilen)) != 0
	{
		return -0x3200 + ret;
	}
	return 0;
}

pub fn mbedtls_dhm_make_public(mbedtls_dhm_context * ctx, i32 x_size, u8 * output, usize olen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret, count = 0;
	if ctx == NULL || olen < 1 || olen > ctx.len
	{
		return -0x3080;
	}
	if mbedtls_mpi_cmp_int(&ctx.P, 0) == 0
	{
		return -0x3080;
	}
	do
	{
		mbedtls_mpi_fill_random(&ctx.X, x_size, f_rng, p_rng);
		while (mbedtls_mpi_cmp_mpi(&ctx.X, &ctx.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_shift_r(&ctx.X, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		if count++ > 10
		{
			return -0x3280;
		}
	}
	while (dhm_check_range(&ctx.X, &ctx.P) != 0);
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&ctx.GX, &ctx.G, &ctx.X, &ctx.P, &ctx.RP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if (ret = dhm_check_range(&ctx.GX, &ctx.P)) != 0
	{
		return ret;
	}
	do
	{
		if (ret = mbedtls_mpi_write_binary(&ctx.GX, output, olen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	if ret != 0
	{
		return -0x3280 + ret;
	}
	return 0;
}

fn dhm_update_blinding(mbedtls_dhm_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret, count;
	if mbedtls_mpi_cmp_mpi(&ctx.X, &ctx.pX) != 0
	{
		do
		{
			if (ret = mbedtls_mpi_copy(&ctx.pX, &ctx.X)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_lset(&ctx.Vi, 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_lset(&ctx.Vf, 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		return 0;
	}
	if mbedtls_mpi_cmp_int(&ctx.Vi, 1) != 0
	{
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&ctx.Vi, &ctx.Vi, &ctx.Vi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&ctx.Vi, &ctx.Vi, &ctx.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&ctx.Vf, &ctx.Vf, &ctx.Vf)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&ctx.Vf, &ctx.Vf, &ctx.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		return 0;
	}
	count = 0;
	do
	{
		mbedtls_mpi_fill_random(&ctx.Vi, mbedtls_mpi_size(&ctx.P), f_rng, p_rng);
		while (mbedtls_mpi_cmp_mpi(&ctx.Vi, &ctx.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_shift_r(&ctx.Vi, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		if count++ > 10
		{
			return -0x000E;
		}
	}
	while (mbedtls_mpi_cmp_int(&ctx.Vi, 1) <= 0);
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&ctx.Vf, &ctx.Vi, &ctx.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&ctx.Vf, &ctx.Vf, &ctx.X, &ctx.P, &ctx.RP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

pub fn mbedtls_dhm_calc_secret(mbedtls_dhm_context * ctx, u8 * output, usize output_size, usize * olen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_mpi GYb;
	if ctx == NULL || output_size < ctx.len
	{
		return -0x3080;
	}
	if (ret = dhm_check_range(&ctx.GY, &ctx.P)) != 0
	{
		return ret;
	}
	mbedtls_mpi_init(&GYb);
	if f_rng != NULL
	{
		do
		{
			if (ret = dhm_update_blinding(ctx, f_rng, p_rng)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&GYb, &ctx.GY, &ctx.Vi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&GYb, &GYb, &ctx.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	else
		do
		{
			if (ret = mbedtls_mpi_copy(&GYb, &ctx.GY)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&ctx.K, &GYb, &ctx.X, &ctx.P, &ctx.RP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if f_rng != NULL
	{
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&ctx.K, &ctx.K, &ctx.Vf)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&ctx.K, &ctx.K, &ctx.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	*olen = mbedtls_mpi_size(&ctx.K);
	do
	{
		if (ret = mbedtls_mpi_write_binary(&ctx.K, output, *olen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&GYb);
	if ret != 0
	{
		return -0x3300 + ret;
	}
	return 0;
}

pub fn mbedtls_dhm_free(mbedtls_dhm_context * ctx)
{
	mbedtls_mpi_free(&ctx.pX);
	mbedtls_mpi_free(&ctx.Vf);
	mbedtls_mpi_free(&ctx.Vi);
	mbedtls_mpi_free(&ctx.RP);
	mbedtls_mpi_free(&ctx.K);
	mbedtls_mpi_free(&ctx.GY);
	mbedtls_mpi_free(&ctx.GX);
	mbedtls_mpi_free(&ctx.X);
	mbedtls_mpi_free(&ctx.G);
	mbedtls_mpi_free(&ctx.P);
	zeroize(ctx, sizeof(mbedtls_dhm_context));
}

pub fn mbedtls_dhm_parse_dhm(mbedtls_dhm_context * dhm, const u8 * dhmin, usize dhminlen) -> i32
{
	i32 ret;
	usize len;
	u8 *p, *end;
	mbedtls_pem_context pem;
	mbedtls_pem_init(&pem);
	if dhminlen == 0 || dhmin[dhminlen - 1] != '\0'
	{
		ret = -0x1080;
	}
	else
	{
		ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN DH PARAMETERS-----", "-----END DH PARAMETERS-----", dhmin, NULL, 0, &dhminlen);
	}
	if ret == 0
	{
		dhminlen = pem.buflen;
	}
	else
		if ret != -0x1080
		{
			goto exit;
		}
	p = (ret == 0) ? pem.buf : (u8 *) dhmin;
	end = p + dhminlen;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		ret = -0x3380 + ret;
		goto exit;
	}
	end = p + len;
	if (ret = mbedtls_asn1_get_mpi(&p, end, &dhm.P)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &dhm.G)) != 0
	{
		ret = -0x3380 + ret;
		goto exit;
	}
	if p != end
	{
		mbedtls_mpi rec;
		mbedtls_mpi_init(&rec);
		ret = mbedtls_asn1_get_mpi(&p, end, &rec);
		mbedtls_mpi_free(&rec);
		if ret != 0
		{
			ret = -0x3380 + ret;
			goto exit;
		}
		if p != end
		{
			ret = -0x3380 + -0x0066;
			goto exit;
		}
	}
	ret = 0;
	dhm.len = mbedtls_mpi_size(&dhm.P);
exit:
	mbedtls_pem_free(&pem);
	if ret != 0
	{
		mbedtls_dhm_free(dhm);
	}
	return ret;
}

fn load_file(const i8 * path, u8 ** buf, usize * n) -> i32
{
	FILE * f;
	i32 size;
	if (f = fopen(path, "rb")) == NULL
	{
		return -0x3480;
	}
	fseek(f, 0, SEEK_END);
	if (size = ftell(f)) == -1
	{
		fclose(f);
		return -0x3480;
	}
	fseek(f, 0, SEEK_SET);
	*n = (usize) size;
	if *n + 1 == 0 || (*buf = mbedtls_calloc(1, *n + 1)) == NULL
	{
		fclose(f);
		return -0x3400;
	}
	if fread(*buf, 1, *n, f) != *n
	{
		fclose(f);
		mbedtls_free(*buf);
		return -0x3480;
	}
	fclose(f);
	(*buf)[*n] = '\0';
	if strstr((const i8 *) *buf, "-----BEGIN ") != NULL
	{
		++*n;
	}
	return 0;
}

pub fn mbedtls_dhm_parse_dhmfile(mbedtls_dhm_context * dhm, const i8 * path) -> i32
{
	i32 ret;
	usize n;
	u8 * buf;
	if (ret = load_file(path, &buf, &n)) != 0
	{
		return ret;
	}
	ret = mbedtls_dhm_parse_dhm(dhm, buf, n);
	zeroize(buf, n);
	mbedtls_free(buf);
	return ret;
}

static const i8 mbedtls_test_dhm_params[] = "-----BEGIN DH PARAMETERS-----\r\n"
		"MIGHAoGBAJ419DBEOgmQTzo5qXl5fQcN9TN455wkOL7052HzxxRVMyhYmwQcgJvh\r\n"
		"1sa18fyfR9OiVEMYglOpkqVoGLN7qd5aQNNi5W7/C+VBdHTBJcGZJyyP5B3qcz32\r\n"
		"9mLJKudlVudV0Qxk5qUJaPZ/xupz0NyoVpviuiBOI1gNi8ovSXWzAgEC\r\n"
		"-----END DH PARAMETERS-----\r\n";

pub fn mbedtls_dhm_self_test(i32 verbose) -> i32
{
	i32 ret;
	mbedtls_dhm_context dhm;
	mbedtls_dhm_init(&dhm);
	if verbose != 0
	{
		printf("  DHM parameter load: ");
	}
	if (ret = mbedtls_dhm_parse_dhm(&dhm, (const u8 *) mbedtls_test_dhm_params, mbedtls_test_dhm_params_len)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto exit;
	}
	if verbose != 0
	{
		printf("passed\n\n");
	}
exit:
	mbedtls_dhm_free(&dhm);
	return ret;
}

typedef enum
{
	MBEDTLS_ECP_DP_NONE = 0,
	MBEDTLS_ECP_DP_SECP192R1,
	MBEDTLS_ECP_DP_SECP224R1,
	MBEDTLS_ECP_DP_SECP256R1,
	MBEDTLS_ECP_DP_SECP384R1,
	MBEDTLS_ECP_DP_SECP521R1,
	MBEDTLS_ECP_DP_BP256R1,
	MBEDTLS_ECP_DP_BP384R1,
	MBEDTLS_ECP_DP_BP512R1,
	MBEDTLS_ECP_DP_CURVE25519,
	MBEDTLS_ECP_DP_SECP192K1,
	MBEDTLS_ECP_DP_SECP224K1,
	MBEDTLS_ECP_DP_SECP256K1,
} mbedtls_ecp_group_id;
typedef struct
{
	mbedtls_ecp_group_id grp_id;
	u16 tls_id;
	u16 bit_size;
	const i8 * name;
} mbedtls_ecp_curve_info;
typedef struct
{
	mbedtls_mpi X;
	mbedtls_mpi Y;
	mbedtls_mpi Z;
} mbedtls_ecp_point;
typedef struct
{
	mbedtls_ecp_group_id id;
	mbedtls_mpi P;
	mbedtls_mpi A;
	mbedtls_mpi B;
	mbedtls_ecp_poi32 G;
	mbedtls_mpi N;
	usize pbits;
	usize nbits;
	u32 h;
	i32 (*modp)(mbedtls_mpi *);
	i32 (*t_pre)(mbedtls_ecp_poi32 *, void *);
	i32 (*t_post)(mbedtls_ecp_poi32 *, void *);
	void * t_data;
	mbedtls_ecp_poi32 * T;
	usize T_size;
} mbedtls_ecp_group;
typedef struct
{
	mbedtls_ecp_group grp;
	mbedtls_mpi d;
	mbedtls_ecp_poi32 Q;
} mbedtls_ecp_keypair;

typedef enum
{
	MBEDTLS_ECDH_OURS,
	MBEDTLS_ECDH_THEIRS,
} mbedtls_ecdh_side;
typedef struct
{
	mbedtls_ecp_group grp;
	mbedtls_mpi d;
	mbedtls_ecp_poi32 Q;
	mbedtls_ecp_poi32 Qp;
	mbedtls_mpi z;
	i32 point_format;
	mbedtls_ecp_poi32 Vi;
	mbedtls_ecp_poi32 Vf;
	mbedtls_mpi _d;
} mbedtls_ecdh_context;

pub fn mbedtls_ecdh_gen_public(mbedtls_ecp_group * grp, mbedtls_mpi * d, mbedtls_ecp_poi32 * Q, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	return mbedtls_ecp_gen_keypair(grp, d, Q, f_rng, p_rng);
}

pub fn mbedtls_ecdh_compute_shared(mbedtls_ecp_group * grp, mbedtls_mpi * z, const mbedtls_ecp_poi32 * Q, const mbedtls_mpi * d, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 P;
	mbedtls_ecp_point_init(&P);
	do
	{
		if (ret = mbedtls_ecp_check_pubkey(grp, Q)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(grp, &P, d, Q, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_ecp_is_zero(&P)
	{
		ret = -0x4F80;
		goto cleanup;
	}
	do
	{
		if (ret = mbedtls_mpi_copy(z, &P.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_ecp_point_free(&P);
	return ret;
}

pub fn mbedtls_ecdh_init(mbedtls_ecdh_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_ecdh_context));
}

pub fn mbedtls_ecdh_free(mbedtls_ecdh_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	mbedtls_ecp_group_free(&ctx.grp);
	mbedtls_ecp_point_free(&ctx.Q);
	mbedtls_ecp_point_free(&ctx.Qp);
	mbedtls_ecp_point_free(&ctx.Vi);
	mbedtls_ecp_point_free(&ctx.Vf);
	mbedtls_mpi_free(&ctx.d);
	mbedtls_mpi_free(&ctx.z);
	mbedtls_mpi_free(&ctx._d);
}

pub fn mbedtls_ecdh_make_params(mbedtls_ecdh_context * ctx, usize * olen, u8 * buf, usize blen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	usize grp_len, pt_len;
	if ctx == NULL || ctx.grp.pbits == 0
	{
		return -0x4F80;
	}
	if (ret = mbedtls_ecdh_gen_public(&ctx.grp, &ctx.d, &ctx.Q, f_rng, p_rng)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_ecp_tls_write_group(&ctx.grp, &grp_len, buf, blen)) != 0
	{
		return ret;
	}
	buf += grp_len;
	blen -= grp_len;
	if (ret = mbedtls_ecp_tls_write_point(&ctx.grp, &ctx.Q, ctx.point_format, &pt_len, buf, blen)) != 0
	{
		return ret;
	}
	*olen = grp_len + pt_len;
	return 0;
}

pub fn mbedtls_ecdh_read_params(mbedtls_ecdh_context * ctx, const u8 ** buf, const u8 * end) -> i32
{
	i32 ret;
	if (ret = mbedtls_ecp_tls_read_group(&ctx.grp, buf, end - *buf)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_ecp_tls_read_point(&ctx.grp, &ctx.Qp, buf, end - *buf)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_ecdh_get_params(mbedtls_ecdh_context * ctx, const mbedtls_ecp_keypair * key, mbedtls_ecdh_side side) -> i32
{
	i32 ret;
	if (ret = mbedtls_ecp_group_copy(&ctx.grp, &key.grp)) != 0
	{
		return ret;
	}
	if side == MBEDTLS_ECDH_THEIRS
	{
		return mbedtls_ecp_copy(&ctx.Qp, &key.Q);
	}
	if side != MBEDTLS_ECDH_OURS
	{
		return -0x4F80;
	}
	if (ret = mbedtls_ecp_copy(&ctx.Q, &key.Q)) != 0 || (ret = mbedtls_mpi_copy(&ctx.d, &key.d)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_ecdh_make_public(mbedtls_ecdh_context * ctx, usize * olen, u8 * buf, usize blen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	if ctx == NULL || ctx.grp.pbits == 0
	{
		return -0x4F80;
	}
	if (ret = mbedtls_ecdh_gen_public(&ctx.grp, &ctx.d, &ctx.Q, f_rng, p_rng)) != 0
	{
		return ret;
	}
	return mbedtls_ecp_tls_write_point(&ctx.grp, &ctx.Q, ctx.point_format, olen, buf, blen);
}

pub fn mbedtls_ecdh_read_public(mbedtls_ecdh_context * ctx, const u8 * buf, usize blen) -> i32
{
	i32 ret;
	const u8 * p = buf;
	if ctx == NULL
	{
		return -0x4F80;
	}
	if (ret = mbedtls_ecp_tls_read_point(&ctx.grp, &ctx.Qp, &p, blen)) != 0
	{
		return ret;
	}
	if (usize)(p - buf) != blen
	{
		return -0x4F80;
	}
	return 0;
}

pub fn mbedtls_ecdh_calc_secret(mbedtls_ecdh_context * ctx, usize * olen, u8 * buf, usize blen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	if ctx == NULL
	{
		return -0x4F80;
	}
	if (ret = mbedtls_ecdh_compute_shared(&ctx.grp, &ctx.z, &ctx.Qp, &ctx.d, f_rng, p_rng)) != 0
	{
		return ret;
	}
	if mbedtls_mpi_size(&ctx.z) > blen
	{
		return -0x4F80;
	}
	*olen = ctx.grp.pbits / 8 + ((ctx.grp.pbits % 8) != 0);
	return mbedtls_mpi_write_binary(&ctx.z, buf, *olen);
}

typedef enum
{
	MBEDTLS_MD_NONE = 0,
	MBEDTLS_MD_MD2,
	MBEDTLS_MD_MD4,
	MBEDTLS_MD_MD5,
	MBEDTLS_MD_SHA1,
	MBEDTLS_MD_SHA224,
	MBEDTLS_MD_SHA256,
	MBEDTLS_MD_SHA384,
	MBEDTLS_MD_SHA512,
	MBEDTLS_MD_RIPEMD160,
} mbedtls_md_type_t;
typedef struct mbedtls_md_info_t mbedtls_md_info_t;
typedef struct
{
	const mbedtls_md_info_t * md_info;
	void * md_ctx;
	void * hmac_ctx;
} mbedtls_md_context_t;

pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;

typedef struct
{
	mbedtls_md_context_t md_ctx;
	u8 V[64];
	i32 reseed_counter;
	usize entropy_len;
	i32 prediction_resistance;
	i32 reseed_interval;
	i32 (*f_entropy)(void *, u8 *, usize);
	void * p_entropy;
	mbedtls_threading_mutex_t mutex;
} mbedtls_hmac_drbg_context;

fn derive_mpi(const mbedtls_ecp_group * grp, mbedtls_mpi * x, const u8 * buf, usize blen) -> i32
{
	i32 ret;
	usize n_size = (grp.nbits + 7) / 8;
	usize use_size = blen > n_size ? n_size : blen;
	do
	{
		if (ret = mbedtls_mpi_read_binary(x, buf, use_size)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if use_size * 8 > grp.nbits
		do
		{
			if (ret = mbedtls_mpi_shift_r(x, use_size * 8 - grp.nbits)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	if mbedtls_mpi_cmp_mpi(x, &grp.N) >= 0
		do
		{
			if (ret = mbedtls_mpi_sub_mpi(x, x, &grp.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
cleanup:
	return ret;
}

pub fn mbedtls_ecdsa_sign(mbedtls_ecp_group * grp, mbedtls_mpi * r, mbedtls_mpi * s, const mbedtls_mpi * d, const u8 * buf, usize blen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret, key_tries, sign_tries, blind_tries;
	mbedtls_ecp_poi32 R;
	mbedtls_mpi k, e, t;
	if grp.N.p == NULL
	{
		return -0x4F80;
	}
	mbedtls_ecp_point_init(&R);
	mbedtls_mpi_init(&k);
	mbedtls_mpi_init(&e);
	mbedtls_mpi_init(&t);
	sign_tries = 0;
	do
	{
		key_tries = 0;
		do
		{
			do
			{
				if (ret = mbedtls_ecp_gen_keypair(grp, &k, &R, f_rng, p_rng)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_mod_mpi(r, &R.X, &grp.N)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			if key_tries++ > 10
			{
				ret = -0x4D00;
				goto cleanup;
			}
		}
		while (mbedtls_mpi_cmp_int(r, 0) == 0);
		do
		{
			if (ret = derive_mpi(grp, &e, buf, blen)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		blind_tries = 0;
		do
		{
			usize n_size = (grp.nbits + 7) / 8;
			do
			{
				if (ret = mbedtls_mpi_fill_random(&t, n_size, f_rng, p_rng)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_shift_r(&t, 8 * n_size - grp.nbits)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			if ++blind_tries > 30
			{
				return -0x4D00;
			}
		}
		while (mbedtls_mpi_cmp_int(&t, 1) < 0 || mbedtls_mpi_cmp_mpi(&t, &grp.N) >= 0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(s, r, d)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&e, &e, s)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&e, &e, &t)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&k, &k, &t)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_inv_mod(s, &k, &grp.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(s, s, &e)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(s, s, &grp.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if sign_tries++ > 10
		{
			ret = -0x4D00;
			goto cleanup;
		}
	}
	while (mbedtls_mpi_cmp_int(s, 0) == 0);
cleanup:
	mbedtls_ecp_point_free(&R);
	mbedtls_mpi_free(&k);
	mbedtls_mpi_free(&e);
	mbedtls_mpi_free(&t);
	return ret;
}

pub fn mbedtls_ecdsa_sign_det(mbedtls_ecp_group * grp, mbedtls_mpi * r, mbedtls_mpi * s, const mbedtls_mpi * d, const u8 * buf, usize blen, mbedtls_md_type_t md_alg) -> i32
{
	i32 ret;
	mbedtls_hmac_drbg_context rng_ctx;
	u8 data[2 * ((521 + 7) / 8)];
	usize grp_len = (grp.nbits + 7) / 8;
	const mbedtls_md_info_t * md_info;
	mbedtls_mpi h;
	if (md_info = mbedtls_md_info_from_type(md_alg)) == NULL
	{
		return -0x4F80;
	}
	mbedtls_mpi_init(&h);
	mbedtls_hmac_drbg_init(&rng_ctx);
	do
	{
		if (ret = mbedtls_mpi_write_binary(d, data, grp_len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = derive_mpi(grp, &h, buf, blen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_write_binary(&h, data + grp_len, grp_len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	mbedtls_hmac_drbg_seed_buf(&rng_ctx, md_info, data, 2 * grp_len);
	ret = mbedtls_ecdsa_sign(grp, r, s, d, buf, blen, mbedtls_hmac_drbg_random, &rng_ctx);
cleanup:
	mbedtls_hmac_drbg_free(&rng_ctx);
	mbedtls_mpi_free(&h);
	return ret;
}

pub fn mbedtls_ecdsa_verify(mbedtls_ecp_group * grp, const u8 * buf, usize blen, const mbedtls_ecp_poi32 * Q, const mbedtls_mpi * r, const mbedtls_mpi * s) -> i32
{
	i32 ret;
	mbedtls_mpi e, s_inv, u1, u2;
	mbedtls_ecp_poi32 R;
	mbedtls_ecp_point_init(&R);
	mbedtls_mpi_init(&e);
	mbedtls_mpi_init(&s_inv);
	mbedtls_mpi_init(&u1);
	mbedtls_mpi_init(&u2);
	if grp.N.p == NULL
	{
		return -0x4F80;
	}
	if mbedtls_mpi_cmp_int(r, 1) < 0 || mbedtls_mpi_cmp_mpi(r, &grp.N) >= 0 || mbedtls_mpi_cmp_int(s, 1) < 0 || mbedtls_mpi_cmp_mpi(s, &grp.N) >= 0
	{
		ret = -0x4E00;
		goto cleanup;
	}
	do
	{
		if (ret = mbedtls_ecp_check_pubkey(grp, Q)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = derive_mpi(grp, &e, buf, blen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&s_inv, s, &grp.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&u1, &e, &s_inv)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&u1, &u1, &grp.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&u2, r, &s_inv)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&u2, &u2, &grp.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_muladd(grp, &R, &u1, &grp.G, &u2, Q)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_ecp_is_zero(&R)
	{
		ret = -0x4E00;
		goto cleanup;
	}
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&R.X, &R.X, &grp.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_mpi(&R.X, r) != 0
	{
		ret = -0x4E00;
		goto cleanup;
	}
cleanup:
	mbedtls_ecp_point_free(&R);
	mbedtls_mpi_free(&e);
	mbedtls_mpi_free(&s_inv);
	mbedtls_mpi_free(&u1);
	mbedtls_mpi_free(&u2);
	return ret;
}

fn ecdsa_signature_to_asn1(const mbedtls_mpi * r, const mbedtls_mpi * s, u8 * sig, usize * slen) -> i32
{
	i32 ret;
	u8 buf[(3 + 2 * (3 + ((521 + 7) / 8)))];
	u8 * p = buf + sizeof(buf);
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_mpi(&p, buf, s)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_mpi(&p, buf, r)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(&p, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&p, buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	memcpy(sig, p, len);
	*slen = len;
	return 0;
}

pub fn mbedtls_ecdsa_write_signature(mbedtls_ecdsa_context * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hlen, u8 * sig, usize * slen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_mpi r, s;
	mbedtls_mpi_init(&r);
	mbedtls_mpi_init(&s);
	(void) f_rng;
	(void) p_rng;
	do
	{
		if (ret = mbedtls_ecdsa_sign_det(&ctx.grp, &r, &s, &ctx.d, hash, hlen, md_alg)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecdsa_signature_to_asn1(&r, &s, sig, slen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&r);
	mbedtls_mpi_free(&s);
	return ret;
}

pub fn mbedtls_ecdsa_read_signature(mbedtls_ecdsa_context * ctx, const u8 * hash, usize hlen, const u8 * sig, usize slen) -> i32
{
	i32 ret;
	u8 * p = (u8 *) sig;
	const u8 * end = sig + slen;
	usize len;
	mbedtls_mpi r, s;
	mbedtls_mpi_init(&r);
	mbedtls_mpi_init(&s);
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		ret += -0x4F80;
		goto cleanup;
	}
	if p + len != end
	{
		ret = -0x4F80 + -0x0066;
		goto cleanup;
	}
	if (ret = mbedtls_asn1_get_mpi(&p, end, &r)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &s)) != 0
	{
		ret += -0x4F80;
		goto cleanup;
	}
	if (ret = mbedtls_ecdsa_verify(&ctx.grp, hash, hlen, &ctx.Q, &r, &s)) != 0
	{
		goto cleanup;
	}
	if p != end
	{
		ret = -0x4C00;
	}
cleanup:
	mbedtls_mpi_free(&r);
	mbedtls_mpi_free(&s);
	return ret;
}

pub fn mbedtls_ecdsa_genkey(mbedtls_ecdsa_context * ctx, mbedtls_ecp_group_id gid, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	return mbedtls_ecp_group_load(&ctx.grp, gid) || mbedtls_ecp_gen_keypair(&ctx.grp, &ctx.d, &ctx.Q, f_rng, p_rng);
}

pub fn mbedtls_ecdsa_from_keypair(mbedtls_ecdsa_context * ctx, const mbedtls_ecp_keypair * key) -> i32
{
	i32 ret;
	if (ret = mbedtls_ecp_group_copy(&ctx.grp, &key.grp)) != 0 || (ret = mbedtls_mpi_copy(&ctx.d, &key.d)) != 0 || (ret = mbedtls_ecp_copy(&ctx.Q, &key.Q)) != 0
	{
		mbedtls_ecdsa_free(ctx);
	}
	return ret;
}

pub fn mbedtls_ecdsa_init(mbedtls_ecdsa_context * ctx)
{
	mbedtls_ecp_keypair_init(ctx);
}

pub fn mbedtls_ecdsa_free(mbedtls_ecdsa_context * ctx)
{
	mbedtls_ecp_keypair_free(ctx);
}

typedef enum
{
	MBEDTLS_ECJPAKE_CLIENT = 0,
	MBEDTLS_ECJPAKE_SERVER,
} mbedtls_ecjpake_role;
typedef struct
{
	const mbedtls_md_info_t * md_info;
	mbedtls_ecp_group grp;
	mbedtls_ecjpake_role role;
	i32 point_format;
	mbedtls_ecp_poi32 Xm1;
	mbedtls_ecp_poi32 Xm2;
	mbedtls_ecp_poi32 Xp1;
	mbedtls_ecp_poi32 Xp2;
	mbedtls_ecp_poi32 Xp;
	mbedtls_mpi xm1;
	mbedtls_mpi xm2;
	mbedtls_mpi s;
} mbedtls_ecjpake_context;

static const i8 * const ecjpake_id[] = {"client", "server"};
pub fn mbedtls_ecjpake_init(mbedtls_ecjpake_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	ctx.md_info = NULL;
	mbedtls_ecp_group_init(&ctx.grp);
	ctx.point_format = 0;
	mbedtls_ecp_point_init(&ctx.Xm1);
	mbedtls_ecp_point_init(&ctx.Xm2);
	mbedtls_ecp_point_init(&ctx.Xp1);
	mbedtls_ecp_point_init(&ctx.Xp2);
	mbedtls_ecp_point_init(&ctx.Xp);
	mbedtls_mpi_init(&ctx.xm1);
	mbedtls_mpi_init(&ctx.xm2);
	mbedtls_mpi_init(&ctx.s);
}

pub fn mbedtls_ecjpake_free(mbedtls_ecjpake_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	ctx.md_info = NULL;
	mbedtls_ecp_group_free(&ctx.grp);
	mbedtls_ecp_point_free(&ctx.Xm1);
	mbedtls_ecp_point_free(&ctx.Xm2);
	mbedtls_ecp_point_free(&ctx.Xp1);
	mbedtls_ecp_point_free(&ctx.Xp2);
	mbedtls_ecp_point_free(&ctx.Xp);
	mbedtls_mpi_free(&ctx.xm1);
	mbedtls_mpi_free(&ctx.xm2);
	mbedtls_mpi_free(&ctx.s);
}

pub fn mbedtls_ecjpake_setup(mbedtls_ecjpake_context * ctx, mbedtls_ecjpake_role role, mbedtls_md_type_t hash, mbedtls_ecp_group_id curve, const u8 * secret, usize len) -> i32
{
	i32 ret;
	ctx.role = role;
	if (ctx.md_info = mbedtls_md_info_from_type(hash)) == NULL
	{
		return -0x5080;
	}
	do
	{
		if (ret = mbedtls_ecp_group_load(&ctx.grp, curve)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_read_binary(&ctx.s, secret, len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	if ret != 0
	{
		mbedtls_ecjpake_free(ctx);
	}
	return ret;
}

pub fn mbedtls_ecjpake_check(const mbedtls_ecjpake_context * ctx) -> i32
{
	if ctx.md_info == NULL || ctx.grp.id == MBEDTLS_ECP_DP_NONE || ctx.s.p == NULL
	{
		return -0x4F80;
	}
	return 0;
}

fn ecjpake_write_len_point(u8 ** p, const u8 * end, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * P) -> i32
{
	i32 ret;
	usize len;
	if end < *p || end - *p < 5
	{
		return -0x4F00;
	}
	ret = mbedtls_ecp_point_write_binary(grp, P, pf, &len, *p + 4, end - (*p + 4));
	if ret != 0
	{
		return ret;
	}
	(*p)[0] = (i8) ((len >> 24) & 0xFF);
	(*p)[1] = (i8) ((len >> 16) & 0xFF);
	(*p)[2] = (i8) ((len >> 8) & 0xFF);
	(*p)[3] = (i8) ((len) &0xFF);
	*p += 4 + len;
	return 0;
}

fn ecjpake_hash(const mbedtls_md_info_t * md_info, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * G, const mbedtls_ecp_poi32 * V, const mbedtls_ecp_poi32 * X, const i8 * id, mbedtls_mpi * h) -> i32
{
	i32 ret;
	u8 buf[(3 * (4 + (2 * ((521 + 7) / 8) + 1)) + 4 + 6)];
	u8 * p = buf;
	const u8 * end = buf + sizeof(buf);
	const usize id_len = strlen(id);
	u8 hash[64];
	do
	{
		if (ret = ecjpake_write_len_point(&p, end, grp, pf, G)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_write_len_point(&p, end, grp, pf, V)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_write_len_point(&p, end, grp, pf, X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if end - p < 4
	{
		return -0x4F00;
	}
	*p++ = (i8) ((id_len >> 24) & 0xFF);
	*p++ = (i8) ((id_len >> 16) & 0xFF);
	*p++ = (i8) ((id_len >> 8) & 0xFF);
	*p++ = (i8) ((id_len) &0xFF);
	if end < p || (usize)(end - p) < id_len
	{
		return -0x4F00;
	}
	memcpy(p, id, id_len);
	p += id_len;
	mbedtls_md(md_info, buf, p - buf, hash);
	do
	{
		if (ret = mbedtls_mpi_read_binary(h, hash, mbedtls_md_get_size(md_info))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(h, h, &grp.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecjpake_zkp_read(const mbedtls_md_info_t * md_info, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * G, const mbedtls_ecp_poi32 * X, const i8 * id, const u8 ** p, const u8 * end) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 V, VV;
	mbedtls_mpi r, h;
	usize r_len;
	mbedtls_ecp_point_init(&V);
	mbedtls_ecp_point_init(&VV);
	mbedtls_mpi_init(&r);
	mbedtls_mpi_init(&h);
	if end < *p
	{
		return -0x4F80;
	}
	do
	{
		if (ret = mbedtls_ecp_tls_read_point(grp, &V, p, end - *p)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if end < *p || (usize)(end - *p) < 1
	{
		ret = -0x4F80;
		goto cleanup;
	}
	r_len = *(*p)++;
	if end < *p || (usize)(end - *p) < r_len
	{
		ret = -0x4F80;
		goto cleanup;
	}
	do
	{
		if (ret = mbedtls_mpi_read_binary(&r, *p, r_len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*p += r_len;
	do
	{
		if (ret = ecjpake_hash(md_info, grp, pf, G, &V, X, id, &h)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_muladd((mbedtls_ecp_group *) grp, &VV, &h, X, &r, G)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_ecp_point_cmp(&VV, &V) != 0
	{
		ret = -0x4E00;
		goto cleanup;
	}
cleanup:
	mbedtls_ecp_point_free(&V);
	mbedtls_ecp_point_free(&VV);
	mbedtls_mpi_free(&r);
	mbedtls_mpi_free(&h);
	return ret;
}

fn ecjpake_zkp_write(const mbedtls_md_info_t * md_info, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * G, const mbedtls_mpi * x, const mbedtls_ecp_poi32 * X, const i8 * id, u8 ** p, const u8 * end, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 V;
	mbedtls_mpi v;
	mbedtls_mpi h;
	usize len;
	if end < *p
	{
		return -0x4F00;
	}
	mbedtls_ecp_point_init(&V);
	mbedtls_mpi_init(&v);
	mbedtls_mpi_init(&h);
	do
	{
		if (ret = mbedtls_ecp_gen_keypair_base((mbedtls_ecp_group *) grp, G, &v, &V, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_hash(md_info, grp, pf, G, &V, X, id, &h)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&h, &h, x)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&h, &v, &h)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&h, &h, &grp.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_tls_write_point(grp, &V, pf, &len, *p, end - *p)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*p += len;
	len = mbedtls_mpi_size(&h);
	if end < *p || (usize)(end - *p) < 1 + len || len > 255
	{
		ret = -0x4F00;
		goto cleanup;
	}
	*(*p)++ = (i8) (len & 0xFF);
	do
	{
		if (ret = mbedtls_mpi_write_binary(&h, *p, len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*p += len;
cleanup:
	mbedtls_ecp_point_free(&V);
	mbedtls_mpi_free(&v);
	mbedtls_mpi_free(&h);
	return ret;
}

fn ecjpake_kkp_read(const mbedtls_md_info_t * md_info, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * G, mbedtls_ecp_poi32 * X, const i8 * id, const u8 ** p, const u8 * end) -> i32
{
	i32 ret;
	if end < *p
	{
		return -0x4F80;
	}
	do
	{
		if (ret = mbedtls_ecp_tls_read_point(grp, X, p, end - *p)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_ecp_is_zero(X)
	{
		ret = -0x4C80;
		goto cleanup;
	}
	do
	{
		if (ret = ecjpake_zkp_read(md_info, grp, pf, G, X, id, p, end)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecjpake_kkp_write(const mbedtls_md_info_t * md_info, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * G, mbedtls_mpi * x, mbedtls_ecp_poi32 * X, const i8 * id, u8 ** p, const u8 * end, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	usize len;
	if end < *p
	{
		return -0x4F00;
	}
	do
	{
		if (ret = mbedtls_ecp_gen_keypair_base((mbedtls_ecp_group *) grp, G, x, X, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_tls_write_point(grp, X, pf, &len, *p, end - *p)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*p += len;
	do
	{
		if (ret = ecjpake_zkp_write(md_info, grp, pf, G, x, X, id, p, end, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecjpake_kkpp_read(const mbedtls_md_info_t * md_info, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * G, mbedtls_ecp_poi32 * Xa, mbedtls_ecp_poi32 * Xb, const i8 * id, const u8 * buf, usize len) -> i32
{
	i32 ret;
	const u8 * p = buf;
	const u8 * end = buf + len;
	do
	{
		if (ret = ecjpake_kkp_read(md_info, grp, pf, G, Xa, id, &p, end)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_kkp_read(md_info, grp, pf, G, Xb, id, &p, end)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if p != end
	{
		ret = -0x4F80;
	}
cleanup:
	return ret;
}

fn ecjpake_kkpp_write(const mbedtls_md_info_t * md_info, const mbedtls_ecp_group * grp, const i32 pf, const mbedtls_ecp_poi32 * G, mbedtls_mpi * xm1, mbedtls_ecp_poi32 * Xa, mbedtls_mpi * xm2, mbedtls_ecp_poi32 * Xb, const i8 * id, u8 * buf, usize len, usize * olen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	u8 * p = buf;
	const u8 * end = buf + len;
	do
	{
		if (ret = ecjpake_kkp_write(md_info, grp, pf, G, xm1, Xa, id, &p, end, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_kkp_write(md_info, grp, pf, G, xm2, Xb, id, &p, end, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*olen = p - buf;
cleanup:
	return ret;
}

pub fn mbedtls_ecjpake_read_round_one(mbedtls_ecjpake_context * ctx, const u8 * buf, usize len) -> i32
{
	return ecjpake_kkpp_read(ctx.md_info, &ctx.grp, ctx.point_format, &ctx.grp.G, &ctx.Xp1, &ctx.Xp2, (ecjpake_id[1 - ctx.role]), buf, len);
}

pub fn mbedtls_ecjpake_write_round_one(mbedtls_ecjpake_context * ctx, u8 * buf, usize len, usize * olen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	return ecjpake_kkpp_write(ctx.md_info, &ctx.grp, ctx.point_format, &ctx.grp.G, &ctx.xm1, &ctx.Xm1, &ctx.xm2, &ctx.Xm2, (ecjpake_id[ctx.role]), buf, len, olen, f_rng, p_rng);
}

fn ecjpake_ecp_add3(mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_ecp_poi32 * A, const mbedtls_ecp_poi32 * B, const mbedtls_ecp_poi32 * C) -> i32
{
	i32 ret;
	mbedtls_mpi one;
	mbedtls_mpi_init(&one);
	do
	{
		if (ret = mbedtls_mpi_lset(&one, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_muladd(grp, R, &one, A, &one, B)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_muladd(grp, R, &one, R, &one, C)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&one);
	return ret;
}

pub fn mbedtls_ecjpake_read_round_two(mbedtls_ecjpake_context * ctx, const u8 * buf, usize len) -> i32
{
	i32 ret;
	const u8 * p = buf;
	const u8 * end = buf + len;
	mbedtls_ecp_group grp;
	mbedtls_ecp_poi32 G;
	mbedtls_ecp_group_init(&grp);
	mbedtls_ecp_point_init(&G);
	do
	{
		if (ret = ecjpake_ecp_add3(&ctx.grp, &G, &ctx.Xm1, &ctx.Xm2, &ctx.Xp1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if ctx.role == MBEDTLS_ECJPAKE_CLIENT
	{
		do
		{
			if (ret = mbedtls_ecp_tls_read_group(&grp, &p, len)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if grp.id != ctx.grp.id
		{
			ret = -0x4E80;
			goto cleanup;
		}
	}
	do
	{
		if (ret = ecjpake_kkp_read(ctx.md_info, &ctx.grp, ctx.point_format, &G, &ctx.Xp, (ecjpake_id[1 - ctx.role]), &p, end)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if p != end
	{
		ret = -0x4F80;
		goto cleanup;
	}
cleanup:
	mbedtls_ecp_group_free(&grp);
	mbedtls_ecp_point_free(&G);
	return ret;
}

fn ecjpake_mul_secret(mbedtls_mpi * R, i32 sign, const mbedtls_mpi * X, const mbedtls_mpi * S, const mbedtls_mpi * N, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_mpi b;
	mbedtls_mpi_init(&b);
	do
	{
		if (ret = mbedtls_mpi_fill_random(&b, 16, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&b, &b, N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_mpi(&b, &b, S)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(R, X, &b)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	R.s *= sign;
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(R, R, N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&b);
	return ret;
}

pub fn mbedtls_ecjpake_write_round_two(mbedtls_ecjpake_context * ctx, u8 * buf, usize len, usize * olen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 G;
	mbedtls_ecp_poi32 Xm;
	mbedtls_mpi xm;
	u8 * p = buf;
	const u8 * end = buf + len;
	usize ec_len;
	mbedtls_ecp_point_init(&G);
	mbedtls_ecp_point_init(&Xm);
	mbedtls_mpi_init(&xm);
	do
	{
		if (ret = ecjpake_ecp_add3(&ctx.grp, &G, &ctx.Xp1, &ctx.Xp2, &ctx.Xm1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_mul_secret(&xm, 1, &ctx.xm2, &ctx.s, &ctx.grp.N, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(&ctx.grp, &Xm, &xm, &G, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if ctx.role == MBEDTLS_ECJPAKE_SERVER
	{
		if end < p
		{
			ret = -0x4F00;
			goto cleanup;
		}
		do
		{
			if (ret = mbedtls_ecp_tls_write_group(&ctx.grp, &ec_len, p, end - p)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		p += ec_len;
	}
	if end < p
	{
		ret = -0x4F00;
		goto cleanup;
	}
	do
	{
		if (ret = mbedtls_ecp_tls_write_point(&ctx.grp, &Xm, ctx.point_format, &ec_len, p, end - p)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	p += ec_len;
	do
	{
		if (ret = ecjpake_zkp_write(ctx.md_info, &ctx.grp, ctx.point_format, &G, &xm, &Xm, (ecjpake_id[ctx.role]), &p, end, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	*olen = p - buf;
cleanup:
	mbedtls_ecp_point_free(&G);
	mbedtls_ecp_point_free(&Xm);
	mbedtls_mpi_free(&xm);
	return ret;
}

pub fn mbedtls_ecjpake_derive_secret(mbedtls_ecjpake_context * ctx, u8 * buf, usize len, usize * olen, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 K;
	mbedtls_mpi m_xm2_s, one;
	u8 kx[((521 + 7) / 8)];
	usize x_bytes;
	*olen = mbedtls_md_get_size(ctx.md_info);
	if len < *olen
	{
		return -0x4F00;
	}
	mbedtls_ecp_point_init(&K);
	mbedtls_mpi_init(&m_xm2_s);
	mbedtls_mpi_init(&one);
	do
	{
		if (ret = mbedtls_mpi_lset(&one, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_mul_secret(&m_xm2_s, -1, &ctx.xm2, &ctx.s, &ctx.grp.N, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_muladd(&ctx.grp, &K, &one, &ctx.Xp, &m_xm2_s, &ctx.Xp2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(&ctx.grp, &K, &ctx.xm2, &K, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	x_bytes = (ctx.grp.pbits + 7) / 8;
	do
	{
		if (ret = mbedtls_mpi_write_binary(&K.X, kx, x_bytes)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_md(ctx.md_info, kx, x_bytes, buf)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_ecp_point_free(&K);
	mbedtls_mpi_free(&m_xm2_s);
	mbedtls_mpi_free(&one);
	return ret;
}

static const u8 ecjpake_test_password[] = {0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x6a, 0x70, 0x61, 0x6b, 0x65, 0x74, 0x65, 0x73, 0x74};
static const u8 ecjpake_test_x1[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x21};
static const u8 ecjpake_test_x2[] = {0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x81};
static const u8 ecjpake_test_x3[] = {0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x81};
static const u8 ecjpake_test_x4[] = {0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe1};
static const u8 ecjpake_test_cli_one[] = {0x41, 0x04, 0xac, 0xcf, 0x01, 0x06, 0xef, 0x85, 0x8f, 0xa2, 0xd9, 0x19, 0x33, 0x13, 0x46, 0x80, 0x5a, 0x78, 0xb5, 0x8b, 0xba, 0xd0, 0xb8, 0x44, 0xe5, 0xc7, 0x89, 0x28, 0x79, 0x14, 0x61, 0x87, 0xdd, 0x26, 0x66, 0xad, 0xa7, 0x81, 0xbb, 0x7f, 0x11, 0x13, 0x72, 0x25, 0x1a, 0x89, 0x10, 0x62, 0x1f, 0x63, 0x4d, 0xf1, 0x28, 0xac, 0x48, 0xe3, 0x81, 0xfd, 0x6e, 0xf9, 0x06, 0x07, 0x31, 0xf6, 0x94, 0xa4, 0x41, 0x04, 0x1d, 0xd0, 0xbd, 0x5d, 0x45, 0x66, 0xc9, 0xbe, 0xd9, 0xce, 0x7d, 0xe7, 0x01, 0xb5, 0xe8, 0x2e, 0x08, 0xe8, 0x4b, 0x73, 0x04, 0x66, 0x01, 0x8a, 0xb9, 0x03, 0xc7, 0x9e, 0xb9, 0x82, 0x17, 0x22, 0x36, 0xc0, 0xc1, 0x72, 0x8a, 0xe4, 0xbf, 0x73, 0x61, 0x0d, 0x34, 0xde, 0x44, 0x24, 0x6e, 0xf3, 0xd9, 0xc0, 0x5a, 0x22, 0x36, 0xfb, 0x66, 0xa6, 0x58, 0x3d, 0x74, 0x49, 0x30, 0x8b, 0xab, 0xce, 0x20, 0x72, 0xfe, 0x16, 0x66, 0x29, 0x92, 0xe9, 0x23, 0x5c, 0x25, 0x00, 0x2f, 0x11, 0xb1, 0x50, 0x87, 0xb8, 0x27, 0x38, 0xe0, 0x3c, 0x94, 0x5b, 0xf7, 0xa2, 0x99, 0x5d, 0xda, 0x1e, 0x98, 0x34, 0x58, 0x41, 0x04, 0x7e, 0xa6, 0xe3, 0xa4, 0x48, 0x70, 0x37, 0xa9, 0xe0, 0xdb, 0xd7, 0x92, 0x62, 0xb2, 0xcc, 0x27, 0x3e, 0x77, 0x99, 0x30, 0xfc, 0x18, 0x40, 0x9a, 0xc5, 0x36, 0x1c, 0x5f, 0xe6, 0x69, 0xd7, 0x02, 0xe1, 0x47, 0x79, 0x0a, 0xeb, 0x4c, 0xe7, 0xfd, 0x65, 0x75, 0xab, 0x0f, 0x6c, 0x7f, 0xd1, 0xc3, 0x35, 0x93, 0x9a, 0xa8, 0x63, 0xba, 0x37, 0xec, 0x91, 0xb7, 0xe3, 0x2b, 0xb0, 0x13, 0xbb, 0x2b, 0x41, 0x04, 0xa4, 0x95, 0x58, 0xd3, 0x2e, 0xd1, 0xeb, 0xfc, 0x18, 0x16, 0xaf, 0x4f, 0xf0, 0x9b, 0x55, 0xfc, 0xb4, 0xca, 0x47, 0xb2, 0xa0, 0x2d, 0x1e, 0x7c, 0xaf, 0x11, 0x79, 0xea, 0x3f, 0xe1, 0x39, 0x5b, 0x22, 0xb8, 0x61, 0x96, 0x40, 0x16, 0xfa, 0xba, 0xf7, 0x2c, 0x97, 0x56, 0x95, 0xd9, 0x3d, 0x4d, 0xf0, 0xe5, 0x19, 0x7f, 0xe9, 0xf0, 0x40, 0x63, 0x4e, 0xd5, 0x97, 0x64, 0x93, 0x77, 0x87, 0xbe, 0x20, 0xbc, 0x4d, 0xee, 0xbb, 0xf9, 0xb8, 0xd6, 0x0a, 0x33, 0x5f, 0x04, 0x6c, 0xa3, 0xaa, 0x94, 0x1e, 0x45, 0x86, 0x4c, 0x7c, 0xad, 0xef, 0x9c, 0xf7, 0x5b, 0x3d, 0x8b, 0x01, 0x0e, 0x44, 0x3e, 0xf0};
static const u8 ecjpake_test_srv_one[] = {0x41, 0x04, 0x7e, 0xa6, 0xe3, 0xa4, 0x48, 0x70, 0x37, 0xa9, 0xe0, 0xdb, 0xd7, 0x92, 0x62, 0xb2, 0xcc, 0x27, 0x3e, 0x77, 0x99, 0x30, 0xfc, 0x18, 0x40, 0x9a, 0xc5, 0x36, 0x1c, 0x5f, 0xe6, 0x69, 0xd7, 0x02, 0xe1, 0x47, 0x79, 0x0a, 0xeb, 0x4c, 0xe7, 0xfd, 0x65, 0x75, 0xab, 0x0f, 0x6c, 0x7f, 0xd1, 0xc3, 0x35, 0x93, 0x9a, 0xa8, 0x63, 0xba, 0x37, 0xec, 0x91, 0xb7, 0xe3, 0x2b, 0xb0, 0x13, 0xbb, 0x2b, 0x41, 0x04, 0x09, 0xf8, 0x5b, 0x3d, 0x20, 0xeb, 0xd7, 0x88, 0x5c, 0xe4, 0x64, 0xc0, 0x8d, 0x05, 0x6d, 0x64, 0x28, 0xfe, 0x4d, 0xd9, 0x28, 0x7a, 0xa3, 0x65, 0xf1, 0x31, 0xf4, 0x36, 0x0f, 0xf3, 0x86, 0xd8, 0x46, 0x89, 0x8b, 0xc4, 0xb4, 0x15, 0x83, 0xc2, 0xa5, 0x19, 0x7f, 0x65, 0xd7, 0x87, 0x42, 0x74, 0x6c, 0x12, 0xa5, 0xec, 0x0a, 0x4f, 0xfe, 0x2f, 0x27, 0x0a, 0x75, 0x0a, 0x1d, 0x8f, 0xb5, 0x16, 0x20, 0x93, 0x4d, 0x74, 0xeb, 0x43, 0xe5, 0x4d, 0xf4, 0x24, 0xfd, 0x96, 0x30, 0x6c, 0x01, 0x17, 0xbf, 0x13, 0x1a, 0xfa, 0xbf, 0x90, 0xa9, 0xd3, 0x3d, 0x11, 0x98, 0xd9, 0x05, 0x19, 0x37, 0x35, 0x14, 0x41, 0x04, 0x19, 0x0a, 0x07, 0x70, 0x0f, 0xfa, 0x4b, 0xe6, 0xae, 0x1d, 0x79, 0xee, 0x0f, 0x06, 0xae, 0xb5, 0x44, 0xcd, 0x5a, 0xdd, 0xaa, 0xbe, 0xdf, 0x70, 0xf8, 0x62, 0x33, 0x21, 0x33, 0x2c, 0x54, 0xf3, 0x55, 0xf0, 0xfb, 0xfe, 0xc7, 0x83, 0xed, 0x35, 0x9e, 0x5d, 0x0b, 0xf7, 0x37, 0x7a, 0x0f, 0xc4, 0xea, 0x7a, 0xce, 0x47, 0x3c, 0x9c, 0x11, 0x2b, 0x41, 0xcc, 0xd4, 0x1a, 0xc5, 0x6a, 0x56, 0x12, 0x41, 0x04, 0x36, 0x0a, 0x1c, 0xea, 0x33, 0xfc, 0xe6, 0x41, 0x15, 0x64, 0x58, 0xe0, 0xa4, 0xea, 0xc2, 0x19, 0xe9, 0x68, 0x31, 0xe6, 0xae, 0xbc, 0x88, 0xb3, 0xf3, 0x75, 0x2f, 0x93, 0xa0, 0x28, 0x1d, 0x1b, 0xf1, 0xfb, 0x10, 0x60, 0x51, 0xdb, 0x96, 0x94, 0xa8, 0xd6, 0xe8, 0x62, 0xa5, 0xef, 0x13, 0x24, 0xa3, 0xd9, 0xe2, 0x78, 0x94, 0xf1, 0xee, 0x4f, 0x7c, 0x59, 0x19, 0x99, 0x65, 0xa8, 0xdd, 0x4a, 0x20, 0x91, 0x84, 0x7d, 0x2d, 0x22, 0xdf, 0x3e, 0xe5, 0x5f, 0xaa, 0x2a, 0x3f, 0xb3, 0x3f, 0xd2, 0xd1, 0xe0, 0x55, 0xa0, 0x7a, 0x7c, 0x61, 0xec, 0xfb, 0x8d, 0x80, 0xec, 0x00, 0xc2, 0xc9, 0xeb, 0x12};
static const u8 ecjpake_test_srv_two[] = {0x03, 0x00, 0x17, 0x41, 0x04, 0x0f, 0xb2, 0x2b, 0x1d, 0x5d, 0x11, 0x23, 0xe0, 0xef, 0x9f, 0xeb, 0x9d, 0x8a, 0x2e, 0x59, 0x0a, 0x1f, 0x4d, 0x7c, 0xed, 0x2c, 0x2b, 0x06, 0x58, 0x6e, 0x8f, 0x2a, 0x16, 0xd4, 0xeb, 0x2f, 0xda, 0x43, 0x28, 0xa2, 0x0b, 0x07, 0xd8, 0xfd, 0x66, 0x76, 0x54, 0xca, 0x18, 0xc5, 0x4e, 0x32, 0xa3, 0x33, 0xa0, 0x84, 0x54, 0x51, 0xe9, 0x26, 0xee, 0x88, 0x04, 0xfd, 0x7a, 0xf0, 0xaa, 0xa7, 0xa6, 0x41, 0x04, 0x55, 0x16, 0xea, 0x3e, 0x54, 0xa0, 0xd5, 0xd8, 0xb2, 0xce, 0x78, 0x6b, 0x38, 0xd3, 0x83, 0x37, 0x00, 0x29, 0xa5, 0xdb, 0xe4, 0x45, 0x9c, 0x9d, 0xd6, 0x01, 0xb4, 0x08, 0xa2, 0x4a, 0xe6, 0x46, 0x5c, 0x8a, 0xc9, 0x05, 0xb9, 0xeb, 0x03, 0xb5, 0xd3, 0x69, 0x1c, 0x13, 0x9e, 0xf8, 0x3f, 0x1c, 0xd4, 0x20, 0x0f, 0x6c, 0x9c, 0xd4, 0xec, 0x39, 0x22, 0x18, 0xa5, 0x9e, 0xd2, 0x43, 0xd3, 0xc8, 0x20, 0xff, 0x72, 0x4a, 0x9a, 0x70, 0xb8, 0x8c, 0xb8, 0x6f, 0x20, 0xb4, 0x34, 0xc6, 0x86, 0x5a, 0xa1, 0xcd, 0x79, 0x06, 0xdd, 0x7c, 0x9b, 0xce, 0x35, 0x25, 0xf5, 0x08, 0x27, 0x6f, 0x26, 0x83, 0x6c};
static const u8 ecjpake_test_cli_two[] = {0x41, 0x04, 0x69, 0xd5, 0x4e, 0xe8, 0x5e, 0x90, 0xce, 0x3f, 0x12, 0x46, 0x74, 0x2d, 0xe5, 0x07, 0xe9, 0x39, 0xe8, 0x1d, 0x1d, 0xc1, 0xc5, 0xcb, 0x98, 0x8b, 0x58, 0xc3, 0x10, 0xc9, 0xfd, 0xd9, 0x52, 0x4d, 0x93, 0x72, 0x0b, 0x45, 0x54, 0x1c, 0x83, 0xee, 0x88, 0x41, 0x19, 0x1d, 0xa7, 0xce, 0xd8, 0x6e, 0x33, 0x12, 0xd4, 0x36, 0x23, 0xc1, 0xd6, 0x3e, 0x74, 0x98, 0x9a, 0xba, 0x4a, 0xff, 0xd1, 0xee, 0x41, 0x04, 0x07, 0x7e, 0x8c, 0x31, 0xe2, 0x0e, 0x6b, 0xed, 0xb7, 0x60, 0xc1, 0x35, 0x93, 0xe6, 0x9f, 0x15, 0xbe, 0x85, 0xc2, 0x7d, 0x68, 0xcd, 0x09, 0xcc, 0xb8, 0xc4, 0x18, 0x36, 0x08, 0x91, 0x7c, 0x5c, 0x3d, 0x40, 0x9f, 0xac, 0x39, 0xfe, 0xfe, 0xe8, 0x2f, 0x72, 0x92, 0xd3, 0x6f, 0x0d, 0x23, 0xe0, 0x55, 0x91, 0x3f, 0x45, 0xa5, 0x2b, 0x85, 0xdd, 0x8a, 0x20, 0x52, 0xe9, 0xe1, 0x29, 0xbb, 0x4d, 0x20, 0x0f, 0x01, 0x1f, 0x19, 0x48, 0x35, 0x35, 0xa6, 0xe8, 0x9a, 0x58, 0x0c, 0x9b, 0x00, 0x03, 0xba, 0xf2, 0x14, 0x62, 0xec, 0xe9, 0x1a, 0x82, 0xcc, 0x38, 0xdb, 0xdc, 0xae, 0x60, 0xd9, 0xc5, 0x4c};
static const u8 ecjpake_test_pms[] = {0xf3, 0xd4, 0x7f, 0x59, 0x98, 0x44, 0xdb, 0x92, 0xa5, 0x69, 0xbb, 0xe7, 0x98, 0x1e, 0x39, 0xd9, 0x31, 0xfd, 0x74, 0x3b, 0xf2, 0x2e, 0x98, 0xf9, 0xb4, 0x38, 0xf7, 0x19, 0xd3, 0xc4, 0xf3, 0x51};
fn ecjpake_test_load(mbedtls_ecjpake_context * ctx, const u8 * xm1, usize len1, const u8 * xm2, usize len2) -> i32
{
	i32 ret;
	do
	{
		if (ret = mbedtls_mpi_read_binary(&ctx.xm1, xm1, len1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_read_binary(&ctx.xm2, xm2, len2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(&ctx.grp, &ctx.Xm1, &ctx.xm1, &ctx.grp.G, NULL, NULL)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(&ctx.grp, &ctx.Xm2, &ctx.xm2, &ctx.grp.G, NULL, NULL)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecjpake_lgc(void * p, u8 * out, usize len) -> i32
{
	static u32 x = 42;
	(void) p;
	while (len > 0)
	{
		usize use_len = len > 4 ? 4 : len;
		x = 1664525 * x + 1013904223;
		memcpy(out, &x, use_len);
		out += use_len;
		len -= use_len;
	}
	return 0;
}

pub fn mbedtls_ecjpake_self_test(i32 verbose) -> i32
{
	i32 ret;
	mbedtls_ecjpake_context cli;
	mbedtls_ecjpake_context srv;
	u8 buf[512], pms[32];
	usize len, pmslen;
	mbedtls_ecjpake_init(&cli);
	mbedtls_ecjpake_init(&srv);
	if verbose != 0
	{
		printf("  ECJPAKE test #0 (setup): ");
	}
	do
	{
		if mbedtls_ecjpake_setup(&cli, MBEDTLS_ECJPAKE_CLIENT, MBEDTLS_MD_SHA256, MBEDTLS_ECP_DP_SECP256R1, ecjpake_test_password, sizeof(ecjpake_test_password)) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_setup(&srv, MBEDTLS_ECJPAKE_SERVER, MBEDTLS_MD_SHA256, MBEDTLS_ECP_DP_SECP256R1, ecjpake_test_password, sizeof(ecjpake_test_password)) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  ECJPAKE test #1 (random handshake): ");
	}
	do
	{
		if mbedtls_ecjpake_write_round_one(&cli, buf, sizeof(buf), &len, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_one(&srv, buf, len) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_write_round_one(&srv, buf, sizeof(buf), &len, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_one(&cli, buf, len) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_write_round_two(&srv, buf, sizeof(buf), &len, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_two(&cli, buf, len) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_derive_secret(&cli, pms, sizeof(pms), &pmslen, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_write_round_two(&cli, buf, sizeof(buf), &len, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_two(&srv, buf, len) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_derive_secret(&srv, buf, sizeof(buf), &len, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if len == pmslen
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if memcmp(buf, pms, len) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  ECJPAKE test #2 (reference handshake): ");
	}
	do
	{
		if (ret = ecjpake_test_load(&cli, ecjpake_test_x1, sizeof(ecjpake_test_x1), ecjpake_test_x2, sizeof(ecjpake_test_x2))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecjpake_test_load(&srv, ecjpake_test_x3, sizeof(ecjpake_test_x3), ecjpake_test_x4, sizeof(ecjpake_test_x4))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_one(&srv, ecjpake_test_cli_one, sizeof(ecjpake_test_cli_one)) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_one(&cli, ecjpake_test_srv_one, sizeof(ecjpake_test_srv_one)) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_two(&cli, ecjpake_test_srv_two, sizeof(ecjpake_test_srv_two)) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_read_round_two(&srv, ecjpake_test_cli_two, sizeof(ecjpake_test_cli_two)) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if mbedtls_ecjpake_derive_secret(&srv, buf, sizeof(buf), &len, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if len == sizeof(ecjpake_test_pms)
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if memcmp(buf, ecjpake_test_pms, len) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	memset(buf, 0, len);
	do
	{
		if mbedtls_ecjpake_derive_secret(&cli, buf, sizeof(buf), &len, ecjpake_lgc, NULL) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if len == sizeof(ecjpake_test_pms)
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if memcmp(buf, ecjpake_test_pms, len) == 0
		{
			ret = 0;
		}
		else
		{
			ret = 1;
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("passed\n");
	}
cleanup:
	mbedtls_ecjpake_free(&cli);
	mbedtls_ecjpake_free(&srv);
	if ret != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
	}
	if verbose != 0
	{
		printf("\n");
	}
	return ret;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

static u32 add_count, dbl_count, mul_count;
typedef enum
{
	ECP_TYPE_NONE = 0,
	ECP_TYPE_SHORT_WEIERSTRASS,
	ECP_TYPE_MONTGOMERY,
} ecp_curve_type;
static const mbedtls_ecp_curve_info ecp_supported_curves[] =
{
	{MBEDTLS_ECP_DP_SECP521R1, 25, 521, "secp521r1"}, {MBEDTLS_ECP_DP_BP512R1, 28, 512, "brainpoolP512r1"}, {MBEDTLS_ECP_DP_SECP384R1, 24, 384, "secp384r1"}, {MBEDTLS_ECP_DP_BP384R1, 27, 384, "brainpoolP384r1"}, {MBEDTLS_ECP_DP_SECP256R1, 23, 256, "secp256r1"}, {MBEDTLS_ECP_DP_SECP256K1, 22, 256, "secp256k1"}, {MBEDTLS_ECP_DP_BP256R1, 26, 256, "brainpoolP256r1"}, {MBEDTLS_ECP_DP_SECP224R1, 21, 224, "secp224r1"}, {MBEDTLS_ECP_DP_SECP224K1, 20, 224, "secp224k1"}, {MBEDTLS_ECP_DP_SECP192R1, 19, 192, "secp192r1"}, {MBEDTLS_ECP_DP_SECP192K1, 18, 192, "secp192k1"}, {MBEDTLS_ECP_DP_NONE, 0, 0, NULL},
};
static mbedtls_ecp_group_id ecp_supported_grp_id[sizeof(ecp_supported_curves) / sizeof(ecp_supported_curves[0])];
pub fn mbedtls_ecp_curve_info * mbedtls_ecp_curve_list() -> const
{
	return ecp_supported_curves;
}

pub fn mbedtls_ecp_group_id * mbedtls_ecp_grp_id_list() -> const
{
	static i32 init_done = 0;
	if !init_done
	{
		usize i = 0;
		const mbedtls_ecp_curve_info * curve_info;
		for (curve_info = mbedtls_ecp_curve_list(); curve_info.grp_id != MBEDTLS_ECP_DP_NONE; curve_info++)
		{
			ecp_supported_grp_id[i++] = curve_info.grp_id;
		}
		ecp_supported_grp_id[i] = MBEDTLS_ECP_DP_NONE;
		init_done = 1;
	}
	return ecp_supported_grp_id;
}

pub fn mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_grp_id(mbedtls_ecp_group_id grp_id) -> const
{
	const mbedtls_ecp_curve_info * curve_info;
	for (curve_info = mbedtls_ecp_curve_list(); curve_info.grp_id != MBEDTLS_ECP_DP_NONE; curve_info++)
	{
		if curve_info.grp_id == grp_id
		{
			return curve_info;
		}
	}
	return NULL;
}

pub fn mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_tls_id(u16 tls_id) -> const
{
	const mbedtls_ecp_curve_info * curve_info;
	for (curve_info = mbedtls_ecp_curve_list(); curve_info.grp_id != MBEDTLS_ECP_DP_NONE; curve_info++)
	{
		if curve_info.tls_id == tls_id
		{
			return curve_info;
		}
	}
	return NULL;
}

pub fn mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_name(const i8 * name) -> const
{
	const mbedtls_ecp_curve_info * curve_info;
	for (curve_info = mbedtls_ecp_curve_list(); curve_info.grp_id != MBEDTLS_ECP_DP_NONE; curve_info++)
	{
		if strcmp(curve_info.name, name) == 0
		{
			return curve_info;
		}
	}
	return NULL;
}

fn ecp_curve_type ecp_get_type(const mbedtls_ecp_group * grp) -> inline
{
	if grp.G.X.p == NULL
	{
		return ECP_TYPE_NONE;
	}
	if grp.G.Y.p == NULL
	{
		return ECP_TYPE_MONTGOMERY;
	}
	else
	{
		return ECP_TYPE_SHORT_WEIERSTRASS;
	}
}

pub fn mbedtls_ecp_point_init(mbedtls_ecp_poi32 * pt)
{
	if pt == NULL
	{
		return;
	}
	mbedtls_mpi_init(&pt.X);
	mbedtls_mpi_init(&pt.Y);
	mbedtls_mpi_init(&pt.Z);
}

pub fn mbedtls_ecp_group_init(mbedtls_ecp_group * grp)
{
	if grp == NULL
	{
		return;
	}
	memset(grp, 0, sizeof(mbedtls_ecp_group));
}

pub fn mbedtls_ecp_keypair_init(mbedtls_ecp_keypair * key)
{
	if key == NULL
	{
		return;
	}
	mbedtls_ecp_group_init(&key.grp);
	mbedtls_mpi_init(&key.d);
	mbedtls_ecp_point_init(&key.Q);
}

pub fn mbedtls_ecp_point_free(mbedtls_ecp_poi32 * pt)
{
	if pt == NULL
	{
		return;
	}
	mbedtls_mpi_free(&(pt.X));
	mbedtls_mpi_free(&(pt.Y));
	mbedtls_mpi_free(&(pt.Z));
}

pub fn mbedtls_ecp_group_free(mbedtls_ecp_group * grp)
{
	usize i;
	if grp == NULL
	{
		return;
	}
	if grp.h != 1
	{
		mbedtls_mpi_free(&grp.P);
		mbedtls_mpi_free(&grp.A);
		mbedtls_mpi_free(&grp.B);
		mbedtls_ecp_point_free(&grp.G);
		mbedtls_mpi_free(&grp.N);
	}
	if grp.T != NULL
	{
		for (i = 0; i < grp.T_size; i++)
		{
			mbedtls_ecp_point_free(&grp.T[i]);
		}
		mbedtls_free(grp.T);
	}
	zeroize(grp, sizeof(mbedtls_ecp_group));
}

pub fn mbedtls_ecp_keypair_free(mbedtls_ecp_keypair * key)
{
	if key == NULL
	{
		return;
	}
	mbedtls_ecp_group_free(&key.grp);
	mbedtls_mpi_free(&key.d);
	mbedtls_ecp_point_free(&key.Q);
}

pub fn mbedtls_ecp_copy(mbedtls_ecp_poi32 * P, const mbedtls_ecp_poi32 * Q) -> i32
{
	i32 ret;
	do
	{
		if (ret = mbedtls_mpi_copy(&P.X, &Q.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&P.Y, &Q.Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&P.Z, &Q.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

pub fn mbedtls_ecp_group_copy(mbedtls_ecp_group * dst, const mbedtls_ecp_group * src) -> i32
{
	return mbedtls_ecp_group_load(dst, src.id);
}

pub fn mbedtls_ecp_set_zero(mbedtls_ecp_poi32 * pt) -> i32
{
	i32 ret;
	do
	{
		if (ret = mbedtls_mpi_lset(&pt.X, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&pt.Y, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&pt.Z, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

pub fn mbedtls_ecp_is_zero(mbedtls_ecp_poi32 * pt) -> i32
{
	return mbedtls_mpi_cmp_int(&pt.Z, 0) == 0;
}

pub fn mbedtls_ecp_point_cmp(const mbedtls_ecp_poi32 * P, const mbedtls_ecp_poi32 * Q) -> i32
{
	if mbedtls_mpi_cmp_mpi(&P.X, &Q.X) == 0 && mbedtls_mpi_cmp_mpi(&P.Y, &Q.Y) == 0 && mbedtls_mpi_cmp_mpi(&P.Z, &Q.Z) == 0
	{
		return 0;
	}
	return -0x4F80;
}

pub fn mbedtls_ecp_point_read_string(mbedtls_ecp_poi32 * P, i32 radix, const i8 * x, const i8 * y) -> i32
{
	i32 ret;
	do
	{
		if (ret = mbedtls_mpi_read_string(&P.X, radix, x)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_read_string(&P.Y, radix, y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&P.Z, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

pub fn mbedtls_ecp_point_write_binary(const mbedtls_ecp_group * grp, const mbedtls_ecp_poi32 * P, i32 format, usize * olen, u8 * buf, usize buflen) -> i32
{
	i32 ret = 0;
	usize plen;
	if format != 0 && format != 1
	{
		return -0x4F80;
	}
	if mbedtls_mpi_cmp_int(&P.Z, 0) == 0
	{
		if buflen < 1
		{
			return -0x4F00;
		}
		buf[0] = 0x00;
		*olen = 1;
		return 0;
	}
	plen = mbedtls_mpi_size(&grp.P);
	if format == 0
	{
		*olen = 2 * plen + 1;
		if buflen < *olen
		{
			return -0x4F00;
		}
		buf[0] = 0x04;
		do
		{
			if (ret = mbedtls_mpi_write_binary(&P.X, buf + 1, plen)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_write_binary(&P.Y, buf + 1 + plen, plen)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	else
		if format == 1
		{
			*olen = plen + 1;
			if buflen < *olen
			{
				return -0x4F00;
			}
			buf[0] = 0x02 + mbedtls_mpi_get_bit(&P.Y, 0);
			do
			{
				if (ret = mbedtls_mpi_write_binary(&P.X, buf + 1, plen)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
cleanup:
	return ret;
}

pub fn mbedtls_ecp_point_read_binary(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * pt, const u8 * buf, usize ilen) -> i32
{
	i32 ret;
	usize plen;
	if ilen < 1
	{
		return -0x4F80;
	}
	if buf[0] == 0x00
	{
		if ilen == 1
		{
			return mbedtls_ecp_set_zero(pt);
		}
		else
		{
			return -0x4F80;
		}
	}
	plen = mbedtls_mpi_size(&grp.P);
	if buf[0] != 0x04
	{
		return -0x4E80;
	}
	if ilen != 2 * plen + 1
	{
		return -0x4F80;
	}
	do
	{
		if (ret = mbedtls_mpi_read_binary(&pt.X, buf + 1, plen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_read_binary(&pt.Y, buf + 1 + plen, plen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&pt.Z, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

pub fn mbedtls_ecp_tls_read_point(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * pt, const u8 ** buf, usize buf_len) -> i32
{
	u8 data_len;
	const u8 * buf_start;
	if buf_len < 2
	{
		return -0x4F80;
	}
	data_len = *(*buf)++;
	if data_len < 1 || data_len > buf_len - 1
	{
		return -0x4F80;
	}
	buf_start = *buf;
	*buf += data_len;
	return mbedtls_ecp_point_read_binary(grp, pt, buf_start, data_len);
}

pub fn mbedtls_ecp_tls_write_point(const mbedtls_ecp_group * grp, const mbedtls_ecp_poi32 * pt, i32 format, usize * olen, u8 * buf, usize blen) -> i32
{
	i32 ret;
	if blen < 1
	{
		return -0x4F80;
	}
	if (ret = mbedtls_ecp_point_write_binary(grp, pt, format, olen, buf + 1, blen - 1)) != 0
	{
		return ret;
	}
	buf[0] = (i8) *olen;
	++*olen;
	return 0;
}

pub fn mbedtls_ecp_tls_read_group(mbedtls_ecp_group * grp, const u8 ** buf, usize len) -> i32
{
	u16 tls_id;
	const mbedtls_ecp_curve_info * curve_info;
	if len < 3
	{
		return -0x4F80;
	}
	if *(*buf)++ != 3
	{
		return -0x4F80;
	}
	tls_id = *(*buf)++;
	tls_id <<= 8;
	tls_id |= *(*buf)++;
	if (curve_info = mbedtls_ecp_curve_info_from_tls_id(tls_id)) == NULL
	{
		return -0x4E80;
	}
	return mbedtls_ecp_group_load(grp, curve_info.grp_id);
}

pub fn mbedtls_ecp_tls_write_group(const mbedtls_ecp_group * grp, usize * olen, u8 * buf, usize blen) -> i32
{
	const mbedtls_ecp_curve_info * curve_info;
	if (curve_info = mbedtls_ecp_curve_info_from_grp_id(grp.id)) == NULL
	{
		return -0x4F80;
	}
	*olen = 3;
	if blen < *olen
	{
		return -0x4F00;
	}
	*buf++ = 3;
	buf[0] = curve_info.tls_id >> 8;
	buf[1] = curve_info.tls_id & 0xFF;
	return 0;
}

fn ecp_modp(mbedtls_mpi * N, const mbedtls_ecp_group * grp) -> i32
{
	i32 ret;
	if grp.modp == NULL
	{
		return mbedtls_mpi_mod_mpi(N, N, &grp.P);
	}
	if (N.s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) || mbedtls_mpi_bitlen(N) > 2 * grp.pbits
	{
		return -0x4F80;
	}
	do
	{
		if (ret = grp.modp(N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (N.s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(N, N, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	while (mbedtls_mpi_cmp_mpi(N, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(N, N, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
cleanup:
	return ret;
}

fn ecp_normalize_jac(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * pt) -> i32
{
	i32 ret;
	mbedtls_mpi Zi, ZZi;
	if mbedtls_mpi_cmp_int(&pt.Z, 0) == 0
	{
		return 0;
	}
	mbedtls_mpi_init(&Zi);
	mbedtls_mpi_init(&ZZi);
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&Zi, &pt.Z, &grp.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&ZZi, &Zi, &Zi)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&ZZi, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&pt.X, &pt.X, &ZZi)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&pt.X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&pt.Y, &pt.Y, &ZZi)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&pt.Y, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&pt.Y, &pt.Y, &Zi)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&pt.Y, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&pt.Z, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&Zi);
	mbedtls_mpi_free(&ZZi);
	return ret;
}

fn ecp_normalize_jac_many(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * T[], usize t_len) -> i32
{
	i32 ret;
	usize i;
	mbedtls_mpi *c, u, Zi, ZZi;
	if t_len < 2
	{
		return ecp_normalize_jac(grp, *T);
	}
	if (c = mbedtls_calloc(t_len, sizeof(mbedtls_mpi))) == NULL
	{
		return -0x4D80;
	}
	mbedtls_mpi_init(&u);
	mbedtls_mpi_init(&Zi);
	mbedtls_mpi_init(&ZZi);
	do
	{
		if (ret = mbedtls_mpi_copy(&c[0], &T[0]->Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i = 1; i < t_len; i++)
	{
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&c[i], &c[i - 1], &T[i]->Z)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&c[i], grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&u, &c[t_len - 1], &grp.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i = t_len - 1;; i--)
	{
		if i == 0
		{
			do
			{
				if (ret = mbedtls_mpi_copy(&Zi, &u)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		else
		{
			do
			{
				if (ret = mbedtls_mpi_mul_mpi(&Zi, &u, &c[i - 1])) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				do
				{
					if (ret = ecp_modp(&Zi, grp)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				mul_count++;
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_mul_mpi(&u, &u, &T[i]->Z)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				do
				{
					if (ret = ecp_modp(&u, grp)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				mul_count++;
			}
			while (0);
		}
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&ZZi, &Zi, &Zi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&ZZi, grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&T[i]->X, &T[i]->X, &ZZi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&T[i]->X, grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&T[i]->Y, &T[i]->Y, &ZZi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&T[i]->Y, grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&T[i]->Y, &T[i]->Y, &Zi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&T[i]->Y, grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_shrink(&T[i]->X, grp.P.n)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_shrink(&T[i]->Y, grp.P.n)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mbedtls_mpi_free(&T[i]->Z);
		if i == 0
		{
			break;

		}
	}
cleanup:
	mbedtls_mpi_free(&u);
	mbedtls_mpi_free(&Zi);
	mbedtls_mpi_free(&ZZi);
	for (i = 0; i < t_len; i++)
	{
		mbedtls_mpi_free(&c[i]);
	}
	mbedtls_free(c);
	return ret;
}

fn ecp_safe_invert_jac(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * Q, u8 inv) -> i32
{
	i32 ret;
	u8 nonzero;
	mbedtls_mpi mQY;
	mbedtls_mpi_init(&mQY);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&mQY, &grp.P, &Q.Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	nonzero = mbedtls_mpi_cmp_int(&Q.Y, 0) != 0;
	do
	{
		if (ret = mbedtls_mpi_safe_cond_assign(&Q.Y, &mQY, inv & nonzero)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&mQY);
	return ret;
}

fn ecp_double_jac(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_ecp_poi32 * P) -> i32
{
	i32 ret;
	mbedtls_mpi M, S, T, U;
	dbl_count++;
	mbedtls_mpi_init(&M);
	mbedtls_mpi_init(&S);
	mbedtls_mpi_init(&T);
	mbedtls_mpi_init(&U);
	if grp.A.p == NULL
	{
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&S, &P.Z, &P.Z)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&S, grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&T, &P.X, &S)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		while (mbedtls_mpi_cmp_mpi(&T, &grp.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_sub_abs(&T, &T, &grp.P)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		do
		{
			if (ret = mbedtls_mpi_sub_mpi(&U, &P.X, &S)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		while (U.s < 0 && mbedtls_mpi_cmp_int(&U, 0) != 0)
			do
			{
				if (ret = mbedtls_mpi_add_mpi(&U, &U, &grp.P)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&S, &T, &U)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&S, grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_int(&M, &S, 3)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		while (mbedtls_mpi_cmp_mpi(&M, &grp.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_sub_abs(&M, &M, &grp.P)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
	}
	else
	{
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&S, &P.X, &P.X)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			do
			{
				if (ret = ecp_modp(&S, grp)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			mul_count++;
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_int(&M, &S, 3)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		while (mbedtls_mpi_cmp_mpi(&M, &grp.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_sub_abs(&M, &M, &grp.P)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		if mbedtls_mpi_cmp_int(&grp.A, 0) != 0
		{
			do
			{
				if (ret = mbedtls_mpi_mul_mpi(&S, &P.Z, &P.Z)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				do
				{
					if (ret = ecp_modp(&S, grp)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				mul_count++;
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_mul_mpi(&T, &S, &S)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				do
				{
					if (ret = ecp_modp(&T, grp)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				mul_count++;
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_mul_mpi(&S, &T, &grp.A)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			do
			{
				do
				{
					if (ret = ecp_modp(&S, grp)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				mul_count++;
			}
			while (0);
			do
			{
				if (ret = mbedtls_mpi_add_mpi(&M, &M, &S)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			while (mbedtls_mpi_cmp_mpi(&M, &grp.P) >= 0)
				do
				{
					if (ret = mbedtls_mpi_sub_abs(&M, &M, &grp.P)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
		}
	}
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T, &P.Y, &P.Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_shift_l(&T, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&T, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&T, &T, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&S, &P.X, &T)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&S, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_shift_l(&S, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&S, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&S, &S, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&U, &T, &T)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&U, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_shift_l(&U, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&U, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&U, &U, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T, &M, &M)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&T, &T, &S)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (T.s < 0 && mbedtls_mpi_cmp_int(&T, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&T, &T, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&T, &T, &S)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (T.s < 0 && mbedtls_mpi_cmp_int(&T, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&T, &T, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&S, &S, &T)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (S.s < 0 && mbedtls_mpi_cmp_int(&S, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&S, &S, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&S, &S, &M)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&S, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&S, &S, &U)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (S.s < 0 && mbedtls_mpi_cmp_int(&S, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&S, &S, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&U, &P.Y, &P.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&U, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_shift_l(&U, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&U, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&U, &U, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&R.X, &T)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&R.Y, &S)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&R.Z, &U)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&M);
	mbedtls_mpi_free(&S);
	mbedtls_mpi_free(&T);
	mbedtls_mpi_free(&U);
	return ret;
}

fn ecp_add_mixed(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_ecp_poi32 * P, const mbedtls_ecp_poi32 * Q) -> i32
{
	i32 ret;
	mbedtls_mpi T1, T2, T3, T4, X, Y, Z;
	add_count++;
	if mbedtls_mpi_cmp_int(&P.Z, 0) == 0
	{
		return mbedtls_ecp_copy(R, Q);
	}
	if Q.Z.p != NULL && mbedtls_mpi_cmp_int(&Q.Z, 0) == 0
	{
		return mbedtls_ecp_copy(R, P);
	}
	if Q.Z.p != NULL && mbedtls_mpi_cmp_int(&Q.Z, 1) != 0
	{
		return -0x4F80;
	}
	mbedtls_mpi_init(&T1);
	mbedtls_mpi_init(&T2);
	mbedtls_mpi_init(&T3);
	mbedtls_mpi_init(&T4);
	mbedtls_mpi_init(&X);
	mbedtls_mpi_init(&Y);
	mbedtls_mpi_init(&Z);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T1, &P.Z, &P.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T1, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T2, &T1, &P.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T2, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T1, &T1, &Q.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T1, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T2, &T2, &Q.Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T2, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&T1, &T1, &P.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (T1.s < 0 && mbedtls_mpi_cmp_int(&T1, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&T1, &T1, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&T2, &T2, &P.Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (T2.s < 0 && mbedtls_mpi_cmp_int(&T2, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&T2, &T2, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	if mbedtls_mpi_cmp_int(&T1, 0) == 0
	{
		if mbedtls_mpi_cmp_int(&T2, 0) == 0
		{
			ret = ecp_double_jac(grp, R, P);
			goto cleanup;
		}
		else
		{
			ret = mbedtls_ecp_set_zero(R);
			goto cleanup;
		}
	}
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&Z, &P.Z, &T1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&Z, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T3, &T1, &T1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T3, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T4, &T3, &T1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T4, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T3, &T3, &P.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T3, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_int(&T1, &T3, 2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&T1, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&T1, &T1, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&X, &T2, &T2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&X, &X, &T1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (X.s < 0 && mbedtls_mpi_cmp_int(&X, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&X, &X, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&X, &X, &T4)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (X.s < 0 && mbedtls_mpi_cmp_int(&X, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&X, &X, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&T3, &T3, &X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (T3.s < 0 && mbedtls_mpi_cmp_int(&T3, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&T3, &T3, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T3, &T3, &T2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T3, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T4, &T4, &P.Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&T4, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&Y, &T3, &T4)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (Y.s < 0 && mbedtls_mpi_cmp_int(&Y, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&Y, &Y, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&R.X, &X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&R.Y, &Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&R.Z, &Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&T1);
	mbedtls_mpi_free(&T2);
	mbedtls_mpi_free(&T3);
	mbedtls_mpi_free(&T4);
	mbedtls_mpi_free(&X);
	mbedtls_mpi_free(&Y);
	mbedtls_mpi_free(&Z);
	return ret;
}

fn ecp_randomize_jac(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * pt, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_mpi l, ll;
	usize p_size = (grp.pbits + 7) / 8;
	i32 count = 0;
	mbedtls_mpi_init(&l);
	mbedtls_mpi_init(&ll);
	do
	{
		mbedtls_mpi_fill_random(&l, p_size, f_rng, p_rng);
		while (mbedtls_mpi_cmp_mpi(&l, &grp.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_shift_r(&l, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		if count++ > 10
		{
			return -0x4D00;
		}
	}
	while (mbedtls_mpi_cmp_int(&l, 1) <= 0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&pt.Z, &pt.Z, &l)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&pt.Z, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&ll, &l, &l)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&ll, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&pt.X, &pt.X, &ll)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&pt.X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&ll, &ll, &l)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&ll, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&pt.Y, &pt.Y, &ll)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&pt.Y, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&l);
	mbedtls_mpi_free(&ll);
	return ret;
}

fn ecp_comb_fixed(u8 x[], usize d, u8 w, const mbedtls_mpi * m)
{
	usize i, j;
	u8 c, cc, adjust;
	memset(x, 0, d + 1);
	for (i = 0; i < d; i++)
		for (j = 0; j < w; j++)
		{
			x[i] |= mbedtls_mpi_get_bit(m, i + d * j) << j;
		}
	c = 0;
	for (i = 1; i <= d; i++)
	{
		cc = x[i] & c;
		x[i] = x[i] ^ c;
		c = cc;
		adjust = 1 - (x[i] & 0x01);
		c |= x[i] & (x[i - 1] * adjust);
		x[i] = x[i] ^ (x[i - 1] * adjust);
		x[i - 1] |= adjust << 7;
	}
}

fn ecp_precompute_comb(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 T[], const mbedtls_ecp_poi32 * P, u8 w, usize d) -> i32
{
	i32 ret;
	u8 i, k;
	usize j;
	mbedtls_ecp_poi32 *cur, *TT[(1 << (6 - 1)) - 1];
	do
	{
		if (ret = mbedtls_ecp_copy(&T[0], P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	k = 0;
	for (i = 1; i < (1U << (w - 1)); i <<= 1)
	{
		cur = T + i;
		do
		{
			if (ret = mbedtls_ecp_copy(cur, T + (i >> 1))) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		for (j = 0; j < d; j++)
			do
			{
				if (ret = ecp_double_jac(grp, cur, cur)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		TT[k++] = cur;
	}
	do
	{
		if (ret = ecp_normalize_jac_many(grp, TT, k)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	k = 0;
	for (i = 1; i < (1U << (w - 1)); i <<= 1)
	{
		j = i;
		while (j--)
		{
			do
			{
				if (ret = ecp_add_mixed(grp, &T[i + j], &T[j], &T[i])) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			TT[k++] = &T[i + j];
		}
	}
	do
	{
		if (ret = ecp_normalize_jac_many(grp, TT, k)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecp_select_comb(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_ecp_poi32 T[], u8 t_len, u8 i) -> i32
{
	i32 ret;
	u8 ii, j;
	ii = (i & 0x7Fu) >> 1;
	for (j = 0; j < t_len; j++)
	{
		do
		{
			if (ret = mbedtls_mpi_safe_cond_assign(&R.X, &T[j].X, j == ii)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_safe_cond_assign(&R.Y, &T[j].Y, j == ii)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	do
	{
		if (ret = ecp_safe_invert_jac(grp, R, i >> 7)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecp_mul_comb_core(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_ecp_poi32 T[], u8 t_len, const u8 x[], usize d, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 Txi;
	usize i;
	mbedtls_ecp_point_init(&Txi);
	i = d;
	do
	{
		if (ret = ecp_select_comb(grp, R, T, t_len, x[i])) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&R.Z, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if f_rng != 0
		do
		{
			if (ret = ecp_randomize_jac(grp, R, f_rng, p_rng)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	while (i-- != 0)
	{
		do
		{
			if (ret = ecp_double_jac(grp, R, R)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = ecp_select_comb(grp, &Txi, T, t_len, x[i])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = ecp_add_mixed(grp, R, R, &Txi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
cleanup:
	mbedtls_ecp_point_free(&Txi);
	return ret;
}

fn ecp_mul_comb(mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_mpi * m, const mbedtls_ecp_poi32 * P, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	u8 w, m_is_odd, p_eq_g, pre_len, i;
	usize d;
	u8 k[(521 + 1) / 2 + 1];
	mbedtls_ecp_poi32 * T;
	mbedtls_mpi M, mm;
	mbedtls_mpi_init(&M);
	mbedtls_mpi_init(&mm);
	if mbedtls_mpi_get_bit(&grp.N, 0) != 1
	{
		return -0x4F80;
	}
	w = grp.nbits >= 384 ? 5 : 4;
	p_eq_g = (mbedtls_mpi_cmp_mpi(&P.Y, &grp.G.Y) == 0 && mbedtls_mpi_cmp_mpi(&P.X, &grp.G.X) == 0);
	if p_eq_g
	{
		w++;
	}
	if w > 6
	{
		w = 6;
	}
	if w >= grp.nbits
	{
		w = 2;
	}
	pre_len = 1U << (w - 1);
	d = (grp.nbits + w - 1) / w;
	T = p_eq_g ? grp.T : NULL;
	if T == NULL
	{
		T = mbedtls_calloc(pre_len, sizeof(mbedtls_ecp_point));
		if T == NULL
		{
			ret = -0x4D80;
			goto cleanup;
		}
		do
		{
			if (ret = ecp_precompute_comb(grp, T, P, w, d)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if p_eq_g
		{
			grp.T = T;
			grp.T_size = pre_len;
		}
	}
	m_is_odd = (mbedtls_mpi_get_bit(m, 0) == 1);
	do
	{
		if (ret = mbedtls_mpi_copy(&M, m)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&mm, &grp.N, m)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_safe_cond_assign(&M, &mm, !m_is_odd)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	ecp_comb_fixed(k, d, w, &M);
	do
	{
		if (ret = ecp_mul_comb_core(grp, R, T, pre_len, k, d, f_rng, p_rng)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecp_safe_invert_jac(grp, R, !m_is_odd)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecp_normalize_jac(grp, R)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	if T != NULL && !p_eq_g
	{
		for (i = 0; i < pre_len; i++)
		{
			mbedtls_ecp_point_free(&T[i]);
		}
		mbedtls_free(T);
	}
	mbedtls_mpi_free(&M);
	mbedtls_mpi_free(&mm);
	if ret != 0
	{
		mbedtls_ecp_point_free(R);
	}
	return ret;
}

fn ecp_normalize_mxz(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * P) -> i32
{
	i32 ret;
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&P.Z, &P.Z, &grp.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&P.X, &P.X, &P.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&P.X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&P.Z, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecp_randomize_mxz(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * P, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_mpi l;
	usize p_size = (grp.pbits + 7) / 8;
	i32 count = 0;
	mbedtls_mpi_init(&l);
	do
	{
		mbedtls_mpi_fill_random(&l, p_size, f_rng, p_rng);
		while (mbedtls_mpi_cmp_mpi(&l, &grp.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_shift_r(&l, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		if count++ > 10
		{
			return -0x4D00;
		}
	}
	while (mbedtls_mpi_cmp_int(&l, 1) <= 0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&P.X, &P.X, &l)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&P.X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&P.Z, &P.Z, &l)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&P.Z, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&l);
	return ret;
}

fn ecp_double_add_mxz(const mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, mbedtls_ecp_poi32 * S, const mbedtls_ecp_poi32 * P, const mbedtls_ecp_poi32 * Q, const mbedtls_mpi * d) -> i32
{
	i32 ret;
	mbedtls_mpi A, AA, B, BB, E, C, D, DA, CB;
	mbedtls_mpi_init(&A);
	mbedtls_mpi_init(&AA);
	mbedtls_mpi_init(&B);
	mbedtls_mpi_init(&BB);
	mbedtls_mpi_init(&E);
	mbedtls_mpi_init(&C);
	mbedtls_mpi_init(&D);
	mbedtls_mpi_init(&DA);
	mbedtls_mpi_init(&CB);
	do
	{
		if (ret = mbedtls_mpi_add_mpi(&A, &P.X, &P.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&A, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&A, &A, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&AA, &A, &A)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&AA, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&B, &P.X, &P.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (B.s < 0 && mbedtls_mpi_cmp_int(&B, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&B, &B, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&BB, &B, &B)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&BB, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&E, &AA, &BB)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (E.s < 0 && mbedtls_mpi_cmp_int(&E, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&E, &E, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_add_mpi(&C, &Q.X, &Q.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&C, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&C, &C, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&D, &Q.X, &Q.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (D.s < 0 && mbedtls_mpi_cmp_int(&D, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&D, &D, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&DA, &D, &A)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&DA, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&CB, &C, &B)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&CB, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_mpi(&S.X, &DA, &CB)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&S.X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&S.X, &S.X, &S.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&S.X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&S.Z, &DA, &CB)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (S.Z.s < 0 && mbedtls_mpi_cmp_int(&S.Z, 0) != 0)
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&S.Z, &S.Z, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&S.Z, &S.Z, &S.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&S.Z, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&S.Z, d, &S.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&S.Z, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&R.X, &AA, &BB)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&R.X, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&R.Z, &grp.A, &E)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&R.Z, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_mpi(&R.Z, &BB, &R.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&R.Z, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&R.Z, &R.Z, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&R.Z, &E, &R.Z)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&R.Z, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
cleanup:
	mbedtls_mpi_free(&A);
	mbedtls_mpi_free(&AA);
	mbedtls_mpi_free(&B);
	mbedtls_mpi_free(&BB);
	mbedtls_mpi_free(&E);
	mbedtls_mpi_free(&C);
	mbedtls_mpi_free(&D);
	mbedtls_mpi_free(&DA);
	mbedtls_mpi_free(&CB);
	return ret;
}

fn ecp_mul_mxz(mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_mpi * m, const mbedtls_ecp_poi32 * P, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	usize i;
	u8 b;
	mbedtls_ecp_poi32 RP;
	mbedtls_mpi PX;
	mbedtls_ecp_point_init(&RP);
	mbedtls_mpi_init(&PX);
	do
	{
		if (ret = mbedtls_mpi_copy(&PX, &P.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_copy(&RP, P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&R.X, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&R.Z, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	mbedtls_mpi_free(&R.Y);
	while (mbedtls_mpi_cmp_mpi(&RP.X, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&RP.X, &RP.X, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	if f_rng != NULL
		do
		{
			if (ret = ecp_randomize_mxz(grp, &RP, f_rng, p_rng)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	i = mbedtls_mpi_bitlen(m);
	while (i-- > 0)
	{
		b = mbedtls_mpi_get_bit(m, i);
		do
		{
			if (ret = mbedtls_mpi_safe_cond_swap(&R.X, &RP.X, b)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_safe_cond_swap(&R.Z, &RP.Z, b)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = ecp_double_add_mxz(grp, R, &RP, R, &RP, &PX)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_safe_cond_swap(&R.X, &RP.X, b)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_safe_cond_swap(&R.Z, &RP.Z, b)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	do
	{
		if (ret = ecp_normalize_mxz(grp, R)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_ecp_point_free(&RP);
	mbedtls_mpi_free(&PX);
	return ret;
}

pub fn mbedtls_ecp_mul(mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_mpi * m, const mbedtls_ecp_poi32 * P, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	if mbedtls_mpi_cmp_int(&P.Z, 1) != 0
	{
		return -0x4F80;
	}
	if (ret = mbedtls_ecp_check_privkey(grp, m)) != 0 || (ret = mbedtls_ecp_check_pubkey(grp, P)) != 0
	{
		return ret;
	}
	if ecp_get_type(grp) == ECP_TYPE_MONTGOMERY
	{
		return ecp_mul_mxz(grp, R, m, P, f_rng, p_rng);
	}
	if ecp_get_type(grp) == ECP_TYPE_SHORT_WEIERSTRASS
	{
		return ecp_mul_comb(grp, R, m, P, f_rng, p_rng);
	}
	return -0x4F80;
}

fn ecp_check_pubkey_sw(const mbedtls_ecp_group * grp, const mbedtls_ecp_poi32 * pt) -> i32
{
	i32 ret;
	mbedtls_mpi YY, RHS;
	if mbedtls_mpi_cmp_int(&pt.X, 0) < 0 || mbedtls_mpi_cmp_int(&pt.Y, 0) < 0 || mbedtls_mpi_cmp_mpi(&pt.X, &grp.P) >= 0 || mbedtls_mpi_cmp_mpi(&pt.Y, &grp.P) >= 0
	{
		return -0x4C80;
	}
	mbedtls_mpi_init(&YY);
	mbedtls_mpi_init(&RHS);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&YY, &pt.Y, &pt.Y)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&YY, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&RHS, &pt.X, &pt.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&RHS, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	if grp.A.p == NULL
	{
		do
		{
			if (ret = mbedtls_mpi_sub_int(&RHS, &RHS, 3)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		while (RHS.s < 0 && mbedtls_mpi_cmp_int(&RHS, 0) != 0)
			do
			{
				if (ret = mbedtls_mpi_add_mpi(&RHS, &RHS, &grp.P)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
	}
	else
	{
		do
		{
			if (ret = mbedtls_mpi_add_mpi(&RHS, &RHS, &grp.A)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		while (mbedtls_mpi_cmp_mpi(&RHS, &grp.P) >= 0)
			do
			{
				if (ret = mbedtls_mpi_sub_abs(&RHS, &RHS, &grp.P)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
	}
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&RHS, &RHS, &pt.X)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = ecp_modp(&RHS, grp)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		mul_count++;
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_mpi(&RHS, &RHS, &grp.B)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	while (mbedtls_mpi_cmp_mpi(&RHS, &grp.P) >= 0)
		do
		{
			if (ret = mbedtls_mpi_sub_abs(&RHS, &RHS, &grp.P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	if mbedtls_mpi_cmp_mpi(&YY, &RHS) != 0
	{
		ret = -0x4C80;
	}
cleanup:
	mbedtls_mpi_free(&YY);
	mbedtls_mpi_free(&RHS);
	return ret;
}

fn mbedtls_ecp_mul_shortcuts(mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_mpi * m, const mbedtls_ecp_poi32 * P) -> i32
{
	i32 ret;
	if mbedtls_mpi_cmp_int(m, 1) == 0
	{
		do
		{
			if (ret = mbedtls_ecp_copy(R, P)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	else
		if mbedtls_mpi_cmp_int(m, -1) == 0
		{
			do
			{
				if (ret = mbedtls_ecp_copy(R, P)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
			if mbedtls_mpi_cmp_int(&R.Y, 0) != 0
				do
				{
					if (ret = mbedtls_mpi_sub_mpi(&R.Y, &grp.P, &R.Y)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
		}
		else
		{
			do
			{
				if (ret = mbedtls_ecp_mul(grp, R, m, P, NULL, NULL)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
cleanup:
	return ret;
}

pub fn mbedtls_ecp_muladd(mbedtls_ecp_group * grp, mbedtls_ecp_poi32 * R, const mbedtls_mpi * m, const mbedtls_ecp_poi32 * P, const mbedtls_mpi * n, const mbedtls_ecp_poi32 * Q) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 mP;
	if ecp_get_type(grp) != ECP_TYPE_SHORT_WEIERSTRASS
	{
		return -0x4E80;
	}
	mbedtls_ecp_point_init(&mP);
	do
	{
		if (ret = mbedtls_ecp_mul_shortcuts(grp, &mP, m, P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul_shortcuts(grp, R, n, Q)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecp_add_mixed(grp, R, &mP, R)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = ecp_normalize_jac(grp, R)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	mbedtls_ecp_point_free(&mP);
	return ret;
}

fn ecp_check_pubkey_mx(const mbedtls_ecp_group * grp, const mbedtls_ecp_poi32 * pt) -> i32
{
	if mbedtls_mpi_size(&pt.X) > (grp.nbits + 7) / 8
	{
		return -0x4C80;
	}
	return 0;
}

pub fn mbedtls_ecp_check_pubkey(const mbedtls_ecp_group * grp, const mbedtls_ecp_poi32 * pt) -> i32
{
	if mbedtls_mpi_cmp_int(&pt.Z, 1) != 0
	{
		return -0x4C80;
	}
	if ecp_get_type(grp) == ECP_TYPE_MONTGOMERY
	{
		return ecp_check_pubkey_mx(grp, pt);
	}
	if ecp_get_type(grp) == ECP_TYPE_SHORT_WEIERSTRASS
	{
		return ecp_check_pubkey_sw(grp, pt);
	}
	return -0x4F80;
}

pub fn mbedtls_ecp_check_privkey(const mbedtls_ecp_group * grp, const mbedtls_mpi * d) -> i32
{
	if ecp_get_type(grp) == ECP_TYPE_MONTGOMERY
	{
		if mbedtls_mpi_get_bit(d, 0) != 0 || mbedtls_mpi_get_bit(d, 1) != 0 || mbedtls_mpi_get_bit(d, 2) != 0 || mbedtls_mpi_bitlen(d) - 1 != grp.nbits
		{
			return -0x4C80;
		}
		else
		{
			return 0;
		}
	}
	if ecp_get_type(grp) == ECP_TYPE_SHORT_WEIERSTRASS
	{
		if mbedtls_mpi_cmp_int(d, 1) < 0 || mbedtls_mpi_cmp_mpi(d, &grp.N) >= 0
		{
			return -0x4C80;
		}
		else
		{
			return 0;
		}
	}
	return -0x4F80;
}

pub fn mbedtls_ecp_gen_keypair_base(mbedtls_ecp_group * grp, const mbedtls_ecp_poi32 * G, mbedtls_mpi * d, mbedtls_ecp_poi32 * Q, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	usize n_size = (grp.nbits + 7) / 8;
	if ecp_get_type(grp) == ECP_TYPE_MONTGOMERY
	{
		usize b;
		do
		{
			do
			{
				if (ret = mbedtls_mpi_fill_random(d, n_size, f_rng, p_rng)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		while (mbedtls_mpi_bitlen(d) == 0);
		b = mbedtls_mpi_bitlen(d) - 1;
		if b > grp.nbits
			do
			{
				if (ret = mbedtls_mpi_shift_r(d, b - grp.nbits)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		else
			do
			{
				if (ret = mbedtls_mpi_set_bit(d, grp.nbits, 1)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		do
		{
			if (ret = mbedtls_mpi_set_bit(d, 0, 0)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_set_bit(d, 1, 0)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_set_bit(d, 2, 0)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	else
		if ecp_get_type(grp) == ECP_TYPE_SHORT_WEIERSTRASS
		{
			i32 count = 0;
			u8 rnd[((521 + 7) / 8)];
			do
			{
				do
				{
					if (ret = f_rng(p_rng, rnd, n_size)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				do
				{
					if (ret = mbedtls_mpi_read_binary(d, rnd, n_size)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				do
				{
					if (ret = mbedtls_mpi_shift_r(d, 8 * n_size - grp.nbits)) != 0
					{
						goto cleanup;
					}
				}
				while (0);
				if ++count > 30
				{
					return -0x4D00;
				}
			}
			while (mbedtls_mpi_cmp_int(d, 1) < 0 || mbedtls_mpi_cmp_mpi(d, &grp.N) >= 0);
		}
		else
		{
			return -0x4F80;
		}
cleanup:
	if ret != 0
	{
		return ret;
	}
	return mbedtls_ecp_mul(grp, Q, d, G, f_rng, p_rng);
}

pub fn mbedtls_ecp_gen_keypair(mbedtls_ecp_group * grp, mbedtls_mpi * d, mbedtls_ecp_poi32 * Q, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	return mbedtls_ecp_gen_keypair_base(grp, &grp.G, d, Q, f_rng, p_rng);
}

pub fn mbedtls_ecp_gen_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair * key, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	if (ret = mbedtls_ecp_group_load(&key.grp, grp_id)) != 0
	{
		return ret;
	}
	return mbedtls_ecp_gen_keypair(&key.grp, &key.d, &key.Q, f_rng, p_rng);
}

pub fn mbedtls_ecp_check_pub_priv(const mbedtls_ecp_keypair * pub, const mbedtls_ecp_keypair * prv) -> i32
{
	i32 ret;
	mbedtls_ecp_poi32 Q;
	mbedtls_ecp_group grp;
	if pub.grp.id == MBEDTLS_ECP_DP_NONE || pub.grp.id != prv.grp.id || mbedtls_mpi_cmp_mpi(&pub.Q.X, &prv.Q.X) || mbedtls_mpi_cmp_mpi(&pub.Q.Y, &prv.Q.Y) || mbedtls_mpi_cmp_mpi(&pub.Q.Z, &prv.Q.Z)
	{
		return -0x4F80;
	}
	mbedtls_ecp_point_init(&Q);
	mbedtls_ecp_group_init(&grp);
	mbedtls_ecp_group_copy(&grp, &prv.grp);
	do
	{
		if (ret = mbedtls_ecp_mul(&grp, &Q, &prv.d, &prv.grp.G, NULL, NULL)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_mpi(&Q.X, &prv.Q.X) || mbedtls_mpi_cmp_mpi(&Q.Y, &prv.Q.Y) || mbedtls_mpi_cmp_mpi(&Q.Z, &prv.Q.Z)
	{
		ret = -0x4F80;
		goto cleanup;
	}
cleanup:
	mbedtls_ecp_point_free(&Q);
	mbedtls_ecp_group_free(&grp);
	return ret;
}

pub fn mbedtls_ecp_self_test(i32 verbose) -> i32
{
	i32 ret;
	usize i;
	mbedtls_ecp_group grp;
	mbedtls_ecp_poi32 R, P;
	mbedtls_mpi m;
	u32 add_c_prev, dbl_c_prev, mul_c_prev;
	const i8 * exponents[] =
	{
		"000000000000000000000000000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22830", "5EA6F389A38B8BC81E767753B15AA5569E1782E30ABE7D25", "400000000000000000000000000000000000000000000000", "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "555555555555555555555555555555555555555555555555",
	};
	mbedtls_ecp_group_init(&grp);
	mbedtls_ecp_point_init(&R);
	mbedtls_ecp_point_init(&P);
	mbedtls_mpi_init(&m);
	do
	{
		if (ret = mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_SECP192R1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("  ECP test #1 (constant op_count, base poi32 G): ");
	}
	do
	{
		if (ret = mbedtls_mpi_lset(&m, 2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(&grp, &P, &m, &grp.G, NULL, NULL)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	add_count = 0;
	dbl_count = 0;
	mul_count = 0;
	do
	{
		if (ret = mbedtls_mpi_read_string(&m, 16, exponents[0])) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(&grp, &R, &m, &grp.G, NULL, NULL)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i = 1; i < sizeof(exponents) / sizeof(exponents[0]); i++)
	{
		add_c_prev = add_count;
		dbl_c_prev = dbl_count;
		mul_c_prev = mul_count;
		add_count = 0;
		dbl_count = 0;
		mul_count = 0;
		do
		{
			if (ret = mbedtls_mpi_read_string(&m, 16, exponents[i])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_ecp_mul(&grp, &R, &m, &grp.G, NULL, NULL)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if add_count != add_c_prev || dbl_count != dbl_c_prev || mul_count != mul_c_prev
		{
			if verbose != 0
			{
				printf("failed (%u)\n", (i32 int) i);
			}
			ret = 1;
			goto cleanup;
		}
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  ECP test #2 (constant op_count, other point): ");
	}
	add_count = 0;
	dbl_count = 0;
	mul_count = 0;
	do
	{
		if (ret = mbedtls_mpi_read_string(&m, 16, exponents[0])) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_ecp_mul(&grp, &R, &m, &P, NULL, NULL)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i = 1; i < sizeof(exponents) / sizeof(exponents[0]); i++)
	{
		add_c_prev = add_count;
		dbl_c_prev = dbl_count;
		mul_c_prev = mul_count;
		add_count = 0;
		dbl_count = 0;
		mul_count = 0;
		do
		{
			if (ret = mbedtls_mpi_read_string(&m, 16, exponents[i])) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_ecp_mul(&grp, &R, &m, &P, NULL, NULL)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if add_count != add_c_prev || dbl_count != dbl_c_prev || mul_count != mul_c_prev
		{
			if verbose != 0
			{
				printf("failed (%u)\n", (i32 int) i);
			}
			ret = 1;
			goto cleanup;
		}
	}
	if verbose != 0
	{
		printf("passed\n");
	}
cleanup:
	if ret < 0 && verbose != 0
	{
		printf("Unexpected error, return code = %08X\n", ret);
	}
	mbedtls_ecp_group_free(&grp);
	mbedtls_ecp_point_free(&R);
	mbedtls_ecp_point_free(&P);
	mbedtls_mpi_free(&m);
	if verbose != 0
	{
		printf("\n");
	}
	return ret;
}

static const mbedtls_mpi_ui32 secp192r1_p[] =
{
	((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFE << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp192r1_b[] =
{
	((mbedtls_mpi_uint) 0xB1 << 0) | ((mbedtls_mpi_uint) 0xB9 << 8) | ((mbedtls_mpi_uint) 0x46 << 16) | ((mbedtls_mpi_uint) 0xC1 << 24) | ((mbedtls_mpi_uint) 0xEC << 32) | ((mbedtls_mpi_uint) 0xDE << 40) | ((mbedtls_mpi_uint) 0xB8 << 48) | ((mbedtls_mpi_uint) 0xFE << 56), ((mbedtls_mpi_uint) 0x49 << 0) | ((mbedtls_mpi_uint) 0x30 << 8) | ((mbedtls_mpi_uint) 0x24 << 16) | ((mbedtls_mpi_uint) 0x72 << 24) | ((mbedtls_mpi_uint) 0xAB << 32) | ((mbedtls_mpi_uint) 0xE9 << 40) | ((mbedtls_mpi_uint) 0xA7 << 48) | ((mbedtls_mpi_uint) 0x0F << 56), ((mbedtls_mpi_uint) 0xE7 << 0) | ((mbedtls_mpi_uint) 0x80 << 8) | ((mbedtls_mpi_uint) 0x9C << 16) | ((mbedtls_mpi_uint) 0xE5 << 24) | ((mbedtls_mpi_uint) 0x19 << 32) | ((mbedtls_mpi_uint) 0x05 << 40) | ((mbedtls_mpi_uint) 0x21 << 48) | ((mbedtls_mpi_uint) 0x64 << 56),
};
static const mbedtls_mpi_ui32 secp192r1_gx[] =
{
	((mbedtls_mpi_uint) 0x12 << 0) | ((mbedtls_mpi_uint) 0x10 << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0x82 << 24) | ((mbedtls_mpi_uint) 0xFD << 32) | ((mbedtls_mpi_uint) 0x0A << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xF4 << 56), ((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x88 << 8) | ((mbedtls_mpi_uint) 0xA1 << 16) | ((mbedtls_mpi_uint) 0x43 << 24) | ((mbedtls_mpi_uint) 0xEB << 32) | ((mbedtls_mpi_uint) 0x20 << 40) | ((mbedtls_mpi_uint) 0xBF << 48) | ((mbedtls_mpi_uint) 0x7C << 56), ((mbedtls_mpi_uint) 0xF6 << 0) | ((mbedtls_mpi_uint) 0x90 << 8) | ((mbedtls_mpi_uint) 0x30 << 16) | ((mbedtls_mpi_uint) 0xB0 << 24) | ((mbedtls_mpi_uint) 0x0E << 32) | ((mbedtls_mpi_uint) 0xA8 << 40) | ((mbedtls_mpi_uint) 0x8D << 48) | ((mbedtls_mpi_uint) 0x18 << 56),
};
static const mbedtls_mpi_ui32 secp192r1_gy[] =
{
	((mbedtls_mpi_uint) 0x11 << 0) | ((mbedtls_mpi_uint) 0x48 << 8) | ((mbedtls_mpi_uint) 0x79 << 16) | ((mbedtls_mpi_uint) 0x1E << 24) | ((mbedtls_mpi_uint) 0xA1 << 32) | ((mbedtls_mpi_uint) 0x77 << 40) | ((mbedtls_mpi_uint) 0xF9 << 48) | ((mbedtls_mpi_uint) 0x73 << 56), ((mbedtls_mpi_uint) 0xD5 << 0) | ((mbedtls_mpi_uint) 0xCD << 8) | ((mbedtls_mpi_uint) 0x24 << 16) | ((mbedtls_mpi_uint) 0x6B << 24) | ((mbedtls_mpi_uint) 0xED << 32) | ((mbedtls_mpi_uint) 0x11 << 40) | ((mbedtls_mpi_uint) 0x10 << 48) | ((mbedtls_mpi_uint) 0x63 << 56), ((mbedtls_mpi_uint) 0x78 << 0) | ((mbedtls_mpi_uint) 0xDA << 8) | ((mbedtls_mpi_uint) 0xC8 << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0x95 << 32) | ((mbedtls_mpi_uint) 0x2B << 40) | ((mbedtls_mpi_uint) 0x19 << 48) | ((mbedtls_mpi_uint) 0x07 << 56),
};
static const mbedtls_mpi_ui32 secp192r1_n[] =
{
	((mbedtls_mpi_uint) 0x31 << 0) | ((mbedtls_mpi_uint) 0x28 << 8) | ((mbedtls_mpi_uint) 0xD2 << 16) | ((mbedtls_mpi_uint) 0xB4 << 24) | ((mbedtls_mpi_uint) 0xB1 << 32) | ((mbedtls_mpi_uint) 0xC9 << 40) | ((mbedtls_mpi_uint) 0x6B << 48) | ((mbedtls_mpi_uint) 0x14 << 56), ((mbedtls_mpi_uint) 0x36 << 0) | ((mbedtls_mpi_uint) 0xF8 << 8) | ((mbedtls_mpi_uint) 0xDE << 16) | ((mbedtls_mpi_uint) 0x99 << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp224r1_p[] =
{
	((mbedtls_mpi_uint) 0x01 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56), ((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56),
};
static const mbedtls_mpi_ui32 secp224r1_b[] =
{
	((mbedtls_mpi_uint) 0xB4 << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0x55 << 16) | ((mbedtls_mpi_uint) 0x23 << 24) | ((mbedtls_mpi_uint) 0x43 << 32) | ((mbedtls_mpi_uint) 0x39 << 40) | ((mbedtls_mpi_uint) 0x0B << 48) | ((mbedtls_mpi_uint) 0x27 << 56), ((mbedtls_mpi_uint) 0xBA << 0) | ((mbedtls_mpi_uint) 0xD8 << 8) | ((mbedtls_mpi_uint) 0xBF << 16) | ((mbedtls_mpi_uint) 0xD7 << 24) | ((mbedtls_mpi_uint) 0xB7 << 32) | ((mbedtls_mpi_uint) 0xB0 << 40) | ((mbedtls_mpi_uint) 0x44 << 48) | ((mbedtls_mpi_uint) 0x50 << 56), ((mbedtls_mpi_uint) 0x56 << 0) | ((mbedtls_mpi_uint) 0x32 << 8) | ((mbedtls_mpi_uint) 0x41 << 16) | ((mbedtls_mpi_uint) 0xF5 << 24) | ((mbedtls_mpi_uint) 0xAB << 32) | ((mbedtls_mpi_uint) 0xB3 << 40) | ((mbedtls_mpi_uint) 0x04 << 48) | ((mbedtls_mpi_uint) 0x0C << 56), ((mbedtls_mpi_uint) 0x85 << 0) | ((mbedtls_mpi_uint) 0x0A << 8) | ((mbedtls_mpi_uint) 0x05 << 16) | ((mbedtls_mpi_uint) 0xB4 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224r1_gx[] =
{
	((mbedtls_mpi_uint) 0x21 << 0) | ((mbedtls_mpi_uint) 0x1D << 8) | ((mbedtls_mpi_uint) 0x5C << 16) | ((mbedtls_mpi_uint) 0x11 << 24) | ((mbedtls_mpi_uint) 0xD6 << 32) | ((mbedtls_mpi_uint) 0x80 << 40) | ((mbedtls_mpi_uint) 0x32 << 48) | ((mbedtls_mpi_uint) 0x34 << 56), ((mbedtls_mpi_uint) 0x22 << 0) | ((mbedtls_mpi_uint) 0x11 << 8) | ((mbedtls_mpi_uint) 0xC2 << 16) | ((mbedtls_mpi_uint) 0x56 << 24) | ((mbedtls_mpi_uint) 0xD3 << 32) | ((mbedtls_mpi_uint) 0xC1 << 40) | ((mbedtls_mpi_uint) 0x03 << 48) | ((mbedtls_mpi_uint) 0x4A << 56), ((mbedtls_mpi_uint) 0xB9 << 0) | ((mbedtls_mpi_uint) 0x90 << 8) | ((mbedtls_mpi_uint) 0x13 << 16) | ((mbedtls_mpi_uint) 0x32 << 24) | ((mbedtls_mpi_uint) 0x7F << 32) | ((mbedtls_mpi_uint) 0xBF << 40) | ((mbedtls_mpi_uint) 0xB4 << 48) | ((mbedtls_mpi_uint) 0x6B << 56), ((mbedtls_mpi_uint) 0xBD << 0) | ((mbedtls_mpi_uint) 0x0C << 8) | ((mbedtls_mpi_uint) 0x0E << 16) | ((mbedtls_mpi_uint) 0xB7 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224r1_gy[] =
{
	((mbedtls_mpi_uint) 0x34 << 0) | ((mbedtls_mpi_uint) 0x7E << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x85 << 24) | ((mbedtls_mpi_uint) 0x99 << 32) | ((mbedtls_mpi_uint) 0x81 << 40) | ((mbedtls_mpi_uint) 0xD5 << 48) | ((mbedtls_mpi_uint) 0x44 << 56), ((mbedtls_mpi_uint) 0x64 << 0) | ((mbedtls_mpi_uint) 0x47 << 8) | ((mbedtls_mpi_uint) 0x07 << 16) | ((mbedtls_mpi_uint) 0x5A << 24) | ((mbedtls_mpi_uint) 0xA0 << 32) | ((mbedtls_mpi_uint) 0x75 << 40) | ((mbedtls_mpi_uint) 0x43 << 48) | ((mbedtls_mpi_uint) 0xCD << 56), ((mbedtls_mpi_uint) 0xE6 << 0) | ((mbedtls_mpi_uint) 0xDF << 8) | ((mbedtls_mpi_uint) 0x22 << 16) | ((mbedtls_mpi_uint) 0x4C << 24) | ((mbedtls_mpi_uint) 0xFB << 32) | ((mbedtls_mpi_uint) 0x23 << 40) | ((mbedtls_mpi_uint) 0xF7 << 48) | ((mbedtls_mpi_uint) 0xB5 << 56), ((mbedtls_mpi_uint) 0x88 << 0) | ((mbedtls_mpi_uint) 0x63 << 8) | ((mbedtls_mpi_uint) 0x37 << 16) | ((mbedtls_mpi_uint) 0xBD << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224r1_n[] =
{
	((mbedtls_mpi_uint) 0x3D << 0) | ((mbedtls_mpi_uint) 0x2A << 8) | ((mbedtls_mpi_uint) 0x5C << 16) | ((mbedtls_mpi_uint) 0x5C << 24) | ((mbedtls_mpi_uint) 0x45 << 32) | ((mbedtls_mpi_uint) 0x29 << 40) | ((mbedtls_mpi_uint) 0xDD << 48) | ((mbedtls_mpi_uint) 0x13 << 56), ((mbedtls_mpi_uint) 0x3E << 0) | ((mbedtls_mpi_uint) 0xF0 << 8) | ((mbedtls_mpi_uint) 0xB8 << 16) | ((mbedtls_mpi_uint) 0xE0 << 24) | ((mbedtls_mpi_uint) 0xA2 << 32) | ((mbedtls_mpi_uint) 0x16 << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp256r1_p[] =
{
	((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56), ((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56), ((mbedtls_mpi_uint) 0x01 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp256r1_b[] =
{
	((mbedtls_mpi_uint) 0x4B << 0) | ((mbedtls_mpi_uint) 0x60 << 8) | ((mbedtls_mpi_uint) 0xD2 << 16) | ((mbedtls_mpi_uint) 0x27 << 24) | ((mbedtls_mpi_uint) 0x3E << 32) | ((mbedtls_mpi_uint) 0x3C << 40) | ((mbedtls_mpi_uint) 0xCE << 48) | ((mbedtls_mpi_uint) 0x3B << 56), ((mbedtls_mpi_uint) 0xF6 << 0) | ((mbedtls_mpi_uint) 0xB0 << 8) | ((mbedtls_mpi_uint) 0x53 << 16) | ((mbedtls_mpi_uint) 0xCC << 24) | ((mbedtls_mpi_uint) 0xB0 << 32) | ((mbedtls_mpi_uint) 0x06 << 40) | ((mbedtls_mpi_uint) 0x1D << 48) | ((mbedtls_mpi_uint) 0x65 << 56), ((mbedtls_mpi_uint) 0xBC << 0) | ((mbedtls_mpi_uint) 0x86 << 8) | ((mbedtls_mpi_uint) 0x98 << 16) | ((mbedtls_mpi_uint) 0x76 << 24) | ((mbedtls_mpi_uint) 0x55 << 32) | ((mbedtls_mpi_uint) 0xBD << 40) | ((mbedtls_mpi_uint) 0xEB << 48) | ((mbedtls_mpi_uint) 0xB3 << 56), ((mbedtls_mpi_uint) 0xE7 << 0) | ((mbedtls_mpi_uint) 0x93 << 8) | ((mbedtls_mpi_uint) 0x3A << 16) | ((mbedtls_mpi_uint) 0xAA << 24) | ((mbedtls_mpi_uint) 0xD8 << 32) | ((mbedtls_mpi_uint) 0x35 << 40) | ((mbedtls_mpi_uint) 0xC6 << 48) | ((mbedtls_mpi_uint) 0x5A << 56),
};
static const mbedtls_mpi_ui32 secp256r1_gx[] =
{
	((mbedtls_mpi_uint) 0x96 << 0) | ((mbedtls_mpi_uint) 0xC2 << 8) | ((mbedtls_mpi_uint) 0x98 << 16) | ((mbedtls_mpi_uint) 0xD8 << 24) | ((mbedtls_mpi_uint) 0x45 << 32) | ((mbedtls_mpi_uint) 0x39 << 40) | ((mbedtls_mpi_uint) 0xA1 << 48) | ((mbedtls_mpi_uint) 0xF4 << 56), ((mbedtls_mpi_uint) 0xA0 << 0) | ((mbedtls_mpi_uint) 0x33 << 8) | ((mbedtls_mpi_uint) 0xEB << 16) | ((mbedtls_mpi_uint) 0x2D << 24) | ((mbedtls_mpi_uint) 0x81 << 32) | ((mbedtls_mpi_uint) 0x7D << 40) | ((mbedtls_mpi_uint) 0x03 << 48) | ((mbedtls_mpi_uint) 0x77 << 56), ((mbedtls_mpi_uint) 0xF2 << 0) | ((mbedtls_mpi_uint) 0x40 << 8) | ((mbedtls_mpi_uint) 0xA4 << 16) | ((mbedtls_mpi_uint) 0x63 << 24) | ((mbedtls_mpi_uint) 0xE5 << 32) | ((mbedtls_mpi_uint) 0xE6 << 40) | ((mbedtls_mpi_uint) 0xBC << 48) | ((mbedtls_mpi_uint) 0xF8 << 56), ((mbedtls_mpi_uint) 0x47 << 0) | ((mbedtls_mpi_uint) 0x42 << 8) | ((mbedtls_mpi_uint) 0x2C << 16) | ((mbedtls_mpi_uint) 0xE1 << 24) | ((mbedtls_mpi_uint) 0xF2 << 32) | ((mbedtls_mpi_uint) 0xD1 << 40) | ((mbedtls_mpi_uint) 0x17 << 48) | ((mbedtls_mpi_uint) 0x6B << 56),
};
static const mbedtls_mpi_ui32 secp256r1_gy[] =
{
	((mbedtls_mpi_uint) 0xF5 << 0) | ((mbedtls_mpi_uint) 0x51 << 8) | ((mbedtls_mpi_uint) 0xBF << 16) | ((mbedtls_mpi_uint) 0x37 << 24) | ((mbedtls_mpi_uint) 0x68 << 32) | ((mbedtls_mpi_uint) 0x40 << 40) | ((mbedtls_mpi_uint) 0xB6 << 48) | ((mbedtls_mpi_uint) 0xCB << 56), ((mbedtls_mpi_uint) 0xCE << 0) | ((mbedtls_mpi_uint) 0x5E << 8) | ((mbedtls_mpi_uint) 0x31 << 16) | ((mbedtls_mpi_uint) 0x6B << 24) | ((mbedtls_mpi_uint) 0x57 << 32) | ((mbedtls_mpi_uint) 0x33 << 40) | ((mbedtls_mpi_uint) 0xCE << 48) | ((mbedtls_mpi_uint) 0x2B << 56), ((mbedtls_mpi_uint) 0x16 << 0) | ((mbedtls_mpi_uint) 0x9E << 8) | ((mbedtls_mpi_uint) 0x0F << 16) | ((mbedtls_mpi_uint) 0x7C << 24) | ((mbedtls_mpi_uint) 0x4A << 32) | ((mbedtls_mpi_uint) 0xEB << 40) | ((mbedtls_mpi_uint) 0xE7 << 48) | ((mbedtls_mpi_uint) 0x8E << 56), ((mbedtls_mpi_uint) 0x9B << 0) | ((mbedtls_mpi_uint) 0x7F << 8) | ((mbedtls_mpi_uint) 0x1A << 16) | ((mbedtls_mpi_uint) 0xFE << 24) | ((mbedtls_mpi_uint) 0xE2 << 32) | ((mbedtls_mpi_uint) 0x42 << 40) | ((mbedtls_mpi_uint) 0xE3 << 48) | ((mbedtls_mpi_uint) 0x4F << 56),
};
static const mbedtls_mpi_ui32 secp256r1_n[] =
{
	((mbedtls_mpi_uint) 0x51 << 0) | ((mbedtls_mpi_uint) 0x25 << 8) | ((mbedtls_mpi_uint) 0x63 << 16) | ((mbedtls_mpi_uint) 0xFC << 24) | ((mbedtls_mpi_uint) 0xC2 << 32) | ((mbedtls_mpi_uint) 0xCA << 40) | ((mbedtls_mpi_uint) 0xB9 << 48) | ((mbedtls_mpi_uint) 0xF3 << 56), ((mbedtls_mpi_uint) 0x84 << 0) | ((mbedtls_mpi_uint) 0x9E << 8) | ((mbedtls_mpi_uint) 0x17 << 16) | ((mbedtls_mpi_uint) 0xA7 << 24) | ((mbedtls_mpi_uint) 0xAD << 32) | ((mbedtls_mpi_uint) 0xFA << 40) | ((mbedtls_mpi_uint) 0xE6 << 48) | ((mbedtls_mpi_uint) 0xBC << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp384r1_p[] =
{
	((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56), ((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFE << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp384r1_b[] =
{
	((mbedtls_mpi_uint) 0xEF << 0) | ((mbedtls_mpi_uint) 0x2A << 8) | ((mbedtls_mpi_uint) 0xEC << 16) | ((mbedtls_mpi_uint) 0xD3 << 24) | ((mbedtls_mpi_uint) 0xED << 32) | ((mbedtls_mpi_uint) 0xC8 << 40) | ((mbedtls_mpi_uint) 0x85 << 48) | ((mbedtls_mpi_uint) 0x2A << 56), ((mbedtls_mpi_uint) 0x9D << 0) | ((mbedtls_mpi_uint) 0xD1 << 8) | ((mbedtls_mpi_uint) 0x2E << 16) | ((mbedtls_mpi_uint) 0x8A << 24) | ((mbedtls_mpi_uint) 0x8D << 32) | ((mbedtls_mpi_uint) 0x39 << 40) | ((mbedtls_mpi_uint) 0x56 << 48) | ((mbedtls_mpi_uint) 0xC6 << 56), ((mbedtls_mpi_uint) 0x5A << 0) | ((mbedtls_mpi_uint) 0x87 << 8) | ((mbedtls_mpi_uint) 0x13 << 16) | ((mbedtls_mpi_uint) 0x50 << 24) | ((mbedtls_mpi_uint) 0x8F << 32) | ((mbedtls_mpi_uint) 0x08 << 40) | ((mbedtls_mpi_uint) 0x14 << 48) | ((mbedtls_mpi_uint) 0x03 << 56), ((mbedtls_mpi_uint) 0x12 << 0) | ((mbedtls_mpi_uint) 0x41 << 8) | ((mbedtls_mpi_uint) 0x81 << 16) | ((mbedtls_mpi_uint) 0xFE << 24) | ((mbedtls_mpi_uint) 0x6E << 32) | ((mbedtls_mpi_uint) 0x9C << 40) | ((mbedtls_mpi_uint) 0x1D << 48) | ((mbedtls_mpi_uint) 0x18 << 56), ((mbedtls_mpi_uint) 0x19 << 0) | ((mbedtls_mpi_uint) 0x2D << 8) | ((mbedtls_mpi_uint) 0xF8 << 16) | ((mbedtls_mpi_uint) 0xE3 << 24) | ((mbedtls_mpi_uint) 0x6B << 32) | ((mbedtls_mpi_uint) 0x05 << 40) | ((mbedtls_mpi_uint) 0x8E << 48) | ((mbedtls_mpi_uint) 0x98 << 56), ((mbedtls_mpi_uint) 0xE4 << 0) | ((mbedtls_mpi_uint) 0xE7 << 8) | ((mbedtls_mpi_uint) 0x3E << 16) | ((mbedtls_mpi_uint) 0xE2 << 24) | ((mbedtls_mpi_uint) 0xA7 << 32) | ((mbedtls_mpi_uint) 0x2F << 40) | ((mbedtls_mpi_uint) 0x31 << 48) | ((mbedtls_mpi_uint) 0xB3 << 56),
};
static const mbedtls_mpi_ui32 secp384r1_gx[] =
{
	((mbedtls_mpi_uint) 0xB7 << 0) | ((mbedtls_mpi_uint) 0x0A << 8) | ((mbedtls_mpi_uint) 0x76 << 16) | ((mbedtls_mpi_uint) 0x72 << 24) | ((mbedtls_mpi_uint) 0x38 << 32) | ((mbedtls_mpi_uint) 0x5E << 40) | ((mbedtls_mpi_uint) 0x54 << 48) | ((mbedtls_mpi_uint) 0x3A << 56), ((mbedtls_mpi_uint) 0x6C << 0) | ((mbedtls_mpi_uint) 0x29 << 8) | ((mbedtls_mpi_uint) 0x55 << 16) | ((mbedtls_mpi_uint) 0xBF << 24) | ((mbedtls_mpi_uint) 0x5D << 32) | ((mbedtls_mpi_uint) 0xF2 << 40) | ((mbedtls_mpi_uint) 0x02 << 48) | ((mbedtls_mpi_uint) 0x55 << 56), ((mbedtls_mpi_uint) 0x38 << 0) | ((mbedtls_mpi_uint) 0x2A << 8) | ((mbedtls_mpi_uint) 0x54 << 16) | ((mbedtls_mpi_uint) 0x82 << 24) | ((mbedtls_mpi_uint) 0xE0 << 32) | ((mbedtls_mpi_uint) 0x41 << 40) | ((mbedtls_mpi_uint) 0xF7 << 48) | ((mbedtls_mpi_uint) 0x59 << 56), ((mbedtls_mpi_uint) 0x98 << 0) | ((mbedtls_mpi_uint) 0x9B << 8) | ((mbedtls_mpi_uint) 0xA7 << 16) | ((mbedtls_mpi_uint) 0x8B << 24) | ((mbedtls_mpi_uint) 0x62 << 32) | ((mbedtls_mpi_uint) 0x3B << 40) | ((mbedtls_mpi_uint) 0x1D << 48) | ((mbedtls_mpi_uint) 0x6E << 56), ((mbedtls_mpi_uint) 0x74 << 0) | ((mbedtls_mpi_uint) 0xAD << 8) | ((mbedtls_mpi_uint) 0x20 << 16) | ((mbedtls_mpi_uint) 0xF3 << 24) | ((mbedtls_mpi_uint) 0x1E << 32) | ((mbedtls_mpi_uint) 0xC7 << 40) | ((mbedtls_mpi_uint) 0xB1 << 48) | ((mbedtls_mpi_uint) 0x8E << 56), ((mbedtls_mpi_uint) 0x37 << 0) | ((mbedtls_mpi_uint) 0x05 << 8) | ((mbedtls_mpi_uint) 0x8B << 16) | ((mbedtls_mpi_uint) 0xBE << 24) | ((mbedtls_mpi_uint) 0x22 << 32) | ((mbedtls_mpi_uint) 0xCA << 40) | ((mbedtls_mpi_uint) 0x87 << 48) | ((mbedtls_mpi_uint) 0xAA << 56),
};
static const mbedtls_mpi_ui32 secp384r1_gy[] =
{
	((mbedtls_mpi_uint) 0x5F << 0) | ((mbedtls_mpi_uint) 0x0E << 8) | ((mbedtls_mpi_uint) 0xEA << 16) | ((mbedtls_mpi_uint) 0x90 << 24) | ((mbedtls_mpi_uint) 0x7C << 32) | ((mbedtls_mpi_uint) 0x1D << 40) | ((mbedtls_mpi_uint) 0x43 << 48) | ((mbedtls_mpi_uint) 0x7A << 56), ((mbedtls_mpi_uint) 0x9D << 0) | ((mbedtls_mpi_uint) 0x81 << 8) | ((mbedtls_mpi_uint) 0x7E << 16) | ((mbedtls_mpi_uint) 0x1D << 24) | ((mbedtls_mpi_uint) 0xCE << 32) | ((mbedtls_mpi_uint) 0xB1 << 40) | ((mbedtls_mpi_uint) 0x60 << 48) | ((mbedtls_mpi_uint) 0x0A << 56), ((mbedtls_mpi_uint) 0xC0 << 0) | ((mbedtls_mpi_uint) 0xB8 << 8) | ((mbedtls_mpi_uint) 0xF0 << 16) | ((mbedtls_mpi_uint) 0xB5 << 24) | ((mbedtls_mpi_uint) 0x13 << 32) | ((mbedtls_mpi_uint) 0x31 << 40) | ((mbedtls_mpi_uint) 0xDA << 48) | ((mbedtls_mpi_uint) 0xE9 << 56), ((mbedtls_mpi_uint) 0x7C << 0) | ((mbedtls_mpi_uint) 0x14 << 8) | ((mbedtls_mpi_uint) 0x9A << 16) | ((mbedtls_mpi_uint) 0x28 << 24) | ((mbedtls_mpi_uint) 0xBD << 32) | ((mbedtls_mpi_uint) 0x1D << 40) | ((mbedtls_mpi_uint) 0xF4 << 48) | ((mbedtls_mpi_uint) 0xF8 << 56), ((mbedtls_mpi_uint) 0x29 << 0) | ((mbedtls_mpi_uint) 0xDC << 8) | ((mbedtls_mpi_uint) 0x92 << 16) | ((mbedtls_mpi_uint) 0x92 << 24) | ((mbedtls_mpi_uint) 0xBF << 32) | ((mbedtls_mpi_uint) 0x98 << 40) | ((mbedtls_mpi_uint) 0x9E << 48) | ((mbedtls_mpi_uint) 0x5D << 56), ((mbedtls_mpi_uint) 0x6F << 0) | ((mbedtls_mpi_uint) 0x2C << 8) | ((mbedtls_mpi_uint) 0x26 << 16) | ((mbedtls_mpi_uint) 0x96 << 24) | ((mbedtls_mpi_uint) 0x4A << 32) | ((mbedtls_mpi_uint) 0xDE << 40) | ((mbedtls_mpi_uint) 0x17 << 48) | ((mbedtls_mpi_uint) 0x36 << 56),
};
static const mbedtls_mpi_ui32 secp384r1_n[] =
{
	((mbedtls_mpi_uint) 0x73 << 0) | ((mbedtls_mpi_uint) 0x29 << 8) | ((mbedtls_mpi_uint) 0xC5 << 16) | ((mbedtls_mpi_uint) 0xCC << 24) | ((mbedtls_mpi_uint) 0x6A << 32) | ((mbedtls_mpi_uint) 0x19 << 40) | ((mbedtls_mpi_uint) 0xEC << 48) | ((mbedtls_mpi_uint) 0xEC << 56), ((mbedtls_mpi_uint) 0x7A << 0) | ((mbedtls_mpi_uint) 0xA7 << 8) | ((mbedtls_mpi_uint) 0xB0 << 16) | ((mbedtls_mpi_uint) 0x48 << 24) | ((mbedtls_mpi_uint) 0xB2 << 32) | ((mbedtls_mpi_uint) 0x0D << 40) | ((mbedtls_mpi_uint) 0x1A << 48) | ((mbedtls_mpi_uint) 0x58 << 56), ((mbedtls_mpi_uint) 0xDF << 0) | ((mbedtls_mpi_uint) 0x2D << 8) | ((mbedtls_mpi_uint) 0x37 << 16) | ((mbedtls_mpi_uint) 0xF4 << 24) | ((mbedtls_mpi_uint) 0x81 << 32) | ((mbedtls_mpi_uint) 0x4D << 40) | ((mbedtls_mpi_uint) 0x63 << 48) | ((mbedtls_mpi_uint) 0xC7 << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp521r1_p[] =
{
	((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0x01 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp521r1_b[] =
{
	((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x3F << 8) | ((mbedtls_mpi_uint) 0x50 << 16) | ((mbedtls_mpi_uint) 0x6B << 24) | ((mbedtls_mpi_uint) 0xD4 << 32) | ((mbedtls_mpi_uint) 0x1F << 40) | ((mbedtls_mpi_uint) 0x45 << 48) | ((mbedtls_mpi_uint) 0xEF << 56), ((mbedtls_mpi_uint) 0xF1 << 0) | ((mbedtls_mpi_uint) 0x34 << 8) | ((mbedtls_mpi_uint) 0x2C << 16) | ((mbedtls_mpi_uint) 0x3D << 24) | ((mbedtls_mpi_uint) 0x88 << 32) | ((mbedtls_mpi_uint) 0xDF << 40) | ((mbedtls_mpi_uint) 0x73 << 48) | ((mbedtls_mpi_uint) 0x35 << 56), ((mbedtls_mpi_uint) 0x07 << 0) | ((mbedtls_mpi_uint) 0xBF << 8) | ((mbedtls_mpi_uint) 0xB1 << 16) | ((mbedtls_mpi_uint) 0x3B << 24) | ((mbedtls_mpi_uint) 0xBD << 32) | ((mbedtls_mpi_uint) 0xC0 << 40) | ((mbedtls_mpi_uint) 0x52 << 48) | ((mbedtls_mpi_uint) 0x16 << 56), ((mbedtls_mpi_uint) 0x7B << 0) | ((mbedtls_mpi_uint) 0x93 << 8) | ((mbedtls_mpi_uint) 0x7E << 16) | ((mbedtls_mpi_uint) 0xEC << 24) | ((mbedtls_mpi_uint) 0x51 << 32) | ((mbedtls_mpi_uint) 0x39 << 40) | ((mbedtls_mpi_uint) 0x19 << 48) | ((mbedtls_mpi_uint) 0x56 << 56), ((mbedtls_mpi_uint) 0xE1 << 0) | ((mbedtls_mpi_uint) 0x09 << 8) | ((mbedtls_mpi_uint) 0xF1 << 16) | ((mbedtls_mpi_uint) 0x8E << 24) | ((mbedtls_mpi_uint) 0x91 << 32) | ((mbedtls_mpi_uint) 0x89 << 40) | ((mbedtls_mpi_uint) 0xB4 << 48) | ((mbedtls_mpi_uint) 0xB8 << 56), ((mbedtls_mpi_uint) 0xF3 << 0) | ((mbedtls_mpi_uint) 0x15 << 8) | ((mbedtls_mpi_uint) 0xB3 << 16) | ((mbedtls_mpi_uint) 0x99 << 24) | ((mbedtls_mpi_uint) 0x5B << 32) | ((mbedtls_mpi_uint) 0x72 << 40) | ((mbedtls_mpi_uint) 0xDA << 48) | ((mbedtls_mpi_uint) 0xA2 << 56), ((mbedtls_mpi_uint) 0xEE << 0) | ((mbedtls_mpi_uint) 0x40 << 8) | ((mbedtls_mpi_uint) 0x85 << 16) | ((mbedtls_mpi_uint) 0xB6 << 24) | ((mbedtls_mpi_uint) 0xA0 << 32) | ((mbedtls_mpi_uint) 0x21 << 40) | ((mbedtls_mpi_uint) 0x9A << 48) | ((mbedtls_mpi_uint) 0x92 << 56), ((mbedtls_mpi_uint) 0x1F << 0) | ((mbedtls_mpi_uint) 0x9A << 8) | ((mbedtls_mpi_uint) 0x1C << 16) | ((mbedtls_mpi_uint) 0x8E << 24) | ((mbedtls_mpi_uint) 0x61 << 32) | ((mbedtls_mpi_uint) 0xB9 << 40) | ((mbedtls_mpi_uint) 0x3E << 48) | ((mbedtls_mpi_uint) 0x95 << 56), ((mbedtls_mpi_uint) 0x51 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp521r1_gx[] =
{
	((mbedtls_mpi_uint) 0x66 << 0) | ((mbedtls_mpi_uint) 0xBD << 8) | ((mbedtls_mpi_uint) 0xE5 << 16) | ((mbedtls_mpi_uint) 0xC2 << 24) | ((mbedtls_mpi_uint) 0x31 << 32) | ((mbedtls_mpi_uint) 0x7E << 40) | ((mbedtls_mpi_uint) 0x7E << 48) | ((mbedtls_mpi_uint) 0xF9 << 56), ((mbedtls_mpi_uint) 0x9B << 0) | ((mbedtls_mpi_uint) 0x42 << 8) | ((mbedtls_mpi_uint) 0x6A << 16) | ((mbedtls_mpi_uint) 0x85 << 24) | ((mbedtls_mpi_uint) 0xC1 << 32) | ((mbedtls_mpi_uint) 0xB3 << 40) | ((mbedtls_mpi_uint) 0x48 << 48) | ((mbedtls_mpi_uint) 0x33 << 56), ((mbedtls_mpi_uint) 0xDE << 0) | ((mbedtls_mpi_uint) 0xA8 << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xA2 << 24) | ((mbedtls_mpi_uint) 0x27 << 32) | ((mbedtls_mpi_uint) 0xC1 << 40) | ((mbedtls_mpi_uint) 0x1D << 48) | ((mbedtls_mpi_uint) 0xFE << 56), ((mbedtls_mpi_uint) 0x28 << 0) | ((mbedtls_mpi_uint) 0x59 << 8) | ((mbedtls_mpi_uint) 0xE7 << 16) | ((mbedtls_mpi_uint) 0xEF << 24) | ((mbedtls_mpi_uint) 0x77 << 32) | ((mbedtls_mpi_uint) 0x5E << 40) | ((mbedtls_mpi_uint) 0x4B << 48) | ((mbedtls_mpi_uint) 0xA1 << 56), ((mbedtls_mpi_uint) 0xBA << 0) | ((mbedtls_mpi_uint) 0x3D << 8) | ((mbedtls_mpi_uint) 0x4D << 16) | ((mbedtls_mpi_uint) 0x6B << 24) | ((mbedtls_mpi_uint) 0x60 << 32) | ((mbedtls_mpi_uint) 0xAF << 40) | ((mbedtls_mpi_uint) 0x28 << 48) | ((mbedtls_mpi_uint) 0xF8 << 56), ((mbedtls_mpi_uint) 0x21 << 0) | ((mbedtls_mpi_uint) 0xB5 << 8) | ((mbedtls_mpi_uint) 0x3F << 16) | ((mbedtls_mpi_uint) 0x05 << 24) | ((mbedtls_mpi_uint) 0x39 << 32) | ((mbedtls_mpi_uint) 0x81 << 40) | ((mbedtls_mpi_uint) 0x64 << 48) | ((mbedtls_mpi_uint) 0x9C << 56), ((mbedtls_mpi_uint) 0x42 << 0) | ((mbedtls_mpi_uint) 0xB4 << 8) | ((mbedtls_mpi_uint) 0x95 << 16) | ((mbedtls_mpi_uint) 0x23 << 24) | ((mbedtls_mpi_uint) 0x66 << 32) | ((mbedtls_mpi_uint) 0xCB << 40) | ((mbedtls_mpi_uint) 0x3E << 48) | ((mbedtls_mpi_uint) 0x9E << 56), ((mbedtls_mpi_uint) 0xCD << 0) | ((mbedtls_mpi_uint) 0xE9 << 8) | ((mbedtls_mpi_uint) 0x04 << 16) | ((mbedtls_mpi_uint) 0x04 << 24) | ((mbedtls_mpi_uint) 0xB7 << 32) | ((mbedtls_mpi_uint) 0x06 << 40) | ((mbedtls_mpi_uint) 0x8E << 48) | ((mbedtls_mpi_uint) 0x85 << 56), ((mbedtls_mpi_uint) 0xC6 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp521r1_gy[] =
{
	((mbedtls_mpi_uint) 0x50 << 0) | ((mbedtls_mpi_uint) 0x66 << 8) | ((mbedtls_mpi_uint) 0xD1 << 16) | ((mbedtls_mpi_uint) 0x9F << 24) | ((mbedtls_mpi_uint) 0x76 << 32) | ((mbedtls_mpi_uint) 0x94 << 40) | ((mbedtls_mpi_uint) 0xBE << 48) | ((mbedtls_mpi_uint) 0x88 << 56), ((mbedtls_mpi_uint) 0x40 << 0) | ((mbedtls_mpi_uint) 0xC2 << 8) | ((mbedtls_mpi_uint) 0x72 << 16) | ((mbedtls_mpi_uint) 0xA2 << 24) | ((mbedtls_mpi_uint) 0x86 << 32) | ((mbedtls_mpi_uint) 0x70 << 40) | ((mbedtls_mpi_uint) 0x3C << 48) | ((mbedtls_mpi_uint) 0x35 << 56), ((mbedtls_mpi_uint) 0x61 << 0) | ((mbedtls_mpi_uint) 0x07 << 8) | ((mbedtls_mpi_uint) 0xAD << 16) | ((mbedtls_mpi_uint) 0x3F << 24) | ((mbedtls_mpi_uint) 0x01 << 32) | ((mbedtls_mpi_uint) 0xB9 << 40) | ((mbedtls_mpi_uint) 0x50 << 48) | ((mbedtls_mpi_uint) 0xC5 << 56), ((mbedtls_mpi_uint) 0x40 << 0) | ((mbedtls_mpi_uint) 0x26 << 8) | ((mbedtls_mpi_uint) 0xF4 << 16) | ((mbedtls_mpi_uint) 0x5E << 24) | ((mbedtls_mpi_uint) 0x99 << 32) | ((mbedtls_mpi_uint) 0x72 << 40) | ((mbedtls_mpi_uint) 0xEE << 48) | ((mbedtls_mpi_uint) 0x97 << 56), ((mbedtls_mpi_uint) 0x2C << 0) | ((mbedtls_mpi_uint) 0x66 << 8) | ((mbedtls_mpi_uint) 0x3E << 16) | ((mbedtls_mpi_uint) 0x27 << 24) | ((mbedtls_mpi_uint) 0x17 << 32) | ((mbedtls_mpi_uint) 0xBD << 40) | ((mbedtls_mpi_uint) 0xAF << 48) | ((mbedtls_mpi_uint) 0x17 << 56), ((mbedtls_mpi_uint) 0x68 << 0) | ((mbedtls_mpi_uint) 0x44 << 8) | ((mbedtls_mpi_uint) 0x9B << 16) | ((mbedtls_mpi_uint) 0x57 << 24) | ((mbedtls_mpi_uint) 0x49 << 32) | ((mbedtls_mpi_uint) 0x44 << 40) | ((mbedtls_mpi_uint) 0xF5 << 48) | ((mbedtls_mpi_uint) 0x98 << 56), ((mbedtls_mpi_uint) 0xD9 << 0) | ((mbedtls_mpi_uint) 0x1B << 8) | ((mbedtls_mpi_uint) 0x7D << 16) | ((mbedtls_mpi_uint) 0x2C << 24) | ((mbedtls_mpi_uint) 0xB4 << 32) | ((mbedtls_mpi_uint) 0x5F << 40) | ((mbedtls_mpi_uint) 0x8A << 48) | ((mbedtls_mpi_uint) 0x5C << 56), ((mbedtls_mpi_uint) 0x04 << 0) | ((mbedtls_mpi_uint) 0xC0 << 8) | ((mbedtls_mpi_uint) 0x3B << 16) | ((mbedtls_mpi_uint) 0x9A << 24) | ((mbedtls_mpi_uint) 0x78 << 32) | ((mbedtls_mpi_uint) 0x6A << 40) | ((mbedtls_mpi_uint) 0x29 << 48) | ((mbedtls_mpi_uint) 0x39 << 56), ((mbedtls_mpi_uint) 0x18 << 0) | ((mbedtls_mpi_uint) 0x01 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp521r1_n[] =
{
	((mbedtls_mpi_uint) 0x09 << 0) | ((mbedtls_mpi_uint) 0x64 << 8) | ((mbedtls_mpi_uint) 0x38 << 16) | ((mbedtls_mpi_uint) 0x91 << 24) | ((mbedtls_mpi_uint) 0x1E << 32) | ((mbedtls_mpi_uint) 0xB7 << 40) | ((mbedtls_mpi_uint) 0x6F << 48) | ((mbedtls_mpi_uint) 0xBB << 56), ((mbedtls_mpi_uint) 0xAE << 0) | ((mbedtls_mpi_uint) 0x47 << 8) | ((mbedtls_mpi_uint) 0x9C << 16) | ((mbedtls_mpi_uint) 0x89 << 24) | ((mbedtls_mpi_uint) 0xB8 << 32) | ((mbedtls_mpi_uint) 0xC9 << 40) | ((mbedtls_mpi_uint) 0xB5 << 48) | ((mbedtls_mpi_uint) 0x3B << 56), ((mbedtls_mpi_uint) 0xD0 << 0) | ((mbedtls_mpi_uint) 0xA5 << 8) | ((mbedtls_mpi_uint) 0x09 << 16) | ((mbedtls_mpi_uint) 0xF7 << 24) | ((mbedtls_mpi_uint) 0x48 << 32) | ((mbedtls_mpi_uint) 0x01 << 40) | ((mbedtls_mpi_uint) 0xCC << 48) | ((mbedtls_mpi_uint) 0x7F << 56), ((mbedtls_mpi_uint) 0x6B << 0) | ((mbedtls_mpi_uint) 0x96 << 8) | ((mbedtls_mpi_uint) 0x2F << 16) | ((mbedtls_mpi_uint) 0xBF << 24) | ((mbedtls_mpi_uint) 0x83 << 32) | ((mbedtls_mpi_uint) 0x87 << 40) | ((mbedtls_mpi_uint) 0x86 << 48) | ((mbedtls_mpi_uint) 0x51 << 56), ((mbedtls_mpi_uint) 0xFA << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0x01 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp192k1_p[] =
{
	((mbedtls_mpi_uint) 0x37 << 0) | ((mbedtls_mpi_uint) 0xEE << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFE << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp192k1_a[] =
{
	((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp192k1_b[] =
{
	((mbedtls_mpi_uint) 0x03 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp192k1_gx[] =
{
	((mbedtls_mpi_uint) 0x7D << 0) | ((mbedtls_mpi_uint) 0x6C << 8) | ((mbedtls_mpi_uint) 0xE0 << 16) | ((mbedtls_mpi_uint) 0xEA << 24) | ((mbedtls_mpi_uint) 0xB1 << 32) | ((mbedtls_mpi_uint) 0xD1 << 40) | ((mbedtls_mpi_uint) 0xA5 << 48) | ((mbedtls_mpi_uint) 0x1D << 56), ((mbedtls_mpi_uint) 0x34 << 0) | ((mbedtls_mpi_uint) 0xF4 << 8) | ((mbedtls_mpi_uint) 0xB7 << 16) | ((mbedtls_mpi_uint) 0x80 << 24) | ((mbedtls_mpi_uint) 0x02 << 32) | ((mbedtls_mpi_uint) 0x7D << 40) | ((mbedtls_mpi_uint) 0xB0 << 48) | ((mbedtls_mpi_uint) 0x26 << 56), ((mbedtls_mpi_uint) 0xAE << 0) | ((mbedtls_mpi_uint) 0xE9 << 8) | ((mbedtls_mpi_uint) 0x57 << 16) | ((mbedtls_mpi_uint) 0xC0 << 24) | ((mbedtls_mpi_uint) 0x0E << 32) | ((mbedtls_mpi_uint) 0xF1 << 40) | ((mbedtls_mpi_uint) 0x4F << 48) | ((mbedtls_mpi_uint) 0xDB << 56),
};
static const mbedtls_mpi_ui32 secp192k1_gy[] =
{
	((mbedtls_mpi_uint) 0x9D << 0) | ((mbedtls_mpi_uint) 0x2F << 8) | ((mbedtls_mpi_uint) 0x5E << 16) | ((mbedtls_mpi_uint) 0xD9 << 24) | ((mbedtls_mpi_uint) 0x88 << 32) | ((mbedtls_mpi_uint) 0xAA << 40) | ((mbedtls_mpi_uint) 0x82 << 48) | ((mbedtls_mpi_uint) 0x40 << 56), ((mbedtls_mpi_uint) 0x34 << 0) | ((mbedtls_mpi_uint) 0x86 << 8) | ((mbedtls_mpi_uint) 0xBE << 16) | ((mbedtls_mpi_uint) 0x15 << 24) | ((mbedtls_mpi_uint) 0xD0 << 32) | ((mbedtls_mpi_uint) 0x63 << 40) | ((mbedtls_mpi_uint) 0x41 << 48) | ((mbedtls_mpi_uint) 0x84 << 56), ((mbedtls_mpi_uint) 0xA7 << 0) | ((mbedtls_mpi_uint) 0x28 << 8) | ((mbedtls_mpi_uint) 0x56 << 16) | ((mbedtls_mpi_uint) 0x9C << 24) | ((mbedtls_mpi_uint) 0x6D << 32) | ((mbedtls_mpi_uint) 0x2F << 40) | ((mbedtls_mpi_uint) 0x2F << 48) | ((mbedtls_mpi_uint) 0x9B << 56),
};
static const mbedtls_mpi_ui32 secp192k1_n[] =
{
	((mbedtls_mpi_uint) 0x8D << 0) | ((mbedtls_mpi_uint) 0xFD << 8) | ((mbedtls_mpi_uint) 0xDE << 16) | ((mbedtls_mpi_uint) 0x74 << 24) | ((mbedtls_mpi_uint) 0x6A << 32) | ((mbedtls_mpi_uint) 0x46 << 40) | ((mbedtls_mpi_uint) 0x69 << 48) | ((mbedtls_mpi_uint) 0x0F << 56), ((mbedtls_mpi_uint) 0x17 << 0) | ((mbedtls_mpi_uint) 0xFC << 8) | ((mbedtls_mpi_uint) 0xF2 << 16) | ((mbedtls_mpi_uint) 0x26 << 24) | ((mbedtls_mpi_uint) 0xFE << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp224k1_p[] =
{
	((mbedtls_mpi_uint) 0x6D << 0) | ((mbedtls_mpi_uint) 0xE5 << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFE << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224k1_a[] =
{
	((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224k1_b[] =
{
	((mbedtls_mpi_uint) 0x05 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224k1_gx[] =
{
	((mbedtls_mpi_uint) 0x5C << 0) | ((mbedtls_mpi_uint) 0xA4 << 8) | ((mbedtls_mpi_uint) 0xB7 << 16) | ((mbedtls_mpi_uint) 0xB6 << 24) | ((mbedtls_mpi_uint) 0x0E << 32) | ((mbedtls_mpi_uint) 0x65 << 40) | ((mbedtls_mpi_uint) 0x7E << 48) | ((mbedtls_mpi_uint) 0x0F << 56), ((mbedtls_mpi_uint) 0xA9 << 0) | ((mbedtls_mpi_uint) 0x75 << 8) | ((mbedtls_mpi_uint) 0x70 << 16) | ((mbedtls_mpi_uint) 0xE4 << 24) | ((mbedtls_mpi_uint) 0xE9 << 32) | ((mbedtls_mpi_uint) 0x67 << 40) | ((mbedtls_mpi_uint) 0xA4 << 48) | ((mbedtls_mpi_uint) 0x69 << 56), ((mbedtls_mpi_uint) 0xA1 << 0) | ((mbedtls_mpi_uint) 0x28 << 8) | ((mbedtls_mpi_uint) 0xFC << 16) | ((mbedtls_mpi_uint) 0x30 << 24) | ((mbedtls_mpi_uint) 0xDF << 32) | ((mbedtls_mpi_uint) 0x99 << 40) | ((mbedtls_mpi_uint) 0xF0 << 48) | ((mbedtls_mpi_uint) 0x4D << 56), ((mbedtls_mpi_uint) 0x33 << 0) | ((mbedtls_mpi_uint) 0x5B << 8) | ((mbedtls_mpi_uint) 0x45 << 16) | ((mbedtls_mpi_uint) 0xA1 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224k1_gy[] =
{
	((mbedtls_mpi_uint) 0xA5 << 0) | ((mbedtls_mpi_uint) 0x61 << 8) | ((mbedtls_mpi_uint) 0x6D << 16) | ((mbedtls_mpi_uint) 0x55 << 24) | ((mbedtls_mpi_uint) 0xDB << 32) | ((mbedtls_mpi_uint) 0x4B << 40) | ((mbedtls_mpi_uint) 0xCA << 48) | ((mbedtls_mpi_uint) 0xE2 << 56), ((mbedtls_mpi_uint) 0x59 << 0) | ((mbedtls_mpi_uint) 0xBD << 8) | ((mbedtls_mpi_uint) 0xB0 << 16) | ((mbedtls_mpi_uint) 0xC0 << 24) | ((mbedtls_mpi_uint) 0xF7 << 32) | ((mbedtls_mpi_uint) 0x19 << 40) | ((mbedtls_mpi_uint) 0xE3 << 48) | ((mbedtls_mpi_uint) 0xF7 << 56), ((mbedtls_mpi_uint) 0xD6 << 0) | ((mbedtls_mpi_uint) 0xFB << 8) | ((mbedtls_mpi_uint) 0xCA << 16) | ((mbedtls_mpi_uint) 0x82 << 24) | ((mbedtls_mpi_uint) 0x42 << 32) | ((mbedtls_mpi_uint) 0x34 << 40) | ((mbedtls_mpi_uint) 0xBA << 48) | ((mbedtls_mpi_uint) 0x7F << 56), ((mbedtls_mpi_uint) 0xED << 0) | ((mbedtls_mpi_uint) 0x9F << 8) | ((mbedtls_mpi_uint) 0x08 << 16) | ((mbedtls_mpi_uint) 0x7E << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp224k1_n[] =
{
	((mbedtls_mpi_uint) 0xF7 << 0) | ((mbedtls_mpi_uint) 0xB1 << 8) | ((mbedtls_mpi_uint) 0x9F << 16) | ((mbedtls_mpi_uint) 0x76 << 24) | ((mbedtls_mpi_uint) 0x71 << 32) | ((mbedtls_mpi_uint) 0xA9 << 40) | ((mbedtls_mpi_uint) 0xF0 << 48) | ((mbedtls_mpi_uint) 0xCA << 56), ((mbedtls_mpi_uint) 0x84 << 0) | ((mbedtls_mpi_uint) 0x61 << 8) | ((mbedtls_mpi_uint) 0xEC << 16) | ((mbedtls_mpi_uint) 0xD2 << 24) | ((mbedtls_mpi_uint) 0xE8 << 32) | ((mbedtls_mpi_uint) 0xDC << 40) | ((mbedtls_mpi_uint) 0x01 << 48) | ((mbedtls_mpi_uint) 0x00 << 56), ((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56), ((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0x01 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56),
};
static const mbedtls_mpi_ui32 secp256k1_p[] =
{
	((mbedtls_mpi_uint) 0x2F << 0) | ((mbedtls_mpi_uint) 0xFC << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFE << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 secp256k1_a[] =
{
	((mbedtls_mpi_uint) 0x00 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp256k1_b[] =
{
	((mbedtls_mpi_uint) 0x07 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0 << 16) | ((mbedtls_mpi_uint) 0 << 24) | ((mbedtls_mpi_uint) 0 << 32) | ((mbedtls_mpi_uint) 0 << 40) | ((mbedtls_mpi_uint) 0 << 48) | ((mbedtls_mpi_uint) 0 << 56),
};
static const mbedtls_mpi_ui32 secp256k1_gx[] =
{
	((mbedtls_mpi_uint) 0x98 << 0) | ((mbedtls_mpi_uint) 0x17 << 8) | ((mbedtls_mpi_uint) 0xF8 << 16) | ((mbedtls_mpi_uint) 0x16 << 24) | ((mbedtls_mpi_uint) 0x5B << 32) | ((mbedtls_mpi_uint) 0x81 << 40) | ((mbedtls_mpi_uint) 0xF2 << 48) | ((mbedtls_mpi_uint) 0x59 << 56), ((mbedtls_mpi_uint) 0xD9 << 0) | ((mbedtls_mpi_uint) 0x28 << 8) | ((mbedtls_mpi_uint) 0xCE << 16) | ((mbedtls_mpi_uint) 0x2D << 24) | ((mbedtls_mpi_uint) 0xDB << 32) | ((mbedtls_mpi_uint) 0xFC << 40) | ((mbedtls_mpi_uint) 0x9B << 48) | ((mbedtls_mpi_uint) 0x02 << 56), ((mbedtls_mpi_uint) 0x07 << 0) | ((mbedtls_mpi_uint) 0x0B << 8) | ((mbedtls_mpi_uint) 0x87 << 16) | ((mbedtls_mpi_uint) 0xCE << 24) | ((mbedtls_mpi_uint) 0x95 << 32) | ((mbedtls_mpi_uint) 0x62 << 40) | ((mbedtls_mpi_uint) 0xA0 << 48) | ((mbedtls_mpi_uint) 0x55 << 56), ((mbedtls_mpi_uint) 0xAC << 0) | ((mbedtls_mpi_uint) 0xBB << 8) | ((mbedtls_mpi_uint) 0xDC << 16) | ((mbedtls_mpi_uint) 0xF9 << 24) | ((mbedtls_mpi_uint) 0x7E << 32) | ((mbedtls_mpi_uint) 0x66 << 40) | ((mbedtls_mpi_uint) 0xBE << 48) | ((mbedtls_mpi_uint) 0x79 << 56),
};
static const mbedtls_mpi_ui32 secp256k1_gy[] =
{
	((mbedtls_mpi_uint) 0xB8 << 0) | ((mbedtls_mpi_uint) 0xD4 << 8) | ((mbedtls_mpi_uint) 0x10 << 16) | ((mbedtls_mpi_uint) 0xFB << 24) | ((mbedtls_mpi_uint) 0x8F << 32) | ((mbedtls_mpi_uint) 0xD0 << 40) | ((mbedtls_mpi_uint) 0x47 << 48) | ((mbedtls_mpi_uint) 0x9C << 56), ((mbedtls_mpi_uint) 0x19 << 0) | ((mbedtls_mpi_uint) 0x54 << 8) | ((mbedtls_mpi_uint) 0x85 << 16) | ((mbedtls_mpi_uint) 0xA6 << 24) | ((mbedtls_mpi_uint) 0x48 << 32) | ((mbedtls_mpi_uint) 0xB4 << 40) | ((mbedtls_mpi_uint) 0x17 << 48) | ((mbedtls_mpi_uint) 0xFD << 56), ((mbedtls_mpi_uint) 0xA8 << 0) | ((mbedtls_mpi_uint) 0x08 << 8) | ((mbedtls_mpi_uint) 0x11 << 16) | ((mbedtls_mpi_uint) 0x0E << 24) | ((mbedtls_mpi_uint) 0xFC << 32) | ((mbedtls_mpi_uint) 0xFB << 40) | ((mbedtls_mpi_uint) 0xA4 << 48) | ((mbedtls_mpi_uint) 0x5D << 56), ((mbedtls_mpi_uint) 0x65 << 0) | ((mbedtls_mpi_uint) 0xC4 << 8) | ((mbedtls_mpi_uint) 0xA3 << 16) | ((mbedtls_mpi_uint) 0x26 << 24) | ((mbedtls_mpi_uint) 0x77 << 32) | ((mbedtls_mpi_uint) 0xDA << 40) | ((mbedtls_mpi_uint) 0x3A << 48) | ((mbedtls_mpi_uint) 0x48 << 56),
};
static const mbedtls_mpi_ui32 secp256k1_n[] =
{
	((mbedtls_mpi_uint) 0x41 << 0) | ((mbedtls_mpi_uint) 0x41 << 8) | ((mbedtls_mpi_uint) 0x36 << 16) | ((mbedtls_mpi_uint) 0xD0 << 24) | ((mbedtls_mpi_uint) 0x8C << 32) | ((mbedtls_mpi_uint) 0x5E << 40) | ((mbedtls_mpi_uint) 0xD2 << 48) | ((mbedtls_mpi_uint) 0xBF << 56), ((mbedtls_mpi_uint) 0x3B << 0) | ((mbedtls_mpi_uint) 0xA0 << 8) | ((mbedtls_mpi_uint) 0x48 << 16) | ((mbedtls_mpi_uint) 0xAF << 24) | ((mbedtls_mpi_uint) 0xE6 << 32) | ((mbedtls_mpi_uint) 0xDC << 40) | ((mbedtls_mpi_uint) 0xAE << 48) | ((mbedtls_mpi_uint) 0xBA << 56), ((mbedtls_mpi_uint) 0xFE << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0xFF << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0xFF << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0xFF << 48) | ((mbedtls_mpi_uint) 0xFF << 56),
};
static const mbedtls_mpi_ui32 brainpoolP256r1_p[] =
{
	((mbedtls_mpi_uint) 0x77 << 0) | ((mbedtls_mpi_uint) 0x53 << 8) | ((mbedtls_mpi_uint) 0x6E << 16) | ((mbedtls_mpi_uint) 0x1F << 24) | ((mbedtls_mpi_uint) 0x1D << 32) | ((mbedtls_mpi_uint) 0x48 << 40) | ((mbedtls_mpi_uint) 0x13 << 48) | ((mbedtls_mpi_uint) 0x20 << 56), ((mbedtls_mpi_uint) 0x28 << 0) | ((mbedtls_mpi_uint) 0x20 << 8) | ((mbedtls_mpi_uint) 0x26 << 16) | ((mbedtls_mpi_uint) 0xD5 << 24) | ((mbedtls_mpi_uint) 0x23 << 32) | ((mbedtls_mpi_uint) 0xF6 << 40) | ((mbedtls_mpi_uint) 0x3B << 48) | ((mbedtls_mpi_uint) 0x6E << 56), ((mbedtls_mpi_uint) 0x72 << 0) | ((mbedtls_mpi_uint) 0x8D << 8) | ((mbedtls_mpi_uint) 0x83 << 16) | ((mbedtls_mpi_uint) 0x9D << 24) | ((mbedtls_mpi_uint) 0x90 << 32) | ((mbedtls_mpi_uint) 0x0A << 40) | ((mbedtls_mpi_uint) 0x66 << 48) | ((mbedtls_mpi_uint) 0x3E << 56), ((mbedtls_mpi_uint) 0xBC << 0) | ((mbedtls_mpi_uint) 0xA9 << 8) | ((mbedtls_mpi_uint) 0xEE << 16) | ((mbedtls_mpi_uint) 0xA1 << 24) | ((mbedtls_mpi_uint) 0xDB << 32) | ((mbedtls_mpi_uint) 0x57 << 40) | ((mbedtls_mpi_uint) 0xFB << 48) | ((mbedtls_mpi_uint) 0xA9 << 56),
};
static const mbedtls_mpi_ui32 brainpoolP256r1_a[] =
{
	((mbedtls_mpi_uint) 0xD9 << 0) | ((mbedtls_mpi_uint) 0xB5 << 8) | ((mbedtls_mpi_uint) 0x30 << 16) | ((mbedtls_mpi_uint) 0xF3 << 24) | ((mbedtls_mpi_uint) 0x44 << 32) | ((mbedtls_mpi_uint) 0x4B << 40) | ((mbedtls_mpi_uint) 0x4A << 48) | ((mbedtls_mpi_uint) 0xE9 << 56), ((mbedtls_mpi_uint) 0x6C << 0) | ((mbedtls_mpi_uint) 0x5C << 8) | ((mbedtls_mpi_uint) 0xDC << 16) | ((mbedtls_mpi_uint) 0x26 << 24) | ((mbedtls_mpi_uint) 0xC1 << 32) | ((mbedtls_mpi_uint) 0x55 << 40) | ((mbedtls_mpi_uint) 0x80 << 48) | ((mbedtls_mpi_uint) 0xFB << 56), ((mbedtls_mpi_uint) 0xE7 << 0) | ((mbedtls_mpi_uint) 0xFF << 8) | ((mbedtls_mpi_uint) 0x7A << 16) | ((mbedtls_mpi_uint) 0x41 << 24) | ((mbedtls_mpi_uint) 0x30 << 32) | ((mbedtls_mpi_uint) 0x75 << 40) | ((mbedtls_mpi_uint) 0xF6 << 48) | ((mbedtls_mpi_uint) 0xEE << 56), ((mbedtls_mpi_uint) 0x57 << 0) | ((mbedtls_mpi_uint) 0x30 << 8) | ((mbedtls_mpi_uint) 0x2C << 16) | ((mbedtls_mpi_uint) 0xFC << 24) | ((mbedtls_mpi_uint) 0x75 << 32) | ((mbedtls_mpi_uint) 0x09 << 40) | ((mbedtls_mpi_uint) 0x5A << 48) | ((mbedtls_mpi_uint) 0x7D << 56),
};
static const mbedtls_mpi_ui32 brainpoolP256r1_b[] =
{
	((mbedtls_mpi_uint) 0xB6 << 0) | ((mbedtls_mpi_uint) 0x07 << 8) | ((mbedtls_mpi_uint) 0x8C << 16) | ((mbedtls_mpi_uint) 0xFF << 24) | ((mbedtls_mpi_uint) 0x18 << 32) | ((mbedtls_mpi_uint) 0xDC << 40) | ((mbedtls_mpi_uint) 0xCC << 48) | ((mbedtls_mpi_uint) 0x6B << 56), ((mbedtls_mpi_uint) 0xCE << 0) | ((mbedtls_mpi_uint) 0xE1 << 8) | ((mbedtls_mpi_uint) 0xF7 << 16) | ((mbedtls_mpi_uint) 0x5C << 24) | ((mbedtls_mpi_uint) 0x29 << 32) | ((mbedtls_mpi_uint) 0x16 << 40) | ((mbedtls_mpi_uint) 0x84 << 48) | ((mbedtls_mpi_uint) 0x95 << 56), ((mbedtls_mpi_uint) 0xBF << 0) | ((mbedtls_mpi_uint) 0x7C << 8) | ((mbedtls_mpi_uint) 0xD7 << 16) | ((mbedtls_mpi_uint) 0xBB << 24) | ((mbedtls_mpi_uint) 0xD9 << 32) | ((mbedtls_mpi_uint) 0xB5 << 40) | ((mbedtls_mpi_uint) 0x30 << 48) | ((mbedtls_mpi_uint) 0xF3 << 56), ((mbedtls_mpi_uint) 0x44 << 0) | ((mbedtls_mpi_uint) 0x4B << 8) | ((mbedtls_mpi_uint) 0x4A << 16) | ((mbedtls_mpi_uint) 0xE9 << 24) | ((mbedtls_mpi_uint) 0x6C << 32) | ((mbedtls_mpi_uint) 0x5C << 40) | ((mbedtls_mpi_uint) 0xDC << 48) | ((mbedtls_mpi_uint) 0x26 << 56),
};
static const mbedtls_mpi_ui32 brainpoolP256r1_gx[] =
{
	((mbedtls_mpi_uint) 0x62 << 0) | ((mbedtls_mpi_uint) 0x32 << 8) | ((mbedtls_mpi_uint) 0xCE << 16) | ((mbedtls_mpi_uint) 0x9A << 24) | ((mbedtls_mpi_uint) 0xBD << 32) | ((mbedtls_mpi_uint) 0x53 << 40) | ((mbedtls_mpi_uint) 0x44 << 48) | ((mbedtls_mpi_uint) 0x3A << 56), ((mbedtls_mpi_uint) 0xC2 << 0) | ((mbedtls_mpi_uint) 0x23 << 8) | ((mbedtls_mpi_uint) 0xBD << 16) | ((mbedtls_mpi_uint) 0xE3 << 24) | ((mbedtls_mpi_uint) 0xE1 << 32) | ((mbedtls_mpi_uint) 0x27 << 40) | ((mbedtls_mpi_uint) 0xDE << 48) | ((mbedtls_mpi_uint) 0xB9 << 56), ((mbedtls_mpi_uint) 0xAF << 0) | ((mbedtls_mpi_uint) 0xB7 << 8) | ((mbedtls_mpi_uint) 0x81 << 16) | ((mbedtls_mpi_uint) 0xFC << 24) | ((mbedtls_mpi_uint) 0x2F << 32) | ((mbedtls_mpi_uint) 0x48 << 40) | ((mbedtls_mpi_uint) 0x4B << 48) | ((mbedtls_mpi_uint) 0x2C << 56), ((mbedtls_mpi_uint) 0xCB << 0) | ((mbedtls_mpi_uint) 0x57 << 8) | ((mbedtls_mpi_uint) 0x7E << 16) | ((mbedtls_mpi_uint) 0xCB << 24) | ((mbedtls_mpi_uint) 0xB9 << 32) | ((mbedtls_mpi_uint) 0xAE << 40) | ((mbedtls_mpi_uint) 0xD2 << 48) | ((mbedtls_mpi_uint) 0x8B << 56),
};
static const mbedtls_mpi_ui32 brainpoolP256r1_gy[] =
{
	((mbedtls_mpi_uint) 0x97 << 0) | ((mbedtls_mpi_uint) 0x69 << 8) | ((mbedtls_mpi_uint) 0x04 << 16) | ((mbedtls_mpi_uint) 0x2F << 24) | ((mbedtls_mpi_uint) 0xC7 << 32) | ((mbedtls_mpi_uint) 0x54 << 40) | ((mbedtls_mpi_uint) 0x1D << 48) | ((mbedtls_mpi_uint) 0x5C << 56), ((mbedtls_mpi_uint) 0x54 << 0) | ((mbedtls_mpi_uint) 0x8E << 8) | ((mbedtls_mpi_uint) 0xED << 16) | ((mbedtls_mpi_uint) 0x2D << 24) | ((mbedtls_mpi_uint) 0x13 << 32) | ((mbedtls_mpi_uint) 0x45 << 40) | ((mbedtls_mpi_uint) 0x77 << 48) | ((mbedtls_mpi_uint) 0xC2 << 56), ((mbedtls_mpi_uint) 0xC9 << 0) | ((mbedtls_mpi_uint) 0x1D << 8) | ((mbedtls_mpi_uint) 0x61 << 16) | ((mbedtls_mpi_uint) 0x14 << 24) | ((mbedtls_mpi_uint) 0x1A << 32) | ((mbedtls_mpi_uint) 0x46 << 40) | ((mbedtls_mpi_uint) 0xF8 << 48) | ((mbedtls_mpi_uint) 0x97 << 56), ((mbedtls_mpi_uint) 0xFD << 0) | ((mbedtls_mpi_uint) 0xC4 << 8) | ((mbedtls_mpi_uint) 0xDA << 16) | ((mbedtls_mpi_uint) 0xC3 << 24) | ((mbedtls_mpi_uint) 0x35 << 32) | ((mbedtls_mpi_uint) 0xF8 << 40) | ((mbedtls_mpi_uint) 0x7E << 48) | ((mbedtls_mpi_uint) 0x54 << 56),
};
static const mbedtls_mpi_ui32 brainpoolP256r1_n[] =
{
	((mbedtls_mpi_uint) 0xA7 << 0) | ((mbedtls_mpi_uint) 0x56 << 8) | ((mbedtls_mpi_uint) 0x48 << 16) | ((mbedtls_mpi_uint) 0x97 << 24) | ((mbedtls_mpi_uint) 0x82 << 32) | ((mbedtls_mpi_uint) 0x0E << 40) | ((mbedtls_mpi_uint) 0x1E << 48) | ((mbedtls_mpi_uint) 0x90 << 56), ((mbedtls_mpi_uint) 0xF7 << 0) | ((mbedtls_mpi_uint) 0xA6 << 8) | ((mbedtls_mpi_uint) 0x61 << 16) | ((mbedtls_mpi_uint) 0xB5 << 24) | ((mbedtls_mpi_uint) 0xA3 << 32) | ((mbedtls_mpi_uint) 0x7A << 40) | ((mbedtls_mpi_uint) 0x39 << 48) | ((mbedtls_mpi_uint) 0x8C << 56), ((mbedtls_mpi_uint) 0x71 << 0) | ((mbedtls_mpi_uint) 0x8D << 8) | ((mbedtls_mpi_uint) 0x83 << 16) | ((mbedtls_mpi_uint) 0x9D << 24) | ((mbedtls_mpi_uint) 0x90 << 32) | ((mbedtls_mpi_uint) 0x0A << 40) | ((mbedtls_mpi_uint) 0x66 << 48) | ((mbedtls_mpi_uint) 0x3E << 56), ((mbedtls_mpi_uint) 0xBC << 0) | ((mbedtls_mpi_uint) 0xA9 << 8) | ((mbedtls_mpi_uint) 0xEE << 16) | ((mbedtls_mpi_uint) 0xA1 << 24) | ((mbedtls_mpi_uint) 0xDB << 32) | ((mbedtls_mpi_uint) 0x57 << 40) | ((mbedtls_mpi_uint) 0xFB << 48) | ((mbedtls_mpi_uint) 0xA9 << 56),
};
static const mbedtls_mpi_ui32 brainpoolP384r1_p[] =
{
	((mbedtls_mpi_uint) 0x53 << 0) | ((mbedtls_mpi_uint) 0xEC << 8) | ((mbedtls_mpi_uint) 0x07 << 16) | ((mbedtls_mpi_uint) 0x31 << 24) | ((mbedtls_mpi_uint) 0x13 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x47 << 48) | ((mbedtls_mpi_uint) 0x87 << 56), ((mbedtls_mpi_uint) 0x71 << 0) | ((mbedtls_mpi_uint) 0x1A << 8) | ((mbedtls_mpi_uint) 0x1D << 16) | ((mbedtls_mpi_uint) 0x90 << 24) | ((mbedtls_mpi_uint) 0x29 << 32) | ((mbedtls_mpi_uint) 0xA7 << 40) | ((mbedtls_mpi_uint) 0xD3 << 48) | ((mbedtls_mpi_uint) 0xAC << 56), ((mbedtls_mpi_uint) 0x23 << 0) | ((mbedtls_mpi_uint) 0x11 << 8) | ((mbedtls_mpi_uint) 0xB7 << 16) | ((mbedtls_mpi_uint) 0x7F << 24) | ((mbedtls_mpi_uint) 0x19 << 32) | ((mbedtls_mpi_uint) 0xDA << 40) | ((mbedtls_mpi_uint) 0xB1 << 48) | ((mbedtls_mpi_uint) 0x12 << 56), ((mbedtls_mpi_uint) 0xB4 << 0) | ((mbedtls_mpi_uint) 0x56 << 8) | ((mbedtls_mpi_uint) 0x54 << 16) | ((mbedtls_mpi_uint) 0xED << 24) | ((mbedtls_mpi_uint) 0x09 << 32) | ((mbedtls_mpi_uint) 0x71 << 40) | ((mbedtls_mpi_uint) 0x2F << 48) | ((mbedtls_mpi_uint) 0x15 << 56), ((mbedtls_mpi_uint) 0xDF << 0) | ((mbedtls_mpi_uint) 0x41 << 8) | ((mbedtls_mpi_uint) 0xE6 << 16) | ((mbedtls_mpi_uint) 0x50 << 24) | ((mbedtls_mpi_uint) 0x7E << 32) | ((mbedtls_mpi_uint) 0x6F << 40) | ((mbedtls_mpi_uint) 0x5D << 48) | ((mbedtls_mpi_uint) 0x0F << 56), ((mbedtls_mpi_uint) 0x28 << 0) | ((mbedtls_mpi_uint) 0x6D << 8) | ((mbedtls_mpi_uint) 0x38 << 16) | ((mbedtls_mpi_uint) 0xA3 << 24) | ((mbedtls_mpi_uint) 0x82 << 32) | ((mbedtls_mpi_uint) 0x1E << 40) | ((mbedtls_mpi_uint) 0xB9 << 48) | ((mbedtls_mpi_uint) 0x8C << 56),
};
static const mbedtls_mpi_ui32 brainpoolP384r1_a[] =
{
	((mbedtls_mpi_uint) 0x26 << 0) | ((mbedtls_mpi_uint) 0x28 << 8) | ((mbedtls_mpi_uint) 0xCE << 16) | ((mbedtls_mpi_uint) 0x22 << 24) | ((mbedtls_mpi_uint) 0xDD << 32) | ((mbedtls_mpi_uint) 0xC7 << 40) | ((mbedtls_mpi_uint) 0xA8 << 48) | ((mbedtls_mpi_uint) 0x04 << 56), ((mbedtls_mpi_uint) 0xEB << 0) | ((mbedtls_mpi_uint) 0xD4 << 8) | ((mbedtls_mpi_uint) 0x3A << 16) | ((mbedtls_mpi_uint) 0x50 << 24) | ((mbedtls_mpi_uint) 0x4A << 32) | ((mbedtls_mpi_uint) 0x81 << 40) | ((mbedtls_mpi_uint) 0xA5 << 48) | ((mbedtls_mpi_uint) 0x8A << 56), ((mbedtls_mpi_uint) 0x0F << 0) | ((mbedtls_mpi_uint) 0xF9 << 8) | ((mbedtls_mpi_uint) 0x91 << 16) | ((mbedtls_mpi_uint) 0xBA << 24) | ((mbedtls_mpi_uint) 0xEF << 32) | ((mbedtls_mpi_uint) 0x65 << 40) | ((mbedtls_mpi_uint) 0x91 << 48) | ((mbedtls_mpi_uint) 0x13 << 56), ((mbedtls_mpi_uint) 0x87 << 0) | ((mbedtls_mpi_uint) 0x27 << 8) | ((mbedtls_mpi_uint) 0xB2 << 16) | ((mbedtls_mpi_uint) 0x4F << 24) | ((mbedtls_mpi_uint) 0x8E << 32) | ((mbedtls_mpi_uint) 0xA2 << 40) | ((mbedtls_mpi_uint) 0xBE << 48) | ((mbedtls_mpi_uint) 0xC2 << 56), ((mbedtls_mpi_uint) 0xA0 << 0) | ((mbedtls_mpi_uint) 0xAF << 8) | ((mbedtls_mpi_uint) 0x05 << 16) | ((mbedtls_mpi_uint) 0xCE << 24) | ((mbedtls_mpi_uint) 0x0A << 32) | ((mbedtls_mpi_uint) 0x08 << 40) | ((mbedtls_mpi_uint) 0x72 << 48) | ((mbedtls_mpi_uint) 0x3C << 56), ((mbedtls_mpi_uint) 0x0C << 0) | ((mbedtls_mpi_uint) 0x15 << 8) | ((mbedtls_mpi_uint) 0x8C << 16) | ((mbedtls_mpi_uint) 0x3D << 24) | ((mbedtls_mpi_uint) 0xC6 << 32) | ((mbedtls_mpi_uint) 0x82 << 40) | ((mbedtls_mpi_uint) 0xC3 << 48) | ((mbedtls_mpi_uint) 0x7B << 56),
};
static const mbedtls_mpi_ui32 brainpoolP384r1_b[] =
{
	((mbedtls_mpi_uint) 0x11 << 0) | ((mbedtls_mpi_uint) 0x4C << 8) | ((mbedtls_mpi_uint) 0x50 << 16) | ((mbedtls_mpi_uint) 0xFA << 24) | ((mbedtls_mpi_uint) 0x96 << 32) | ((mbedtls_mpi_uint) 0x86 << 40) | ((mbedtls_mpi_uint) 0xB7 << 48) | ((mbedtls_mpi_uint) 0x3A << 56), ((mbedtls_mpi_uint) 0x94 << 0) | ((mbedtls_mpi_uint) 0xC9 << 8) | ((mbedtls_mpi_uint) 0xDB << 16) | ((mbedtls_mpi_uint) 0x95 << 24) | ((mbedtls_mpi_uint) 0x02 << 32) | ((mbedtls_mpi_uint) 0x39 << 40) | ((mbedtls_mpi_uint) 0xB4 << 48) | ((mbedtls_mpi_uint) 0x7C << 56), ((mbedtls_mpi_uint) 0xD5 << 0) | ((mbedtls_mpi_uint) 0x62 << 8) | ((mbedtls_mpi_uint) 0xEB << 16) | ((mbedtls_mpi_uint) 0x3E << 24) | ((mbedtls_mpi_uint) 0xA5 << 32) | ((mbedtls_mpi_uint) 0x0E << 40) | ((mbedtls_mpi_uint) 0x88 << 48) | ((mbedtls_mpi_uint) 0x2E << 56), ((mbedtls_mpi_uint) 0xA6 << 0) | ((mbedtls_mpi_uint) 0xD2 << 8) | ((mbedtls_mpi_uint) 0xDC << 16) | ((mbedtls_mpi_uint) 0x07 << 24) | ((mbedtls_mpi_uint) 0xE1 << 32) | ((mbedtls_mpi_uint) 0x7D << 40) | ((mbedtls_mpi_uint) 0xB7 << 48) | ((mbedtls_mpi_uint) 0x2F << 56), ((mbedtls_mpi_uint) 0x7C << 0) | ((mbedtls_mpi_uint) 0x44 << 8) | ((mbedtls_mpi_uint) 0xF0 << 16) | ((mbedtls_mpi_uint) 0x16 << 24) | ((mbedtls_mpi_uint) 0x54 << 32) | ((mbedtls_mpi_uint) 0xB5 << 40) | ((mbedtls_mpi_uint) 0x39 << 48) | ((mbedtls_mpi_uint) 0x8B << 56), ((mbedtls_mpi_uint) 0x26 << 0) | ((mbedtls_mpi_uint) 0x28 << 8) | ((mbedtls_mpi_uint) 0xCE << 16) | ((mbedtls_mpi_uint) 0x22 << 24) | ((mbedtls_mpi_uint) 0xDD << 32) | ((mbedtls_mpi_uint) 0xC7 << 40) | ((mbedtls_mpi_uint) 0xA8 << 48) | ((mbedtls_mpi_uint) 0x04 << 56),
};
static const mbedtls_mpi_ui32 brainpoolP384r1_gx[] =
{
	((mbedtls_mpi_uint) 0x1E << 0) | ((mbedtls_mpi_uint) 0xAF << 8) | ((mbedtls_mpi_uint) 0xD4 << 16) | ((mbedtls_mpi_uint) 0x47 << 24) | ((mbedtls_mpi_uint) 0xE2 << 32) | ((mbedtls_mpi_uint) 0xB2 << 40) | ((mbedtls_mpi_uint) 0x87 << 48) | ((mbedtls_mpi_uint) 0xEF << 56), ((mbedtls_mpi_uint) 0xAA << 0) | ((mbedtls_mpi_uint) 0x46 << 8) | ((mbedtls_mpi_uint) 0xD6 << 16) | ((mbedtls_mpi_uint) 0x36 << 24) | ((mbedtls_mpi_uint) 0x34 << 32) | ((mbedtls_mpi_uint) 0xE0 << 40) | ((mbedtls_mpi_uint) 0x26 << 48) | ((mbedtls_mpi_uint) 0xE8 << 56), ((mbedtls_mpi_uint) 0xE8 << 0) | ((mbedtls_mpi_uint) 0x10 << 8) | ((mbedtls_mpi_uint) 0xBD << 16) | ((mbedtls_mpi_uint) 0x0C << 24) | ((mbedtls_mpi_uint) 0xFE << 32) | ((mbedtls_mpi_uint) 0xCA << 40) | ((mbedtls_mpi_uint) 0x7F << 48) | ((mbedtls_mpi_uint) 0xDB << 56), ((mbedtls_mpi_uint) 0xE3 << 0) | ((mbedtls_mpi_uint) 0x4F << 8) | ((mbedtls_mpi_uint) 0xF1 << 16) | ((mbedtls_mpi_uint) 0x7E << 24) | ((mbedtls_mpi_uint) 0xE7 << 32) | ((mbedtls_mpi_uint) 0xA3 << 40) | ((mbedtls_mpi_uint) 0x47 << 48) | ((mbedtls_mpi_uint) 0x88 << 56), ((mbedtls_mpi_uint) 0x6B << 0) | ((mbedtls_mpi_uint) 0x3F << 8) | ((mbedtls_mpi_uint) 0xC1 << 16) | ((mbedtls_mpi_uint) 0xB7 << 24) | ((mbedtls_mpi_uint) 0x81 << 32) | ((mbedtls_mpi_uint) 0x3A << 40) | ((mbedtls_mpi_uint) 0xA6 << 48) | ((mbedtls_mpi_uint) 0xA2 << 56), ((mbedtls_mpi_uint) 0xFF << 0) | ((mbedtls_mpi_uint) 0x45 << 8) | ((mbedtls_mpi_uint) 0xCF << 16) | ((mbedtls_mpi_uint) 0x68 << 24) | ((mbedtls_mpi_uint) 0xF0 << 32) | ((mbedtls_mpi_uint) 0x64 << 40) | ((mbedtls_mpi_uint) 0x1C << 48) | ((mbedtls_mpi_uint) 0x1D << 56),
};
static const mbedtls_mpi_ui32 brainpoolP384r1_gy[] =
{
	((mbedtls_mpi_uint) 0x15 << 0) | ((mbedtls_mpi_uint) 0x53 << 8) | ((mbedtls_mpi_uint) 0x3C << 16) | ((mbedtls_mpi_uint) 0x26 << 24) | ((mbedtls_mpi_uint) 0x41 << 32) | ((mbedtls_mpi_uint) 0x03 << 40) | ((mbedtls_mpi_uint) 0x82 << 48) | ((mbedtls_mpi_uint) 0x42 << 56), ((mbedtls_mpi_uint) 0x11 << 0) | ((mbedtls_mpi_uint) 0x81 << 8) | ((mbedtls_mpi_uint) 0x91 << 16) | ((mbedtls_mpi_uint) 0x77 << 24) | ((mbedtls_mpi_uint) 0x21 << 32) | ((mbedtls_mpi_uint) 0x46 << 40) | ((mbedtls_mpi_uint) 0x46 << 48) | ((mbedtls_mpi_uint) 0x0E << 56), ((mbedtls_mpi_uint) 0x28 << 0) | ((mbedtls_mpi_uint) 0x29 << 8) | ((mbedtls_mpi_uint) 0x91 << 16) | ((mbedtls_mpi_uint) 0xF9 << 24) | ((mbedtls_mpi_uint) 0x4F << 32) | ((mbedtls_mpi_uint) 0x05 << 40) | ((mbedtls_mpi_uint) 0x9C << 48) | ((mbedtls_mpi_uint) 0xE1 << 56), ((mbedtls_mpi_uint) 0x64 << 0) | ((mbedtls_mpi_uint) 0x58 << 8) | ((mbedtls_mpi_uint) 0xEC << 16) | ((mbedtls_mpi_uint) 0xFE << 24) | ((mbedtls_mpi_uint) 0x29 << 32) | ((mbedtls_mpi_uint) 0x0B << 40) | ((mbedtls_mpi_uint) 0xB7 << 48) | ((mbedtls_mpi_uint) 0x62 << 56), ((mbedtls_mpi_uint) 0x52 << 0) | ((mbedtls_mpi_uint) 0xD5 << 8) | ((mbedtls_mpi_uint) 0xCF << 16) | ((mbedtls_mpi_uint) 0x95 << 24) | ((mbedtls_mpi_uint) 0x8E << 32) | ((mbedtls_mpi_uint) 0xEB << 40) | ((mbedtls_mpi_uint) 0xB1 << 48) | ((mbedtls_mpi_uint) 0x5C << 56), ((mbedtls_mpi_uint) 0xA4 << 0) | ((mbedtls_mpi_uint) 0xC2 << 8) | ((mbedtls_mpi_uint) 0xF9 << 16) | ((mbedtls_mpi_uint) 0x20 << 24) | ((mbedtls_mpi_uint) 0x75 << 32) | ((mbedtls_mpi_uint) 0x1D << 40) | ((mbedtls_mpi_uint) 0xBE << 48) | ((mbedtls_mpi_uint) 0x8A << 56),
};
static const mbedtls_mpi_ui32 brainpoolP384r1_n[] =
{
	((mbedtls_mpi_uint) 0x65 << 0) | ((mbedtls_mpi_uint) 0x65 << 8) | ((mbedtls_mpi_uint) 0x04 << 16) | ((mbedtls_mpi_uint) 0xE9 << 24) | ((mbedtls_mpi_uint) 0x02 << 32) | ((mbedtls_mpi_uint) 0x32 << 40) | ((mbedtls_mpi_uint) 0x88 << 48) | ((mbedtls_mpi_uint) 0x3B << 56), ((mbedtls_mpi_uint) 0x10 << 0) | ((mbedtls_mpi_uint) 0xC3 << 8) | ((mbedtls_mpi_uint) 0x7F << 16) | ((mbedtls_mpi_uint) 0x6B << 24) | ((mbedtls_mpi_uint) 0xAF << 32) | ((mbedtls_mpi_uint) 0xB6 << 40) | ((mbedtls_mpi_uint) 0x3A << 48) | ((mbedtls_mpi_uint) 0xCF << 56), ((mbedtls_mpi_uint) 0xA7 << 0) | ((mbedtls_mpi_uint) 0x25 << 8) | ((mbedtls_mpi_uint) 0x04 << 16) | ((mbedtls_mpi_uint) 0xAC << 24) | ((mbedtls_mpi_uint) 0x6C << 32) | ((mbedtls_mpi_uint) 0x6E << 40) | ((mbedtls_mpi_uint) 0x16 << 48) | ((mbedtls_mpi_uint) 0x1F << 56), ((mbedtls_mpi_uint) 0xB3 << 0) | ((mbedtls_mpi_uint) 0x56 << 8) | ((mbedtls_mpi_uint) 0x54 << 16) | ((mbedtls_mpi_uint) 0xED << 24) | ((mbedtls_mpi_uint) 0x09 << 32) | ((mbedtls_mpi_uint) 0x71 << 40) | ((mbedtls_mpi_uint) 0x2F << 48) | ((mbedtls_mpi_uint) 0x15 << 56), ((mbedtls_mpi_uint) 0xDF << 0) | ((mbedtls_mpi_uint) 0x41 << 8) | ((mbedtls_mpi_uint) 0xE6 << 16) | ((mbedtls_mpi_uint) 0x50 << 24) | ((mbedtls_mpi_uint) 0x7E << 32) | ((mbedtls_mpi_uint) 0x6F << 40) | ((mbedtls_mpi_uint) 0x5D << 48) | ((mbedtls_mpi_uint) 0x0F << 56), ((mbedtls_mpi_uint) 0x28 << 0) | ((mbedtls_mpi_uint) 0x6D << 8) | ((mbedtls_mpi_uint) 0x38 << 16) | ((mbedtls_mpi_uint) 0xA3 << 24) | ((mbedtls_mpi_uint) 0x82 << 32) | ((mbedtls_mpi_uint) 0x1E << 40) | ((mbedtls_mpi_uint) 0xB9 << 48) | ((mbedtls_mpi_uint) 0x8C << 56),
};
static const mbedtls_mpi_ui32 brainpoolP512r1_p[] =
{
	((mbedtls_mpi_uint) 0xF3 << 0) | ((mbedtls_mpi_uint) 0x48 << 8) | ((mbedtls_mpi_uint) 0x3A << 16) | ((mbedtls_mpi_uint) 0x58 << 24) | ((mbedtls_mpi_uint) 0x56 << 32) | ((mbedtls_mpi_uint) 0x60 << 40) | ((mbedtls_mpi_uint) 0xAA << 48) | ((mbedtls_mpi_uint) 0x28 << 56), ((mbedtls_mpi_uint) 0x85 << 0) | ((mbedtls_mpi_uint) 0xC6 << 8) | ((mbedtls_mpi_uint) 0x82 << 16) | ((mbedtls_mpi_uint) 0x2D << 24) | ((mbedtls_mpi_uint) 0x2F << 32) | ((mbedtls_mpi_uint) 0xFF << 40) | ((mbedtls_mpi_uint) 0x81 << 48) | ((mbedtls_mpi_uint) 0x28 << 56), ((mbedtls_mpi_uint) 0xE6 << 0) | ((mbedtls_mpi_uint) 0x80 << 8) | ((mbedtls_mpi_uint) 0xA3 << 16) | ((mbedtls_mpi_uint) 0xE6 << 24) | ((mbedtls_mpi_uint) 0x2A << 32) | ((mbedtls_mpi_uint) 0xA1 << 40) | ((mbedtls_mpi_uint) 0xCD << 48) | ((mbedtls_mpi_uint) 0xAE << 56), ((mbedtls_mpi_uint) 0x42 << 0) | ((mbedtls_mpi_uint) 0x68 << 8) | ((mbedtls_mpi_uint) 0xC6 << 16) | ((mbedtls_mpi_uint) 0x9B << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0x9B << 40) | ((mbedtls_mpi_uint) 0x4D << 48) | ((mbedtls_mpi_uint) 0x7D << 56), ((mbedtls_mpi_uint) 0x71 << 0) | ((mbedtls_mpi_uint) 0x08 << 8) | ((mbedtls_mpi_uint) 0x33 << 16) | ((mbedtls_mpi_uint) 0x70 << 24) | ((mbedtls_mpi_uint) 0xCA << 32) | ((mbedtls_mpi_uint) 0x9C << 40) | ((mbedtls_mpi_uint) 0x63 << 48) | ((mbedtls_mpi_uint) 0xD6 << 56), ((mbedtls_mpi_uint) 0x0E << 0) | ((mbedtls_mpi_uint) 0xD2 << 8) | ((mbedtls_mpi_uint) 0xC9 << 16) | ((mbedtls_mpi_uint) 0xB3 << 24) | ((mbedtls_mpi_uint) 0xB3 << 32) | ((mbedtls_mpi_uint) 0x8D << 40) | ((mbedtls_mpi_uint) 0x30 << 48) | ((mbedtls_mpi_uint) 0xCB << 56), ((mbedtls_mpi_uint) 0x07 << 0) | ((mbedtls_mpi_uint) 0xFC << 8) | ((mbedtls_mpi_uint) 0xC9 << 16) | ((mbedtls_mpi_uint) 0x33 << 24) | ((mbedtls_mpi_uint) 0xAE << 32) | ((mbedtls_mpi_uint) 0xE6 << 40) | ((mbedtls_mpi_uint) 0xD4 << 48) | ((mbedtls_mpi_uint) 0x3F << 56), ((mbedtls_mpi_uint) 0x8B << 0) | ((mbedtls_mpi_uint) 0xC4 << 8) | ((mbedtls_mpi_uint) 0xE9 << 16) | ((mbedtls_mpi_uint) 0xDB << 24) | ((mbedtls_mpi_uint) 0xB8 << 32) | ((mbedtls_mpi_uint) 0x9D << 40) | ((mbedtls_mpi_uint) 0xDD << 48) | ((mbedtls_mpi_uint) 0xAA << 56),
};
static const mbedtls_mpi_ui32 brainpoolP512r1_a[] =
{
	((mbedtls_mpi_uint) 0xCA << 0) | ((mbedtls_mpi_uint) 0x94 << 8) | ((mbedtls_mpi_uint) 0xFC << 16) | ((mbedtls_mpi_uint) 0x77 << 24) | ((mbedtls_mpi_uint) 0x4D << 32) | ((mbedtls_mpi_uint) 0xAC << 40) | ((mbedtls_mpi_uint) 0xC1 << 48) | ((mbedtls_mpi_uint) 0xE7 << 56), ((mbedtls_mpi_uint) 0xB9 << 0) | ((mbedtls_mpi_uint) 0xC7 << 8) | ((mbedtls_mpi_uint) 0xF2 << 16) | ((mbedtls_mpi_uint) 0x2B << 24) | ((mbedtls_mpi_uint) 0xA7 << 32) | ((mbedtls_mpi_uint) 0x17 << 40) | ((mbedtls_mpi_uint) 0x11 << 48) | ((mbedtls_mpi_uint) 0x7F << 56), ((mbedtls_mpi_uint) 0xB5 << 0) | ((mbedtls_mpi_uint) 0xC8 << 8) | ((mbedtls_mpi_uint) 0x9A << 16) | ((mbedtls_mpi_uint) 0x8B << 24) | ((mbedtls_mpi_uint) 0xC9 << 32) | ((mbedtls_mpi_uint) 0xF1 << 40) | ((mbedtls_mpi_uint) 0x2E << 48) | ((mbedtls_mpi_uint) 0x0A << 56), ((mbedtls_mpi_uint) 0xA1 << 0) | ((mbedtls_mpi_uint) 0x3A << 8) | ((mbedtls_mpi_uint) 0x25 << 16) | ((mbedtls_mpi_uint) 0xA8 << 24) | ((mbedtls_mpi_uint) 0x5A << 32) | ((mbedtls_mpi_uint) 0x5D << 40) | ((mbedtls_mpi_uint) 0xED << 48) | ((mbedtls_mpi_uint) 0x2D << 56), ((mbedtls_mpi_uint) 0xBC << 0) | ((mbedtls_mpi_uint) 0x63 << 8) | ((mbedtls_mpi_uint) 0x98 << 16) | ((mbedtls_mpi_uint) 0xEA << 24) | ((mbedtls_mpi_uint) 0xCA << 32) | ((mbedtls_mpi_uint) 0x41 << 40) | ((mbedtls_mpi_uint) 0x34 << 48) | ((mbedtls_mpi_uint) 0xA8 << 56), ((mbedtls_mpi_uint) 0x10 << 0) | ((mbedtls_mpi_uint) 0x16 << 8) | ((mbedtls_mpi_uint) 0xF9 << 16) | ((mbedtls_mpi_uint) 0x3D << 24) | ((mbedtls_mpi_uint) 0x8D << 32) | ((mbedtls_mpi_uint) 0xDD << 40) | ((mbedtls_mpi_uint) 0xCB << 48) | ((mbedtls_mpi_uint) 0x94 << 56), ((mbedtls_mpi_uint) 0xC5 << 0) | ((mbedtls_mpi_uint) 0x4C << 8) | ((mbedtls_mpi_uint) 0x23 << 16) | ((mbedtls_mpi_uint) 0xAC << 24) | ((mbedtls_mpi_uint) 0x45 << 32) | ((mbedtls_mpi_uint) 0x71 << 40) | ((mbedtls_mpi_uint) 0x32 << 48) | ((mbedtls_mpi_uint) 0xE2 << 56), ((mbedtls_mpi_uint) 0x89 << 0) | ((mbedtls_mpi_uint) 0x3B << 8) | ((mbedtls_mpi_uint) 0x60 << 16) | ((mbedtls_mpi_uint) 0x8B << 24) | ((mbedtls_mpi_uint) 0x31 << 32) | ((mbedtls_mpi_uint) 0xA3 << 40) | ((mbedtls_mpi_uint) 0x30 << 48) | ((mbedtls_mpi_uint) 0x78 << 56),
};
static const mbedtls_mpi_ui32 brainpoolP512r1_b[] =
{
	((mbedtls_mpi_uint) 0x23 << 0) | ((mbedtls_mpi_uint) 0xF7 << 8) | ((mbedtls_mpi_uint) 0x16 << 16) | ((mbedtls_mpi_uint) 0x80 << 24) | ((mbedtls_mpi_uint) 0x63 << 32) | ((mbedtls_mpi_uint) 0xBD << 40) | ((mbedtls_mpi_uint) 0x09 << 48) | ((mbedtls_mpi_uint) 0x28 << 56), ((mbedtls_mpi_uint) 0xDD << 0) | ((mbedtls_mpi_uint) 0xE5 << 8) | ((mbedtls_mpi_uint) 0xBA << 16) | ((mbedtls_mpi_uint) 0x5E << 24) | ((mbedtls_mpi_uint) 0xB7 << 32) | ((mbedtls_mpi_uint) 0x50 << 40) | ((mbedtls_mpi_uint) 0x40 << 48) | ((mbedtls_mpi_uint) 0x98 << 56), ((mbedtls_mpi_uint) 0x67 << 0) | ((mbedtls_mpi_uint) 0x3E << 8) | ((mbedtls_mpi_uint) 0x08 << 16) | ((mbedtls_mpi_uint) 0xDC << 24) | ((mbedtls_mpi_uint) 0xCA << 32) | ((mbedtls_mpi_uint) 0x94 << 40) | ((mbedtls_mpi_uint) 0xFC << 48) | ((mbedtls_mpi_uint) 0x77 << 56), ((mbedtls_mpi_uint) 0x4D << 0) | ((mbedtls_mpi_uint) 0xAC << 8) | ((mbedtls_mpi_uint) 0xC1 << 16) | ((mbedtls_mpi_uint) 0xE7 << 24) | ((mbedtls_mpi_uint) 0xB9 << 32) | ((mbedtls_mpi_uint) 0xC7 << 40) | ((mbedtls_mpi_uint) 0xF2 << 48) | ((mbedtls_mpi_uint) 0x2B << 56), ((mbedtls_mpi_uint) 0xA7 << 0) | ((mbedtls_mpi_uint) 0x17 << 8) | ((mbedtls_mpi_uint) 0x11 << 16) | ((mbedtls_mpi_uint) 0x7F << 24) | ((mbedtls_mpi_uint) 0xB5 << 32) | ((mbedtls_mpi_uint) 0xC8 << 40) | ((mbedtls_mpi_uint) 0x9A << 48) | ((mbedtls_mpi_uint) 0x8B << 56), ((mbedtls_mpi_uint) 0xC9 << 0) | ((mbedtls_mpi_uint) 0xF1 << 8) | ((mbedtls_mpi_uint) 0x2E << 16) | ((mbedtls_mpi_uint) 0x0A << 24) | ((mbedtls_mpi_uint) 0xA1 << 32) | ((mbedtls_mpi_uint) 0x3A << 40) | ((mbedtls_mpi_uint) 0x25 << 48) | ((mbedtls_mpi_uint) 0xA8 << 56), ((mbedtls_mpi_uint) 0x5A << 0) | ((mbedtls_mpi_uint) 0x5D << 8) | ((mbedtls_mpi_uint) 0xED << 16) | ((mbedtls_mpi_uint) 0x2D << 24) | ((mbedtls_mpi_uint) 0xBC << 32) | ((mbedtls_mpi_uint) 0x63 << 40) | ((mbedtls_mpi_uint) 0x98 << 48) | ((mbedtls_mpi_uint) 0xEA << 56), ((mbedtls_mpi_uint) 0xCA << 0) | ((mbedtls_mpi_uint) 0x41 << 8) | ((mbedtls_mpi_uint) 0x34 << 16) | ((mbedtls_mpi_uint) 0xA8 << 24) | ((mbedtls_mpi_uint) 0x10 << 32) | ((mbedtls_mpi_uint) 0x16 << 40) | ((mbedtls_mpi_uint) 0xF9 << 48) | ((mbedtls_mpi_uint) 0x3D << 56),
};
static const mbedtls_mpi_ui32 brainpoolP512r1_gx[] =
{
	((mbedtls_mpi_uint) 0x22 << 0) | ((mbedtls_mpi_uint) 0xF8 << 8) | ((mbedtls_mpi_uint) 0xB9 << 16) | ((mbedtls_mpi_uint) 0xBC << 24) | ((mbedtls_mpi_uint) 0x09 << 32) | ((mbedtls_mpi_uint) 0x22 << 40) | ((mbedtls_mpi_uint) 0x35 << 48) | ((mbedtls_mpi_uint) 0x8B << 56), ((mbedtls_mpi_uint) 0x68 << 0) | ((mbedtls_mpi_uint) 0x5E << 8) | ((mbedtls_mpi_uint) 0x6A << 16) | ((mbedtls_mpi_uint) 0x40 << 24) | ((mbedtls_mpi_uint) 0x47 << 32) | ((mbedtls_mpi_uint) 0x50 << 40) | ((mbedtls_mpi_uint) 0x6D << 48) | ((mbedtls_mpi_uint) 0x7C << 56), ((mbedtls_mpi_uint) 0x5F << 0) | ((mbedtls_mpi_uint) 0x7D << 8) | ((mbedtls_mpi_uint) 0xB9 << 16) | ((mbedtls_mpi_uint) 0x93 << 24) | ((mbedtls_mpi_uint) 0x7B << 32) | ((mbedtls_mpi_uint) 0x68 << 40) | ((mbedtls_mpi_uint) 0xD1 << 48) | ((mbedtls_mpi_uint) 0x50 << 56), ((mbedtls_mpi_uint) 0x8D << 0) | ((mbedtls_mpi_uint) 0xD4 << 8) | ((mbedtls_mpi_uint) 0xD0 << 16) | ((mbedtls_mpi_uint) 0xE2 << 24) | ((mbedtls_mpi_uint) 0x78 << 32) | ((mbedtls_mpi_uint) 0x1F << 40) | ((mbedtls_mpi_uint) 0x3B << 48) | ((mbedtls_mpi_uint) 0xFF << 56), ((mbedtls_mpi_uint) 0x8E << 0) | ((mbedtls_mpi_uint) 0x09 << 8) | ((mbedtls_mpi_uint) 0xD0 << 16) | ((mbedtls_mpi_uint) 0xF4 << 24) | ((mbedtls_mpi_uint) 0xEE << 32) | ((mbedtls_mpi_uint) 0x62 << 40) | ((mbedtls_mpi_uint) 0x3B << 48) | ((mbedtls_mpi_uint) 0xB4 << 56), ((mbedtls_mpi_uint) 0xC1 << 0) | ((mbedtls_mpi_uint) 0x16 << 8) | ((mbedtls_mpi_uint) 0xD9 << 16) | ((mbedtls_mpi_uint) 0xB5 << 24) | ((mbedtls_mpi_uint) 0x70 << 32) | ((mbedtls_mpi_uint) 0x9F << 40) | ((mbedtls_mpi_uint) 0xED << 48) | ((mbedtls_mpi_uint) 0x85 << 56), ((mbedtls_mpi_uint) 0x93 << 0) | ((mbedtls_mpi_uint) 0x6A << 8) | ((mbedtls_mpi_uint) 0x4C << 16) | ((mbedtls_mpi_uint) 0x9C << 24) | ((mbedtls_mpi_uint) 0x2E << 32) | ((mbedtls_mpi_uint) 0x32 << 40) | ((mbedtls_mpi_uint) 0x21 << 48) | ((mbedtls_mpi_uint) 0x5A << 56), ((mbedtls_mpi_uint) 0x64 << 0) | ((mbedtls_mpi_uint) 0xD9 << 8) | ((mbedtls_mpi_uint) 0x2E << 16) | ((mbedtls_mpi_uint) 0xD8 << 24) | ((mbedtls_mpi_uint) 0xBD << 32) | ((mbedtls_mpi_uint) 0xE4 << 40) | ((mbedtls_mpi_uint) 0xAE << 48) | ((mbedtls_mpi_uint) 0x81 << 56),
};
static const mbedtls_mpi_ui32 brainpoolP512r1_gy[] =
{
	((mbedtls_mpi_uint) 0x92 << 0) | ((mbedtls_mpi_uint) 0x08 << 8) | ((mbedtls_mpi_uint) 0xD8 << 16) | ((mbedtls_mpi_uint) 0x3A << 24) | ((mbedtls_mpi_uint) 0x0F << 32) | ((mbedtls_mpi_uint) 0x1E << 40) | ((mbedtls_mpi_uint) 0xCD << 48) | ((mbedtls_mpi_uint) 0x78 << 56), ((mbedtls_mpi_uint) 0x06 << 0) | ((mbedtls_mpi_uint) 0x54 << 8) | ((mbedtls_mpi_uint) 0xF0 << 16) | ((mbedtls_mpi_uint) 0xA8 << 24) | ((mbedtls_mpi_uint) 0x2F << 32) | ((mbedtls_mpi_uint) 0x2B << 40) | ((mbedtls_mpi_uint) 0xCA << 48) | ((mbedtls_mpi_uint) 0xD1 << 56), ((mbedtls_mpi_uint) 0xAE << 0) | ((mbedtls_mpi_uint) 0x63 << 8) | ((mbedtls_mpi_uint) 0x27 << 16) | ((mbedtls_mpi_uint) 0x8A << 24) | ((mbedtls_mpi_uint) 0xD8 << 32) | ((mbedtls_mpi_uint) 0x4B << 40) | ((mbedtls_mpi_uint) 0xCA << 48) | ((mbedtls_mpi_uint) 0x5B << 56), ((mbedtls_mpi_uint) 0x5E << 0) | ((mbedtls_mpi_uint) 0x48 << 8) | ((mbedtls_mpi_uint) 0x5F << 16) | ((mbedtls_mpi_uint) 0x4A << 24) | ((mbedtls_mpi_uint) 0x49 << 32) | ((mbedtls_mpi_uint) 0xDE << 40) | ((mbedtls_mpi_uint) 0xDC << 48) | ((mbedtls_mpi_uint) 0xB2 << 56), ((mbedtls_mpi_uint) 0x11 << 0) | ((mbedtls_mpi_uint) 0x81 << 8) | ((mbedtls_mpi_uint) 0x1F << 16) | ((mbedtls_mpi_uint) 0x88 << 24) | ((mbedtls_mpi_uint) 0x5B << 32) | ((mbedtls_mpi_uint) 0xC5 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0xA0 << 56), ((mbedtls_mpi_uint) 0x1A << 0) | ((mbedtls_mpi_uint) 0x7B << 8) | ((mbedtls_mpi_uint) 0xA5 << 16) | ((mbedtls_mpi_uint) 0x24 << 24) | ((mbedtls_mpi_uint) 0x00 << 32) | ((mbedtls_mpi_uint) 0xF7 << 40) | ((mbedtls_mpi_uint) 0x09 << 48) | ((mbedtls_mpi_uint) 0xF2 << 56), ((mbedtls_mpi_uint) 0xFD << 0) | ((mbedtls_mpi_uint) 0x22 << 8) | ((mbedtls_mpi_uint) 0x78 << 16) | ((mbedtls_mpi_uint) 0xCF << 24) | ((mbedtls_mpi_uint) 0xA9 << 32) | ((mbedtls_mpi_uint) 0xBF << 40) | ((mbedtls_mpi_uint) 0xEA << 48) | ((mbedtls_mpi_uint) 0xC0 << 56), ((mbedtls_mpi_uint) 0xEC << 0) | ((mbedtls_mpi_uint) 0x32 << 8) | ((mbedtls_mpi_uint) 0x63 << 16) | ((mbedtls_mpi_uint) 0x56 << 24) | ((mbedtls_mpi_uint) 0x5D << 32) | ((mbedtls_mpi_uint) 0x38 << 40) | ((mbedtls_mpi_uint) 0xDE << 48) | ((mbedtls_mpi_uint) 0x7D << 56),
};
static const mbedtls_mpi_ui32 brainpoolP512r1_n[] =
{
	((mbedtls_mpi_uint) 0x69 << 0) | ((mbedtls_mpi_uint) 0x00 << 8) | ((mbedtls_mpi_uint) 0xA9 << 16) | ((mbedtls_mpi_uint) 0x9C << 24) | ((mbedtls_mpi_uint) 0x82 << 32) | ((mbedtls_mpi_uint) 0x96 << 40) | ((mbedtls_mpi_uint) 0x87 << 48) | ((mbedtls_mpi_uint) 0xB5 << 56), ((mbedtls_mpi_uint) 0xDD << 0) | ((mbedtls_mpi_uint) 0xDA << 8) | ((mbedtls_mpi_uint) 0x5D << 16) | ((mbedtls_mpi_uint) 0x08 << 24) | ((mbedtls_mpi_uint) 0x81 << 32) | ((mbedtls_mpi_uint) 0xD3 << 40) | ((mbedtls_mpi_uint) 0xB1 << 48) | ((mbedtls_mpi_uint) 0x1D << 56), ((mbedtls_mpi_uint) 0x47 << 0) | ((mbedtls_mpi_uint) 0x10 << 8) | ((mbedtls_mpi_uint) 0xAC << 16) | ((mbedtls_mpi_uint) 0x7F << 24) | ((mbedtls_mpi_uint) 0x19 << 32) | ((mbedtls_mpi_uint) 0x61 << 40) | ((mbedtls_mpi_uint) 0x86 << 48) | ((mbedtls_mpi_uint) 0x41 << 56), ((mbedtls_mpi_uint) 0x19 << 0) | ((mbedtls_mpi_uint) 0x26 << 8) | ((mbedtls_mpi_uint) 0xA9 << 16) | ((mbedtls_mpi_uint) 0x4C << 24) | ((mbedtls_mpi_uint) 0x41 << 32) | ((mbedtls_mpi_uint) 0x5C << 40) | ((mbedtls_mpi_uint) 0x3E << 48) | ((mbedtls_mpi_uint) 0x55 << 56), ((mbedtls_mpi_uint) 0x70 << 0) | ((mbedtls_mpi_uint) 0x08 << 8) | ((mbedtls_mpi_uint) 0x33 << 16) | ((mbedtls_mpi_uint) 0x70 << 24) | ((mbedtls_mpi_uint) 0xCA << 32) | ((mbedtls_mpi_uint) 0x9C << 40) | ((mbedtls_mpi_uint) 0x63 << 48) | ((mbedtls_mpi_uint) 0xD6 << 56), ((mbedtls_mpi_uint) 0x0E << 0) | ((mbedtls_mpi_uint) 0xD2 << 8) | ((mbedtls_mpi_uint) 0xC9 << 16) | ((mbedtls_mpi_uint) 0xB3 << 24) | ((mbedtls_mpi_uint) 0xB3 << 32) | ((mbedtls_mpi_uint) 0x8D << 40) | ((mbedtls_mpi_uint) 0x30 << 48) | ((mbedtls_mpi_uint) 0xCB << 56), ((mbedtls_mpi_uint) 0x07 << 0) | ((mbedtls_mpi_uint) 0xFC << 8) | ((mbedtls_mpi_uint) 0xC9 << 16) | ((mbedtls_mpi_uint) 0x33 << 24) | ((mbedtls_mpi_uint) 0xAE << 32) | ((mbedtls_mpi_uint) 0xE6 << 40) | ((mbedtls_mpi_uint) 0xD4 << 48) | ((mbedtls_mpi_uint) 0x3F << 56), ((mbedtls_mpi_uint) 0x8B << 0) | ((mbedtls_mpi_uint) 0xC4 << 8) | ((mbedtls_mpi_uint) 0xE9 << 16) | ((mbedtls_mpi_uint) 0xDB << 24) | ((mbedtls_mpi_uint) 0xB8 << 32) | ((mbedtls_mpi_uint) 0x9D << 40) | ((mbedtls_mpi_uint) 0xDD << 48) | ((mbedtls_mpi_uint) 0xAA << 56),
};
fn void ecp_mpi_load(mbedtls_mpi * X, const mbedtls_mpi_ui32 * p, usize len) -> inline
{
	X.s = 1;
	X.n = len / sizeof(mbedtls_mpi_uint);
	X.p = (mbedtls_mpi_ui32 *) p;
}

fn void ecp_mpi_set1(mbedtls_mpi * X) -> inline
{
	static mbedtls_mpi_ui32 one[] = {1};
	X.s = 1;
	X.n = 1;
	X.p = one;
}

fn ecp_group_load(mbedtls_ecp_group * grp, const mbedtls_mpi_ui32 * p, usize plen, const mbedtls_mpi_ui32 * a, usize alen, const mbedtls_mpi_ui32 * b, usize blen, const mbedtls_mpi_ui32 * gx, usize gxlen, const mbedtls_mpi_ui32 * gy, usize gylen, const mbedtls_mpi_ui32 * n, usize nlen) -> i32
{
	ecp_mpi_load(&grp.P, p, plen);
	if a != NULL
	{
		ecp_mpi_load(&grp.A, a, alen);
	}
	ecp_mpi_load(&grp.B, b, blen);
	ecp_mpi_load(&grp.N, n, nlen);
	ecp_mpi_load(&grp.G.X, gx, gxlen);
	ecp_mpi_load(&grp.G.Y, gy, gylen);
	ecp_mpi_set1(&grp.G.Z);
	grp.pbits = mbedtls_mpi_bitlen(&grp.P);
	grp.nbits = mbedtls_mpi_bitlen(&grp.N);
	grp.h = 1;
	return 0;
}

fn ecp_use_curve25519(mbedtls_ecp_group * grp) -> i32
{
	i32 ret;
	do
	{
		if (ret = mbedtls_mpi_read_string(&grp.A, 16, "01DB42")) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&grp.P, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_shift_l(&grp.P, 255)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_int(&grp.P, &grp.P, 19)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	grp.pbits = mbedtls_mpi_bitlen(&grp.P);
	do
	{
		if (ret = mbedtls_mpi_lset(&grp.G.X, 9)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_lset(&grp.G.Z, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	mbedtls_mpi_free(&grp.G.Y);
	grp.nbits = 254;
cleanup:
	if ret != 0
	{
		mbedtls_ecp_group_free(grp);
	}
	return ret;
}

pub fn mbedtls_ecp_group_load(mbedtls_ecp_group * grp, mbedtls_ecp_group_id id) -> i32
{
	mbedtls_ecp_group_free(grp);
	grp.id = id;
	switch (id)
	{
		case MBEDTLS_ECP_DP_SECP192R1:
		grp.modp = ecp_mod_p192;
		;
		return ecp_group_load(grp, secp192r1_p, sizeof(secp192r1_p), NULL, 0, secp192r1_b, sizeof(secp192r1_b), secp192r1_gx, sizeof(secp192r1_gx), secp192r1_gy, sizeof(secp192r1_gy), secp192r1_n, sizeof(secp192r1_n));
		case MBEDTLS_ECP_DP_SECP224R1:
		grp.modp = ecp_mod_p224;
		;
		return ecp_group_load(grp, secp224r1_p, sizeof(secp224r1_p), NULL, 0, secp224r1_b, sizeof(secp224r1_b), secp224r1_gx, sizeof(secp224r1_gx), secp224r1_gy, sizeof(secp224r1_gy), secp224r1_n, sizeof(secp224r1_n));
		case MBEDTLS_ECP_DP_SECP256R1:
		grp.modp = ecp_mod_p256;
		;
		return ecp_group_load(grp, secp256r1_p, sizeof(secp256r1_p), NULL, 0, secp256r1_b, sizeof(secp256r1_b), secp256r1_gx, sizeof(secp256r1_gx), secp256r1_gy, sizeof(secp256r1_gy), secp256r1_n, sizeof(secp256r1_n));
		case MBEDTLS_ECP_DP_SECP384R1:
		grp.modp = ecp_mod_p384;
		;
		return ecp_group_load(grp, secp384r1_p, sizeof(secp384r1_p), NULL, 0, secp384r1_b, sizeof(secp384r1_b), secp384r1_gx, sizeof(secp384r1_gx), secp384r1_gy, sizeof(secp384r1_gy), secp384r1_n, sizeof(secp384r1_n));
		case MBEDTLS_ECP_DP_SECP521R1:
		grp.modp = ecp_mod_p521;
		;
		return ecp_group_load(grp, secp521r1_p, sizeof(secp521r1_p), NULL, 0, secp521r1_b, sizeof(secp521r1_b), secp521r1_gx, sizeof(secp521r1_gx), secp521r1_gy, sizeof(secp521r1_gy), secp521r1_n, sizeof(secp521r1_n));
		case MBEDTLS_ECP_DP_SECP192K1:
		grp.modp = ecp_mod_p192k1;
		return ecp_group_load(grp, secp192k1_p, sizeof(secp192k1_p), secp192k1_a, sizeof(secp192k1_a), secp192k1_b, sizeof(secp192k1_b), secp192k1_gx, sizeof(secp192k1_gx), secp192k1_gy, sizeof(secp192k1_gy), secp192k1_n, sizeof(secp192k1_n));
		case MBEDTLS_ECP_DP_SECP224K1:
		grp.modp = ecp_mod_p224k1;
		return ecp_group_load(grp, secp224k1_p, sizeof(secp224k1_p), secp224k1_a, sizeof(secp224k1_a), secp224k1_b, sizeof(secp224k1_b), secp224k1_gx, sizeof(secp224k1_gx), secp224k1_gy, sizeof(secp224k1_gy), secp224k1_n, sizeof(secp224k1_n));
		case MBEDTLS_ECP_DP_SECP256K1:
		grp.modp = ecp_mod_p256k1;
		return ecp_group_load(grp, secp256k1_p, sizeof(secp256k1_p), secp256k1_a, sizeof(secp256k1_a), secp256k1_b, sizeof(secp256k1_b), secp256k1_gx, sizeof(secp256k1_gx), secp256k1_gy, sizeof(secp256k1_gy), secp256k1_n, sizeof(secp256k1_n));
		case MBEDTLS_ECP_DP_BP256R1:
		return ecp_group_load(grp, brainpoolP256r1_p, sizeof(brainpoolP256r1_p), brainpoolP256r1_a, sizeof(brainpoolP256r1_a), brainpoolP256r1_b, sizeof(brainpoolP256r1_b), brainpoolP256r1_gx, sizeof(brainpoolP256r1_gx), brainpoolP256r1_gy, sizeof(brainpoolP256r1_gy), brainpoolP256r1_n, sizeof(brainpoolP256r1_n));
		case MBEDTLS_ECP_DP_BP384R1:
		return ecp_group_load(grp, brainpoolP384r1_p, sizeof(brainpoolP384r1_p), brainpoolP384r1_a, sizeof(brainpoolP384r1_a), brainpoolP384r1_b, sizeof(brainpoolP384r1_b), brainpoolP384r1_gx, sizeof(brainpoolP384r1_gx), brainpoolP384r1_gy, sizeof(brainpoolP384r1_gy), brainpoolP384r1_n, sizeof(brainpoolP384r1_n));
		case MBEDTLS_ECP_DP_BP512R1:
		return ecp_group_load(grp, brainpoolP512r1_p, sizeof(brainpoolP512r1_p), brainpoolP512r1_a, sizeof(brainpoolP512r1_a), brainpoolP512r1_b, sizeof(brainpoolP512r1_b), brainpoolP512r1_gx, sizeof(brainpoolP512r1_gx), brainpoolP512r1_gy, sizeof(brainpoolP512r1_gy), brainpoolP512r1_n, sizeof(brainpoolP512r1_n));
		case MBEDTLS_ECP_DP_CURVE25519:
		grp.modp = ecp_mod_p255;
		return ecp_use_curve25519(grp);
	default:
		mbedtls_ecp_group_free(grp);
		return -0x4E80;
	}
}

fn void add64(mbedtls_mpi_ui32 * dst, mbedtls_mpi_ui32 * src, mbedtls_mpi_ui32 * carry) -> inline
{
	u8 i;
	mbedtls_mpi_ui32 c = 0;
	for (i = 0; i < 8 / sizeof(mbedtls_mpi_uint); i++, dst++, src++)
	{
		*dst += c;
		c = (*dst < c);
		*dst += *src;
		c += (*dst < *src);
	}
	*carry += c;
}

fn void carry64(mbedtls_mpi_ui32 * dst, mbedtls_mpi_ui32 * carry) -> inline
{
	u8 i;
	for (i = 0; i < 8 / sizeof(mbedtls_mpi_uint); i++, dst++)
	{
		*dst += *carry;
		*carry = (*dst < *carry);
	}
}

fn ecp_mod_p192(mbedtls_mpi * N) -> i32
{
	i32 ret;
	mbedtls_mpi_ui32 c = 0;
	mbedtls_mpi_ui32 *p, *end;
	do
	{
		if (ret = mbedtls_mpi_grow(N, 6 * 8 / sizeof(mbedtls_mpi_uint))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	p = N.p;
	end = p + N.n;
	add64(p, N.p + 3 * 8 / sizeof(mbedtls_mpi_uint), &c);
	add64(p, N.p + 5 * 8 / sizeof(mbedtls_mpi_uint), &c);
	p += 8 / sizeof(mbedtls_mpi_uint);
	carry64(p, &c);
	add64(p, N.p + 3 * 8 / sizeof(mbedtls_mpi_uint), &c);
	add64(p, N.p + 4 * 8 / sizeof(mbedtls_mpi_uint), &c);
	add64(p, N.p + 5 * 8 / sizeof(mbedtls_mpi_uint), &c);
	p += 8 / sizeof(mbedtls_mpi_uint);
	carry64(p, &c);
	add64(p, N.p + 4 * 8 / sizeof(mbedtls_mpi_uint), &c);
	add64(p, N.p + 5 * 8 / sizeof(mbedtls_mpi_uint), &c);
	p += 8 / sizeof(mbedtls_mpi_uint);
	*p = c;
	while (++p < end)
	{
		*p = 0;
	}
cleanup:
	return ret;
}

fn void add32(u32 * dst, u32 src, i8 * carry) -> inline
{
	*dst += src;
	*carry += (*dst < src);
}

fn void sub32(u32 * dst, u32 src, i8 * carry) -> inline
{
	*carry -= (*dst < src);
	*dst -= src;
}

fn i32 fix_negative(mbedtls_mpi * N, i8 c, mbedtls_mpi * C, usize bits) -> inline
{
	i32 ret;
	if bits == 224
	{
		C.p[C.n - 1] = ((mbedtls_mpi_uint) -c) << 32;
	}
	else
	{
		C.p[C.n - 1] = (mbedtls_mpi_uint) -c;
	}
	do
	{
		if (ret = mbedtls_mpi_sub_abs(N, C, N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	N.s = -1;
cleanup:
	return ret;
}

fn ecp_mod_p224(mbedtls_mpi * N) -> i32
{
	i32 ret;
	i8 c = 0, cc;
	u32 cur;
	usize i = 0, bits = 224;
	mbedtls_mpi C;
	mbedtls_mpi_ui32 Cp[224 / 8 / sizeof(mbedtls_mpi_uint) + 1];
	C.s = 1;
	C.n = 224 / 8 / sizeof(mbedtls_mpi_uint) + 1;
	C.p = Cp;
	memset(Cp, 0, C.n * sizeof(mbedtls_mpi_uint));
	do
	{
		if (ret = mbedtls_mpi_grow(N, 224 * 2 / 8 / sizeof(mbedtls_mpi_uint))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	;
	sub32(&cur, 7 % 2 ? (u32)(N.p[7 / 2] >> 32) : (u32)(N.p[7 / 2]), &c);
	;
	sub32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	sub32(&cur, 8 % 2 ? (u32)(N.p[8 / 2] >> 32) : (u32)(N.p[8 / 2]), &c);
	;
	sub32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	sub32(&cur, 9 % 2 ? (u32)(N.p[9 / 2] >> 32) : (u32)(N.p[9 / 2]), &c);
	;
	sub32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	sub32(&cur, 10 % 2 ? (u32)(N.p[10 / 2] >> 32) : (u32)(N.p[10 / 2]), &c);
	;
	add32(&cur, 7 % 2 ? (u32)(N.p[7 / 2] >> 32) : (u32)(N.p[7 / 2]), &c);
	;
	add32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	sub32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	add32(&cur, 8 % 2 ? (u32)(N.p[8 / 2] >> 32) : (u32)(N.p[8 / 2]), &c);
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	sub32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 9 % 2 ? (u32)(N.p[9 / 2] >> 32) : (u32)(N.p[9 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	sub32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 10 % 2 ? (u32)(N.p[10 / 2] >> 32) : (u32)(N.p[10 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = c > 0 ? c : 0;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	cur = 0;
	while (++i < N.n * 2)
	{
		if i % 2
		{
			N.p[i / 2] &= 0x00000000FFFFFFFF;
			N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
		}
		else
		{
			N.p[i / 2] &= 0xFFFFFFFF00000000;
			N.p[i / 2] |= (mbedtls_mpi_uint) cur;
		};
	}
	if c < 0
	{
		fix_negative(N, c, &C, bits);
	}
	;
cleanup:
	return ret;
}

fn ecp_mod_p256(mbedtls_mpi * N) -> i32
{
	i32 ret;
	i8 c = 0, cc;
	u32 cur;
	usize i = 0, bits = 256;
	mbedtls_mpi C;
	mbedtls_mpi_ui32 Cp[256 / 8 / sizeof(mbedtls_mpi_uint) + 1];
	C.s = 1;
	C.n = 256 / 8 / sizeof(mbedtls_mpi_uint) + 1;
	C.p = Cp;
	memset(Cp, 0, C.n * sizeof(mbedtls_mpi_uint));
	do
	{
		if (ret = mbedtls_mpi_grow(N, 256 * 2 / 8 / sizeof(mbedtls_mpi_uint))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	;
	add32(&cur, 8 % 2 ? (u32)(N.p[8 / 2] >> 32) : (u32)(N.p[8 / 2]), &c);
	;
	add32(&cur, 9 % 2 ? (u32)(N.p[9 / 2] >> 32) : (u32)(N.p[9 / 2]), &c);
	;
	sub32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	sub32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	sub32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	sub32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 9 % 2 ? (u32)(N.p[9 / 2] >> 32) : (u32)(N.p[9 / 2]), &c);
	;
	add32(&cur, 10 % 2 ? (u32)(N.p[10 / 2] >> 32) : (u32)(N.p[10 / 2]), &c);
	;
	sub32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	sub32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	sub32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	sub32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 10 % 2 ? (u32)(N.p[10 / 2] >> 32) : (u32)(N.p[10 / 2]), &c);
	;
	add32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	sub32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	sub32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	sub32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	add32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	sub32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	sub32(&cur, 8 % 2 ? (u32)(N.p[8 / 2] >> 32) : (u32)(N.p[8 / 2]), &c);
	;
	sub32(&cur, 9 % 2 ? (u32)(N.p[9 / 2] >> 32) : (u32)(N.p[9 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	sub32(&cur, 9 % 2 ? (u32)(N.p[9 / 2] >> 32) : (u32)(N.p[9 / 2]), &c);
	;
	sub32(&cur, 10 % 2 ? (u32)(N.p[10 / 2] >> 32) : (u32)(N.p[10 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	sub32(&cur, 10 % 2 ? (u32)(N.p[10 / 2] >> 32) : (u32)(N.p[10 / 2]), &c);
	;
	sub32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	sub32(&cur, 8 % 2 ? (u32)(N.p[8 / 2] >> 32) : (u32)(N.p[8 / 2]), &c);
	;
	sub32(&cur, 9 % 2 ? (u32)(N.p[9 / 2] >> 32) : (u32)(N.p[9 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 8 % 2 ? (u32)(N.p[8 / 2] >> 32) : (u32)(N.p[8 / 2]), &c);
	;
	sub32(&cur, 10 % 2 ? (u32)(N.p[10 / 2] >> 32) : (u32)(N.p[10 / 2]), &c);
	;
	sub32(&cur, 11 % 2 ? (u32)(N.p[11 / 2] >> 32) : (u32)(N.p[11 / 2]), &c);
	;
	sub32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	sub32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = c > 0 ? c : 0;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	cur = 0;
	while (++i < N.n * 2)
	{
		if i % 2
		{
			N.p[i / 2] &= 0x00000000FFFFFFFF;
			N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
		}
		else
		{
			N.p[i / 2] &= 0xFFFFFFFF00000000;
			N.p[i / 2] |= (mbedtls_mpi_uint) cur;
		};
	}
	if c < 0
	{
		fix_negative(N, c, &C, bits);
	}
	;
cleanup:
	return ret;
}

fn ecp_mod_p384(mbedtls_mpi * N) -> i32
{
	i32 ret;
	i8 c = 0, cc;
	u32 cur;
	usize i = 0, bits = 384;
	mbedtls_mpi C;
	mbedtls_mpi_ui32 Cp[384 / 8 / sizeof(mbedtls_mpi_uint) + 1];
	C.s = 1;
	C.n = 384 / 8 / sizeof(mbedtls_mpi_uint) + 1;
	C.p = Cp;
	memset(Cp, 0, C.n * sizeof(mbedtls_mpi_uint));
	do
	{
		if (ret = mbedtls_mpi_grow(N, 384 * 2 / 8 / sizeof(mbedtls_mpi_uint))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	add32(&cur, 20 % 2 ? (u32)(N.p[20 / 2] >> 32) : (u32)(N.p[20 / 2]), &c);
	;
	sub32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	add32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	sub32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	sub32(&cur, 20 % 2 ? (u32)(N.p[20 / 2] >> 32) : (u32)(N.p[20 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	sub32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	sub32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 20 % 2 ? (u32)(N.p[20 / 2] >> 32) : (u32)(N.p[20 / 2]), &c);
	;
	add32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	sub32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	sub32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	sub32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	add32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	add32(&cur, 16 % 2 ? (u32)(N.p[16 / 2] >> 32) : (u32)(N.p[16 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 12 % 2 ? (u32)(N.p[12 / 2] >> 32) : (u32)(N.p[12 / 2]), &c);
	;
	add32(&cur, 20 % 2 ? (u32)(N.p[20 / 2] >> 32) : (u32)(N.p[20 / 2]), &c);
	;
	add32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	sub32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	sub32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	sub32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	add32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	add32(&cur, 17 % 2 ? (u32)(N.p[17 / 2] >> 32) : (u32)(N.p[17 / 2]), &c);
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 13 % 2 ? (u32)(N.p[13 / 2] >> 32) : (u32)(N.p[13 / 2]), &c);
	;
	add32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	add32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	sub32(&cur, 16 % 2 ? (u32)(N.p[16 / 2] >> 32) : (u32)(N.p[16 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	add32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	add32(&cur, 18 % 2 ? (u32)(N.p[18 / 2] >> 32) : (u32)(N.p[18 / 2]), &c);
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 14 % 2 ? (u32)(N.p[14 / 2] >> 32) : (u32)(N.p[14 / 2]), &c);
	;
	add32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	sub32(&cur, 17 % 2 ? (u32)(N.p[17 / 2] >> 32) : (u32)(N.p[17 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 19 % 2 ? (u32)(N.p[19 / 2] >> 32) : (u32)(N.p[19 / 2]), &c);
	;
	add32(&cur, 16 % 2 ? (u32)(N.p[16 / 2] >> 32) : (u32)(N.p[16 / 2]), &c);
	;
	add32(&cur, 15 % 2 ? (u32)(N.p[15 / 2] >> 32) : (u32)(N.p[15 / 2]), &c);
	;
	add32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	sub32(&cur, 18 % 2 ? (u32)(N.p[18 / 2] >> 32) : (u32)(N.p[18 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 20 % 2 ? (u32)(N.p[20 / 2] >> 32) : (u32)(N.p[20 / 2]), &c);
	;
	add32(&cur, 17 % 2 ? (u32)(N.p[17 / 2] >> 32) : (u32)(N.p[17 / 2]), &c);
	;
	add32(&cur, 16 % 2 ? (u32)(N.p[16 / 2] >> 32) : (u32)(N.p[16 / 2]), &c);
	;
	sub32(&cur, 19 % 2 ? (u32)(N.p[19 / 2] >> 32) : (u32)(N.p[19 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	add32(&cur, 18 % 2 ? (u32)(N.p[18 / 2] >> 32) : (u32)(N.p[18 / 2]), &c);
	;
	add32(&cur, 17 % 2 ? (u32)(N.p[17 / 2] >> 32) : (u32)(N.p[17 / 2]), &c);
	;
	sub32(&cur, 20 % 2 ? (u32)(N.p[20 / 2] >> 32) : (u32)(N.p[20 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	add32(&cur, 19 % 2 ? (u32)(N.p[19 / 2] >> 32) : (u32)(N.p[19 / 2]), &c);
	;
	add32(&cur, 18 % 2 ? (u32)(N.p[18 / 2] >> 32) : (u32)(N.p[18 / 2]), &c);
	;
	sub32(&cur, 21 % 2 ? (u32)(N.p[21 / 2] >> 32) : (u32)(N.p[21 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = i % 2 ? (u32)(N.p[i / 2] >> 32) : (u32)(N.p[i / 2]);
	;
	cc = c;
	c = 0;
	if cc < 0
	{
		sub32(&cur, -cc, &c);
	}
	else
	{
		add32(&cur, cc, &c);
	}
	;
	add32(&cur, 23 % 2 ? (u32)(N.p[23 / 2] >> 32) : (u32)(N.p[23 / 2]), &c);
	;
	add32(&cur, 20 % 2 ? (u32)(N.p[20 / 2] >> 32) : (u32)(N.p[20 / 2]), &c);
	;
	add32(&cur, 19 % 2 ? (u32)(N.p[19 / 2] >> 32) : (u32)(N.p[19 / 2]), &c);
	;
	sub32(&cur, 22 % 2 ? (u32)(N.p[22 / 2] >> 32) : (u32)(N.p[22 / 2]), &c);
	;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	i++;
	cur = c > 0 ? c : 0;
	if i % 2
	{
		N.p[i / 2] &= 0x00000000FFFFFFFF;
		N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
	}
	else
	{
		N.p[i / 2] &= 0xFFFFFFFF00000000;
		N.p[i / 2] |= (mbedtls_mpi_uint) cur;
	};
	cur = 0;
	while (++i < N.n * 2)
	{
		if i % 2
		{
			N.p[i / 2] &= 0x00000000FFFFFFFF;
			N.p[i / 2] |= ((mbedtls_mpi_uint) cur) << 32;
		}
		else
		{
			N.p[i / 2] &= 0xFFFFFFFF00000000;
			N.p[i / 2] |= (mbedtls_mpi_uint) cur;
		};
	}
	if c < 0
	{
		fix_negative(N, c, &C, bits);
	}
	;
cleanup:
	return ret;
}

fn ecp_mod_p521(mbedtls_mpi * N) -> i32
{
	i32 ret;
	usize i;
	mbedtls_mpi M;
	mbedtls_mpi_ui32 Mp[(521 / 8 / sizeof(mbedtls_mpi_uint) + 1) + 1];
	if N.n < (521 / 8 / sizeof(mbedtls_mpi_uint) + 1)
	{
		return 0;
	}
	M.s = 1;
	M.n = N.n - ((521 / 8 / sizeof(mbedtls_mpi_uint) + 1) - 1);
	if M.n > (521 / 8 / sizeof(mbedtls_mpi_uint) + 1) + 1
	{
		M.n = (521 / 8 / sizeof(mbedtls_mpi_uint) + 1) + 1;
	}
	M.p = Mp;
	memcpy(Mp, N.p + (521 / 8 / sizeof(mbedtls_mpi_uint) + 1) - 1, M.n * sizeof(mbedtls_mpi_uint));
	do
	{
		if (ret = mbedtls_mpi_shift_r(&M, 521 % (8 * sizeof(mbedtls_mpi_uint)))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	N.p[(521 / 8 / sizeof(mbedtls_mpi_uint) + 1) - 1] &= 0x01FF;
	for (i = (521 / 8 / sizeof(mbedtls_mpi_uint) + 1); i < N.n; i++)
	{
		N.p[i] = 0;
	}
	do
	{
		if (ret = mbedtls_mpi_add_abs(N, N, &M)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecp_mod_p255(mbedtls_mpi * N) -> i32
{
	i32 ret;
	usize i;
	mbedtls_mpi M;
	mbedtls_mpi_ui32 Mp[(255 / 8 / sizeof(mbedtls_mpi_uint) + 1) + 2];
	if N.n < (255 / 8 / sizeof(mbedtls_mpi_uint) + 1)
	{
		return 0;
	}
	M.s = 1;
	M.n = N.n - ((255 / 8 / sizeof(mbedtls_mpi_uint) + 1) - 1);
	if M.n > (255 / 8 / sizeof(mbedtls_mpi_uint) + 1) + 1
	{
		M.n = (255 / 8 / sizeof(mbedtls_mpi_uint) + 1) + 1;
	}
	M.p = Mp;
	memset(Mp, 0, sizeof Mp);
	memcpy(Mp, N.p + (255 / 8 / sizeof(mbedtls_mpi_uint) + 1) - 1, M.n * sizeof(mbedtls_mpi_uint));
	do
	{
		if (ret = mbedtls_mpi_shift_r(&M, 255 % (8 * sizeof(mbedtls_mpi_uint)))) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	M.n++;
	do
	{
		if (ret = mbedtls_mpi_set_bit(N, 255, 0)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (i = (255 / 8 / sizeof(mbedtls_mpi_uint) + 1); i < N.n; i++)
	{
		N.p[i] = 0;
	}
	do
	{
		if (ret = mbedtls_mpi_mul_int(&M, &M, 19)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_abs(N, N, &M)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn i32 ecp_mod_koblitz(mbedtls_mpi * N, mbedtls_mpi_ui32 * Rp, usize p_limbs, usize adjust, usize shift, mbedtls_mpi_ui32 mask) -> inline
{
	i32 ret;
	usize i;
	mbedtls_mpi M, R;
	mbedtls_mpi_ui32 Mp[(256 / 8 / sizeof(mbedtls_mpi_uint)) + (8 / sizeof(mbedtls_mpi_uint))];
	if N.n < p_limbs
	{
		return 0;
	}
	R.s = 1;
	R.p = Rp;
	R.n = (8 / sizeof(mbedtls_mpi_uint));
	M.s = 1;
	M.p = Mp;
	M.n = N.n - (p_limbs - adjust);
	if M.n > p_limbs + adjust
	{
		M.n = p_limbs + adjust;
	}
	memset(Mp, 0, sizeof Mp);
	memcpy(Mp, N.p + p_limbs - adjust, M.n * sizeof(mbedtls_mpi_uint));
	if shift != 0
		do
		{
			if (ret = mbedtls_mpi_shift_r(&M, shift)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	M.n += R.n - adjust;
	if mask != 0
	{
		N.p[p_limbs - 1] &= mask;
	}
	for (i = p_limbs; i < N.n; i++)
	{
		N.p[i] = 0;
	}
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&M, &M, &R)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_abs(N, N, &M)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	M.n = N.n - (p_limbs - adjust);
	if M.n > p_limbs + adjust
	{
		M.n = p_limbs + adjust;
	}
	memset(Mp, 0, sizeof Mp);
	memcpy(Mp, N.p + p_limbs - adjust, M.n * sizeof(mbedtls_mpi_uint));
	if shift != 0
		do
		{
			if (ret = mbedtls_mpi_shift_r(&M, shift)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	M.n += R.n - adjust;
	if mask != 0
	{
		N.p[p_limbs - 1] &= mask;
	}
	for (i = p_limbs; i < N.n; i++)
	{
		N.p[i] = 0;
	}
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&M, &M, &R)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_abs(N, N, &M)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

fn ecp_mod_p192k1(mbedtls_mpi * N) -> i32
{
	static mbedtls_mpi_ui32 Rp[] = {((mbedtls_mpi_uint) 0xC9 << 0) | ((mbedtls_mpi_uint) 0x11 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0x01 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56)};
	return ecp_mod_koblitz(N, Rp, 192 / 8 / sizeof(mbedtls_mpi_uint), 0, 0, 0);
}

fn ecp_mod_p224k1(mbedtls_mpi * N) -> i32
{
	static mbedtls_mpi_ui32 Rp[] = {((mbedtls_mpi_uint) 0x93 << 0) | ((mbedtls_mpi_uint) 0x1A << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0x01 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56)};
	return ecp_mod_koblitz(N, Rp, 4, 1, 32, 0xFFFFFFFF);
}

fn ecp_mod_p256k1(mbedtls_mpi * N) -> i32
{
	static mbedtls_mpi_ui32 Rp[] = {((mbedtls_mpi_uint) 0xD1 << 0) | ((mbedtls_mpi_uint) 0x03 << 8) | ((mbedtls_mpi_uint) 0x00 << 16) | ((mbedtls_mpi_uint) 0x00 << 24) | ((mbedtls_mpi_uint) 0x01 << 32) | ((mbedtls_mpi_uint) 0x00 << 40) | ((mbedtls_mpi_uint) 0x00 << 48) | ((mbedtls_mpi_uint) 0x00 << 56)};
	return ecp_mod_koblitz(N, Rp, 256 / 8 / sizeof(mbedtls_mpi_uint), 0, 0, 0);
}

typedef struct
{
	u64 total[2];
	u64 state[8];
	u8 buffer[128];
	i32 is384;
} mbedtls_sha512_context;

typedef struct
{
	mbedtls_entropy_f_source_ptr f_source;
	void * p_source;
	usize size;
	usize threshold;
	i32 strong;
} mbedtls_entropy_source_state;
typedef struct
{
	mbedtls_sha512_context accumulator;
	i32 source_count;
	mbedtls_entropy_source_state source[20];
	mbedtls_threading_mutex_t mutex;
} mbedtls_entropy_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_entropy_init(mbedtls_entropy_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_entropy_context));
	mbedtls_mutex_init(&ctx.mutex);
	mbedtls_sha512_starts(&ctx.accumulator, 0);
	mbedtls_entropy_add_source(ctx, mbedtls_platform_entropy_poll, NULL, 32, 1);
	mbedtls_entropy_add_source(ctx, mbedtls_hardclock_poll, NULL, 4, 0);
}

pub fn mbedtls_entropy_free(mbedtls_entropy_context * ctx)
{
	mbedtls_mutex_free(&ctx.mutex);
	zeroize(ctx, sizeof(mbedtls_entropy_context));
}

pub fn mbedtls_entropy_add_source(mbedtls_entropy_context * ctx, mbedtls_entropy_f_source_ptr f_source, void * p_source, usize threshold, i32 strong) -> i32
{
	i32 index, ret = 0;
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	index = ctx.source_count;
	if index >= 20
	{
		ret = -0x003E;
		goto exit;
	}
	ctx.source[index].f_source = f_source;
	ctx.source[index].p_source = p_source;
	ctx.source[index].threshold = threshold;
	ctx.source[index].strong = strong;
	ctx.source_count++;
exit:
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

fn entropy_update(mbedtls_entropy_context * ctx, u8 source_id, const u8 * data, usize len) -> i32
{
	u8 header[2];
	u8 tmp[64];
	usize use_len = len;
	const u8 * p = data;
	if use_len > 64
	{
		mbedtls_sha512(data, len, tmp, 0);
		p = tmp;
		use_len = 64;
	}
	header[0] = source_id;
	header[1] = use_len & 0xFF;
	mbedtls_sha512_update(&ctx.accumulator, header, 2);
	mbedtls_sha512_update(&ctx.accumulator, p, use_len);
	return 0;
}

pub fn mbedtls_entropy_update_manual(mbedtls_entropy_context * ctx, const u8 * data, usize len) -> i32
{
	i32 ret;
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	ret = entropy_update(ctx, 20, data, len);
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

fn entropy_gather_internal(mbedtls_entropy_context * ctx) -> i32
{
	i32 ret, i, have_one_strong = 0;
	u8 buf[128];
	usize olen;
	if ctx.source_count == 0
	{
		return -0x0040;
	}
	for (i = 0; i < ctx.source_count; i++)
	{
		if ctx.source[i].strong == 1
		{
			have_one_strong = 1;
		}
		olen = 0;
		if (ret = ctx.source[i].f_source(ctx.source[i].p_source, buf, 128, &olen)) != 0
		{
			return ret;
		}
		if olen > 0
		{
			entropy_update(ctx, (i8) i, buf, olen);
			ctx.source[i].size += olen;
		}
	}
	if have_one_strong == 0
	{
		return -0x003D;
	}
	return 0;
}

pub fn mbedtls_entropy_gather(mbedtls_entropy_context * ctx) -> i32
{
	i32 ret;
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	ret = entropy_gather_internal(ctx);
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

pub fn mbedtls_entropy_func(void * data, u8 * output, usize len) -> i32
{
	i32 ret, count = 0, i, done;
	mbedtls_entropy_context * ctx = (mbedtls_entropy_context *) data;
	u8 buf[64];
	if len > 64
	{
		return -0x003C;
	}
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	do
	{
		if count++ > 256
		{
			ret = -0x003C;
			goto exit;
		}
		if (ret = entropy_gather_internal(ctx)) != 0
		{
			goto exit;
		}
		done = 1;
		for (i = 0; i < ctx.source_count; i++)
			if ctx.source[i].size < ctx.source[i].threshold
			{
				done = 0;
			}
	}
	while (!done);
	memset(buf, 0, 64);
	mbedtls_sha512_finish(&ctx.accumulator, buf);
	memset(&ctx.accumulator, 0, sizeof(mbedtls_sha512_context));
	mbedtls_sha512_starts(&ctx.accumulator, 0);
	mbedtls_sha512_update(&ctx.accumulator, buf, 64);
	mbedtls_sha512(buf, 64, buf, 0);
	for (i = 0; i < ctx.source_count; i++)
	{
		ctx.source[i].size = 0;
	}
	memcpy(output, buf, len);
	ret = 0;
exit:
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

pub fn mbedtls_entropy_write_seed_file(mbedtls_entropy_context * ctx, const i8 * path) -> i32
{
	i32 ret = -0x003F;
	FILE * f;
	u8 buf[64];
	if (f = fopen(path, "wb")) == NULL
	{
		return -0x003F;
	}
	if (ret = mbedtls_entropy_func(ctx, buf, 64)) != 0
	{
		goto exit;
	}
	if fwrite(buf, 1, 64, f) != 64
	{
		ret = -0x003F;
		goto exit;
	}
	ret = 0;
exit:
	fclose(f);
	return ret;
}

pub fn mbedtls_entropy_update_seed_file(mbedtls_entropy_context * ctx, const i8 * path) -> i32
{
	FILE * f;
	usize n;
	u8 buf[1024];
	if (f = fopen(path, "rb")) == NULL
	{
		return -0x003F;
	}
	fseek(f, 0, SEEK_END);
	n = (usize) ftell(f);
	fseek(f, 0, SEEK_SET);
	if n > 1024
	{
		n = 1024;
	}
	if fread(buf, 1, n, f) != n
	{
		fclose(f);
		return -0x003F;
	}
	fclose(f);
	mbedtls_entropy_update_manual(ctx, buf, n);
	return mbedtls_entropy_write_seed_file(ctx, path);
}

fn entropy_dummy_source(void * data, u8 * output, usize len, usize * olen) -> i32
{
	((void) data);
	memset(output, 0x2a, len);
	*olen = len;
	return 0;
}

pub fn mbedtls_entropy_self_test(i32 verbose) -> i32
{
	i32 ret = 0;
	mbedtls_entropy_context ctx;
	u8 buf[64] = {0};
	u8 acc[64] = {0};
	usize i, j;
	if verbose != 0
	{
		printf("  ENTROPY test: ");
	}
	mbedtls_entropy_init(&ctx);
	if (ret = mbedtls_entropy_gather(&ctx)) != 0
	{
		goto cleanup;
	}
	ret = mbedtls_entropy_add_source(&ctx, entropy_dummy_source, NULL, 16, 0);
	if ret != 0
	{
		goto cleanup;
	}
	if (ret = mbedtls_entropy_update_manual(&ctx, buf, sizeof buf)) != 0
	{
		goto cleanup;
	}
	for (i = 0; i < 8; i++)
	{
		if (ret = mbedtls_entropy_func(&ctx, buf, sizeof(buf))) != 0
		{
			goto cleanup;
		}
		for (j = 0; j < sizeof(buf); j++)
		{
			acc[j] |= buf[j];
		}
	}
	for (j = 0; j < sizeof(buf); j++)
	{
		if acc[j] == 0
		{
			ret = 1;
			goto cleanup;
		}
	}
cleanup:
	mbedtls_entropy_free(&ctx);
	if verbose != 0
	{
		if ret != 0
		{
			printf("failed\n");
		}
		else
		{
			printf("passed\n");
		}
		printf("\n");
	}
	return ret != 0;
}

struct mbedtls_timing_hr_time
{
	u8 opaque[32];
};
typedef struct
{
	struct mbedtls_timing_hr_time timer;
	u32 int_ms;
	u32 fin_ms;
} mbedtls_timing_delay_context;
static volatile i32 mbedtls_timing_alarmed;

pub fn mbedtls_platform_entropy_poll(void * data, u8 * output, usize len, usize * olen) -> i32
{
	FILE * file;
	usize read_len;
	((void) data);
	*olen = 0;
	file = fopen("/dev/urandom", "rb");
	if file == NULL
	{
		return -0x003C;
	}
	read_len = fread(output, 1, len, file);
	if read_len != len
	{
		fclose(file);
		return -0x003C;
	}
	fclose(file);
	*olen = len;
	return 0;
}

pub fn mbedtls_hardclock_poll(void * data, u8 * output, usize len, usize * olen) -> i32
{
	u32 timer = mbedtls_timing_hardclock();
	((void) data);
	*olen = 0;
	if len < sizeof(i32 long)
	{
		return 0;
	}
	memcpy(output, &timer, sizeof(i32 long));
	*olen = sizeof(i32 long);
	return 0;
}

typedef struct
{
	i32 ver;
	usize len;
	mbedtls_mpi N;
	mbedtls_mpi E;
	mbedtls_mpi D;
	mbedtls_mpi P;
	mbedtls_mpi Q;
	mbedtls_mpi DP;
	mbedtls_mpi DQ;
	mbedtls_mpi QP;
	mbedtls_mpi RN;
	mbedtls_mpi RP;
	mbedtls_mpi RQ;
	mbedtls_mpi Vi;
	mbedtls_mpi Vf;
	i32 padding;
	i32 hash_id;
	mbedtls_threading_mutex_t mutex;
} mbedtls_rsa_context;

typedef enum
{
	MBEDTLS_PK_NONE = 0,
	MBEDTLS_PK_RSA,
	MBEDTLS_PK_ECKEY,
	MBEDTLS_PK_ECKEY_DH,
	MBEDTLS_PK_ECDSA,
	MBEDTLS_PK_RSA_ALT,
	MBEDTLS_PK_RSASSA_PSS,
} mbedtls_pk_type_t;
typedef struct
{
	mbedtls_md_type_t mgf1_hash_id;
	i32 expected_salt_len;
} mbedtls_pk_rsassa_pss_options;
typedef enum
{
	MBEDTLS_PK_DEBUG_NONE = 0,
	MBEDTLS_PK_DEBUG_MPI,
	MBEDTLS_PK_DEBUG_ECP,
} mbedtls_pk_debug_type;
typedef struct
{
	mbedtls_pk_debug_type type;
	const i8 * name;
	void * value;
} mbedtls_pk_debug_item;
typedef struct mbedtls_pk_info_t mbedtls_pk_info_t;
typedef struct
{
	const mbedtls_pk_info_t * pk_info;
	void * pk_ctx;
} mbedtls_pk_context;
fn mbedtls_rsa_context * mbedtls_pk_rsa(const mbedtls_pk_context pk) -> inline
{
	return (mbedtls_rsa_context *) (pk).pk_ctx;
}

fn mbedtls_ecp_keypair * mbedtls_pk_ec(const mbedtls_pk_context pk) -> inline
{
	return (mbedtls_ecp_keypair *) (pk).pk_ctx;
}

fn usize mbedtls_pk_get_len(const mbedtls_pk_context * ctx) -> inline
{
	return (mbedtls_pk_get_bitlen(ctx) + 7) / 8;
}

pub type mbedtls_x509_buf = mbedtls_asn1_buf;
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
typedef struct mbedtls_x509_time
{
	i32 year, mon, day;
	i32 hour, min, sec;
} mbedtls_x509_time;

typedef struct
{
	const i8 * asn1;
	usize asn1_len;
	const i8 * name;
	const i8 * description;
} mbedtls_oid_descriptor_t;

typedef enum
{
	MBEDTLS_KEY_EXCHANGE_NONE = 0,
	MBEDTLS_KEY_EXCHANGE_RSA,
	MBEDTLS_KEY_EXCHANGE_DHE_RSA,
	MBEDTLS_KEY_EXCHANGE_ECDHE_RSA,
	MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA,
	MBEDTLS_KEY_EXCHANGE_PSK,
	MBEDTLS_KEY_EXCHANGE_DHE_PSK,
	MBEDTLS_KEY_EXCHANGE_RSA_PSK,
	MBEDTLS_KEY_EXCHANGE_ECDHE_PSK,
	MBEDTLS_KEY_EXCHANGE_ECDH_RSA,
	MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA,
	MBEDTLS_KEY_EXCHANGE_ECJPAKE,
} mbedtls_key_exchange_type_t;
typedef struct mbedtls_ssl_ciphersuite_t mbedtls_ssl_ciphersuite_t;
struct mbedtls_ssl_ciphersuite_t
{
	i32 id;
	const i8 * name;
	mbedtls_cipher_type_t cipher;
	mbedtls_md_type_t mac;
	mbedtls_key_exchange_type_t key_exchange;
	i32 min_major_ver;
	i32 min_minor_ver;
	i32 max_major_ver;
	i32 max_minor_ver;
	u8 flags;
};

typedef struct mbedtls_x509_crl_entry
{
	mbedtls_x509_buf raw;
	mbedtls_x509_buf serial;
	mbedtls_x509_time revocation_date;
	mbedtls_x509_buf entry_ext;
	struct mbedtls_x509_crl_entry * next;
} mbedtls_x509_crl_entry;
typedef struct mbedtls_x509_crl
{
	mbedtls_x509_buf raw;
	mbedtls_x509_buf tbs;
	i32 version;
	mbedtls_x509_buf sig_oid;
	mbedtls_x509_buf issuer_raw;
	mbedtls_x509_name issuer;
	mbedtls_x509_time this_update;
	mbedtls_x509_time next_update;
	mbedtls_x509_crl_entry entry;
	mbedtls_x509_buf crl_ext;
	mbedtls_x509_buf sig_oid2;
	mbedtls_x509_buf sig;
	mbedtls_md_type_t sig_md;
	mbedtls_pk_type_t sig_pk;
	void * sig_opts;
	struct mbedtls_x509_crl * next;
} mbedtls_x509_crl;

typedef struct mbedtls_x509_crt
{
	mbedtls_x509_buf raw;
	mbedtls_x509_buf tbs;
	i32 version;
	mbedtls_x509_buf serial;
	mbedtls_x509_buf sig_oid;
	mbedtls_x509_buf issuer_raw;
	mbedtls_x509_buf subject_raw;
	mbedtls_x509_name issuer;
	mbedtls_x509_name subject;
	mbedtls_x509_time valid_from;
	mbedtls_x509_time valid_to;
	mbedtls_pk_context pk;
	mbedtls_x509_buf issuer_id;
	mbedtls_x509_buf subject_id;
	mbedtls_x509_buf v3_ext;
	mbedtls_x509_sequence subject_alt_names;
	i32 ext_types;
	i32 ca_istrue;
	i32 max_pathlen;
	u32 key_usage;
	mbedtls_x509_sequence ext_key_usage;
	u8 ns_cert_type;
	mbedtls_x509_buf sig;
	mbedtls_md_type_t sig_md;
	mbedtls_pk_type_t sig_pk;
	void * sig_opts;
	struct mbedtls_x509_crt * next;
} mbedtls_x509_crt;
typedef struct
{
	u32 allowed_mds;
	u32 allowed_pks;
	u32 allowed_curves;
	u32 rsa_min_bitlen;
} mbedtls_x509_crt_profile;
typedef struct mbedtls_x509write_cert
{
	i32 version;
	mbedtls_mpi serial;
	mbedtls_pk_context * subject_key;
	mbedtls_pk_context * issuer_key;
	mbedtls_asn1_named_data * subject;
	mbedtls_asn1_named_data * issuer;
	mbedtls_md_type_t md_alg;
	i8 not_before[15 + 1];
	i8 not_after[15 + 1];
	mbedtls_asn1_named_data * extensions;
} mbedtls_x509write_cert;
static  mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default;
static  mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next;
static  mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb;

union mbedtls_ssl_premaster_secret
{
	u8 _pms_rsa[48];
	u8 _pms_dhm[1024];
	u8 _pms_ecdh[((521 + 7) / 8)];
	u8 _pms_psk[4 + 2 * 32];
	u8 _pms_dhe_psk[4 + 1024 + 32];
	u8 _pms_rsa_psk[52 + 32];
	u8 _pms_ecdhe_psk[4 + ((521 + 7) / 8) + 32];
};
typedef enum
{
	MBEDTLS_SSL_HELLO_REQUEST,
	MBEDTLS_SSL_CLIENT_HELLO,
	MBEDTLS_SSL_SERVER_HELLO,
	MBEDTLS_SSL_SERVER_CERTIFICATE,
	MBEDTLS_SSL_SERVER_KEY_EXCHANGE,
	MBEDTLS_SSL_CERTIFICATE_REQUEST,
	MBEDTLS_SSL_SERVER_HELLO_DONE,
	MBEDTLS_SSL_CLIENT_CERTIFICATE,
	MBEDTLS_SSL_CLIENT_KEY_EXCHANGE,
	MBEDTLS_SSL_CERTIFICATE_VERIFY,
	MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC,
	MBEDTLS_SSL_CLIENT_FINISHED,
	MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC,
	MBEDTLS_SSL_SERVER_FINISHED,
	MBEDTLS_SSL_FLUSH_BUFFERS,
	MBEDTLS_SSL_HANDSHAKE_WRAPUP,
	MBEDTLS_SSL_HANDSHAKE_OVER,
	MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET,
	MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT,
} mbedtls_ssl_states;

typedef struct mbedtls_ssl_session mbedtls_ssl_session;
typedef struct mbedtls_ssl_context mbedtls_ssl_context;
typedef struct mbedtls_ssl_config mbedtls_ssl_config;
typedef struct mbedtls_ssl_transform mbedtls_ssl_transform;
typedef struct mbedtls_ssl_handshake_params mbedtls_ssl_handshake_params;
typedef struct mbedtls_ssl_key_cert mbedtls_ssl_key_cert;
typedef struct mbedtls_ssl_flight_item mbedtls_ssl_flight_item;
struct mbedtls_ssl_session
{
	time_t start;
	i32 ciphersuite;
	i32 compression;
	usize id_len;
	u8 id[32];
	u8 master[48];
	mbedtls_x509_crt * peer_cert;
	u32 verify_result;
	u8 * ticket;
	usize ticket_len;
	u32 ticket_lifetime;
	u8 mfl_code;
	i32 encrypt_then_mac;
};
struct mbedtls_ssl_config
{
	const i32 * ciphersuite_list[4];
	void (*f_dbg)(void *, int, const i8 *, int, const i8 *);
	void * p_dbg;
	i32 (*f_rng)(void *, u8 *, usize);
	void * p_rng;
	i32 (*f_get_cache)(void *, mbedtls_ssl_session *);
	i32 (*f_set_cache)(void *, const mbedtls_ssl_session *);
	void * p_cache;
	i32 (*f_sni)(void *, mbedtls_ssl_context *, const u8 *, usize);
	void * p_sni;
	i32 (*f_vrfy)(void *, mbedtls_x509_crt *, int, u32 *);
	void * p_vrfy;
	i32 (*f_psk)(void *, mbedtls_ssl_context *, const u8 *, usize);
	void * p_psk;
	i32 (*f_cookie_write)(void *, u8 **, u8 *, const u8 *, usize);
	i32 (*f_cookie_check)(void *, const u8 *, usize, const u8 *, usize);
	void * p_cookie;
	i32 (*f_ticket_write)(void *, const mbedtls_ssl_session *, u8 *, const u8 *, usize *, u32 *);
	i32 (*f_ticket_parse)(void *, mbedtls_ssl_session *, u8 *, usize);
	void * p_ticket;
	const mbedtls_x509_crt_profile * cert_profile;
	mbedtls_ssl_key_cert * key_cert;
	mbedtls_x509_crt * ca_chain;
	mbedtls_x509_crl * ca_crl;
	const i32 * sig_hashes;
	const mbedtls_ecp_group_id * curve_list;
	mbedtls_mpi dhm_P;
	mbedtls_mpi dhm_G;
	u8 * psk;
	usize psk_len;
	u8 * psk_identity;
	usize psk_identity_len;
	const i8 ** alpn_list;
	u32 read_timeout;
	u32 hs_timeout_min;
	u32 hs_timeout_max;
	u32 badmac_limit;
	u32 dhm_min_bitlen;
	u8 max_major_ver;
	u8 max_minor_ver;
	u8 min_major_ver;
	u8 min_minor_ver;
	u32 endpoi32 : 1;
	u32 transport : 1;
	u32 authmode : 2;
	u32 allow_legacy_renegotiation : 2;
	u32 mfl_code : 3;
	u32 encrypt_then_mac : 1;
	u32 extended_ms : 1;
	u32 anti_replay : 1;
	u32 session_tickets : 1;
};
struct mbedtls_ssl_context
{
	const mbedtls_ssl_config * conf;
	i32 state;
	i32 major_ver;
	i32 minor_ver;
	i32 badmac_seen;
	mbedtls_ssl_send_t * f_send;
	mbedtls_ssl_recv_t * f_recv;
	mbedtls_ssl_recv_timeout_t * f_recv_timeout;
	void * p_bio;
	mbedtls_ssl_session * session_in;
	mbedtls_ssl_session * session_out;
	mbedtls_ssl_session * session;
	mbedtls_ssl_session * session_negotiate;
	mbedtls_ssl_handshake_params * handshake;
	mbedtls_ssl_transform * transform_in;
	mbedtls_ssl_transform * transform_out;
	mbedtls_ssl_transform * transform;
	mbedtls_ssl_transform * transform_negotiate;
	void * p_timer;
	mbedtls_ssl_set_timer_t * f_set_timer;
	mbedtls_ssl_get_timer_t * f_get_timer;
	u8 * in_buf;
	u8 * in_ctr;
	u8 * in_hdr;
	u8 * in_len;
	u8 * in_iv;
	u8 * in_msg;
	u8 * in_offt;
	i32 in_msgtype;
	usize in_msglen;
	usize in_left;
	u16 in_epoch;
	usize next_record_offset;
	u64 in_window_top;
	u64 in_window;
	usize in_hslen;
	i32 nb_zero;
	i32 record_read;
	u8 * out_buf;
	u8 * out_ctr;
	u8 * out_hdr;
	u8 * out_len;
	u8 * out_iv;
	u8 * out_msg;
	i32 out_msgtype;
	usize out_msglen;
	usize out_left;
	i32 client_auth;
	i8 * hostname;
	const i8 * alpn_chosen;
	u8 * cli_id;
	usize cli_id_len;
	i32 secure_renegotiation;
};

typedef struct
{
	u32 k[4];
} mbedtls_xtea_context;

pub fn mbedtls_strerror(i32 ret, i8 * buf, usize buflen)
{
	usize len;
	i32 use_ret;
	if buflen == 0
	{
		return;
	}
	memset(buf, 0x00, buflen);
	if ret < 0
	{
		ret = -ret;
	}
	if ret & 0xFF80
	{
		use_ret = ret & 0xFF80;
		if use_ret == -(-0x6080)
		{
			snprintf(buf, buflen, "CIPHER - The selected feature is not available");
		}
		if use_ret == -(-0x6100)
		{
			snprintf(buf, buflen, "CIPHER - Bad input parameters to function");
		}
		if use_ret == -(-0x6180)
		{
			snprintf(buf, buflen, "CIPHER - Failed to allocate memory");
		}
		if use_ret == -(-0x6200)
		{
			snprintf(buf, buflen, "CIPHER - Input data contains invalid padding and is rejected");
		}
		if use_ret == -(-0x6280)
		{
			snprintf(buf, buflen, "CIPHER - Decryption of block requires a full block");
		}
		if use_ret == -(-0x6300)
		{
			snprintf(buf, buflen, "CIPHER - Authentication failed (for AEAD modes)");
		}
		if use_ret == -(-0x6380)
		{
			snprintf(buf, buflen, "CIPHER - The context is invalid, eg because it was free()ed");
		}
		if use_ret == -(-0x3080)
		{
			snprintf(buf, buflen, "DHM - Bad input parameters to function");
		}
		if use_ret == -(-0x3100)
		{
			snprintf(buf, buflen, "DHM - Reading of the DHM parameters failed");
		}
		if use_ret == -(-0x3180)
		{
			snprintf(buf, buflen, "DHM - Making of the DHM parameters failed");
		}
		if use_ret == -(-0x3200)
		{
			snprintf(buf, buflen, "DHM - Reading of the public values failed");
		}
		if use_ret == -(-0x3280)
		{
			snprintf(buf, buflen, "DHM - Making of the public value failed");
		}
		if use_ret == -(-0x3300)
		{
			snprintf(buf, buflen, "DHM - Calculation of the DHM secret failed");
		}
		if use_ret == -(-0x3380)
		{
			snprintf(buf, buflen, "DHM - The ASN.1 data is not formatted correctly");
		}
		if use_ret == -(-0x3400)
		{
			snprintf(buf, buflen, "DHM - Allocation of memory failed");
		}
		if use_ret == -(-0x3480)
		{
			snprintf(buf, buflen, "DHM - Read/write of file failed");
		}
		if use_ret == -(-0x4F80)
		{
			snprintf(buf, buflen, "ECP - Bad input parameters to function");
		}
		if use_ret == -(-0x4F00)
		{
			snprintf(buf, buflen, "ECP - The buffer is too small to write to");
		}
		if use_ret == -(-0x4E80)
		{
			snprintf(buf, buflen, "ECP - Requested curve not available");
		}
		if use_ret == -(-0x4E00)
		{
			snprintf(buf, buflen, "ECP - The signature is not valid");
		}
		if use_ret == -(-0x4D80)
		{
			snprintf(buf, buflen, "ECP - Memory allocation failed");
		}
		if use_ret == -(-0x4D00)
		{
			snprintf(buf, buflen, "ECP - Generation of random value, such as (ephemeral) key, failed");
		}
		if use_ret == -(-0x4C80)
		{
			snprintf(buf, buflen, "ECP - Invalid private or public key");
		}
		if use_ret == -(-0x4C00)
		{
			snprintf(buf, buflen, "ECP - Signature is valid but shorter than the user-supplied length");
		}
		if use_ret == -(-0x5080)
		{
			snprintf(buf, buflen, "MD - The selected feature is not available");
		}
		if use_ret == -(-0x5100)
		{
			snprintf(buf, buflen, "MD - Bad input parameters to function");
		}
		if use_ret == -(-0x5180)
		{
			snprintf(buf, buflen, "MD - Failed to allocate memory");
		}
		if use_ret == -(-0x5200)
		{
			snprintf(buf, buflen, "MD - Opening or reading of file failed");
		}
		if use_ret == -(-0x1080)
		{
			snprintf(buf, buflen, "PEM - No PEM header or footer found");
		}
		if use_ret == -(-0x1100)
		{
			snprintf(buf, buflen, "PEM - PEM string is not as expected");
		}
		if use_ret == -(-0x1180)
		{
			snprintf(buf, buflen, "PEM - Failed to allocate memory");
		}
		if use_ret == -(-0x1200)
		{
			snprintf(buf, buflen, "PEM - RSA IV is not in hex-format");
		}
		if use_ret == -(-0x1280)
		{
			snprintf(buf, buflen, "PEM - Unsupported key encryption algorithm");
		}
		if use_ret == -(-0x1300)
		{
			snprintf(buf, buflen, "PEM - Private key password can't be empty");
		}
		if use_ret == -(-0x1380)
		{
			snprintf(buf, buflen, "PEM - Given private key password does not allow for correct decryption");
		}
		if use_ret == -(-0x1400)
		{
			snprintf(buf, buflen, "PEM - Unavailable feature, e.g. hashing/encryption combination");
		}
		if use_ret == -(-0x1480)
		{
			snprintf(buf, buflen, "PEM - Bad input parameters to function");
		}
		if use_ret == -(-0x3F80)
		{
			snprintf(buf, buflen, "PK - Memory allocation failed");
		}
		if use_ret == -(-0x3F00)
		{
			snprintf(buf, buflen, "PK - Type mismatch, eg attempt to encrypt with an ECDSA key");
		}
		if use_ret == -(-0x3E80)
		{
			snprintf(buf, buflen, "PK - Bad input parameters to function");
		}
		if use_ret == -(-0x3E00)
		{
			snprintf(buf, buflen, "PK - Read/write of file failed");
		}
		if use_ret == -(-0x3D80)
		{
			snprintf(buf, buflen, "PK - Unsupported key version");
		}
		if use_ret == -(-0x3D00)
		{
			snprintf(buf, buflen, "PK - Invalid key tag or value");
		}
		if use_ret == -(-0x3C80)
		{
			snprintf(buf, buflen, "PK - Key algorithm is unsupported (only RSA and EC are supported)");
		}
		if use_ret == -(-0x3C00)
		{
			snprintf(buf, buflen, "PK - Private key password can't be empty");
		}
		if use_ret == -(-0x3B80)
		{
			snprintf(buf, buflen, "PK - Given private key password does not allow for correct decryption");
		}
		if use_ret == -(-0x3B00)
		{
			snprintf(buf, buflen, "PK - The pubkey tag or value is invalid (only RSA and EC are supported)");
		}
		if use_ret == -(-0x3A80)
		{
			snprintf(buf, buflen, "PK - The algorithm tag or value is invalid");
		}
		if use_ret == -(-0x3A00)
		{
			snprintf(buf, buflen, "PK - Elliptic curve is unsupported (only NIST curves are supported)");
		}
		if use_ret == -(-0x3980)
		{
			snprintf(buf, buflen, "PK - Unavailable feature, e.g. RSA disabled for RSA key");
		}
		if use_ret == -(-0x3900)
		{
			snprintf(buf, buflen, "PK - The signature is valid but its length is less than expected");
		}
		if use_ret == -(-0x1F80)
		{
			snprintf(buf, buflen, "PKCS12 - Bad input parameters to function");
		}
		if use_ret == -(-0x1F00)
		{
			snprintf(buf, buflen, "PKCS12 - Feature not available, e.g. unsupported encryption scheme");
		}
		if use_ret == -(-0x1E80)
		{
			snprintf(buf, buflen, "PKCS12 - PBE ASN.1 data not as expected");
		}
		if use_ret == -(-0x1E00)
		{
			snprintf(buf, buflen, "PKCS12 - Given private key password does not allow for correct decryption");
		}
		if use_ret == -(-0x2f80)
		{
			snprintf(buf, buflen, "PKCS5 - Bad input parameters to function");
		}
		if use_ret == -(-0x2f00)
		{
			snprintf(buf, buflen, "PKCS5 - Unexpected ASN.1 data");
		}
		if use_ret == -(-0x2e80)
		{
			snprintf(buf, buflen, "PKCS5 - Requested encryption or digest alg not available");
		}
		if use_ret == -(-0x2e00)
		{
			snprintf(buf, buflen, "PKCS5 - Given private key password does not allow for correct decryption");
		}
		if use_ret == -(-0x4080)
		{
			snprintf(buf, buflen, "RSA - Bad input parameters to function");
		}
		if use_ret == -(-0x4100)
		{
			snprintf(buf, buflen, "RSA - Input data contains invalid padding and is rejected");
		}
		if use_ret == -(-0x4180)
		{
			snprintf(buf, buflen, "RSA - Something failed during generation of a key");
		}
		if use_ret == -(-0x4200)
		{
			snprintf(buf, buflen, "RSA - Key failed to pass the library's validity check");
		}
		if use_ret == -(-0x4280)
		{
			snprintf(buf, buflen, "RSA - The public key operation failed");
		}
		if use_ret == -(-0x4300)
		{
			snprintf(buf, buflen, "RSA - The private key operation failed");
		}
		if use_ret == -(-0x4380)
		{
			snprintf(buf, buflen, "RSA - The PKCS#1 verification failed");
		}
		if use_ret == -(-0x4400)
		{
			snprintf(buf, buflen, "RSA - The output buffer for decryption is not large enough");
		}
		if use_ret == -(-0x4480)
		{
			snprintf(buf, buflen, "RSA - The random generator failed to generate non-zeros");
		}
		if use_ret == -(-0x7080)
		{
			snprintf(buf, buflen, "SSL - The requested feature is not available");
		}
		if use_ret == -(-0x7100)
		{
			snprintf(buf, buflen, "SSL - Bad input parameters to function");
		}
		if use_ret == -(-0x7180)
		{
			snprintf(buf, buflen, "SSL - Verification of the message MAC failed");
		}
		if use_ret == -(-0x7200)
		{
			snprintf(buf, buflen, "SSL - An invalid SSL record was received");
		}
		if use_ret == -(-0x7280)
		{
			snprintf(buf, buflen, "SSL - The connection indicated an EOF");
		}
		if use_ret == -(-0x7300)
		{
			snprintf(buf, buflen, "SSL - An unknown cipher was received");
		}
		if use_ret == -(-0x7380)
		{
			snprintf(buf, buflen, "SSL - The server has no ciphersuites in common with the client");
		}
		if use_ret == -(-0x7400)
		{
			snprintf(buf, buflen, "SSL - No RNG was provided to the SSL module");
		}
		if use_ret == -(-0x7480)
		{
			snprintf(buf, buflen, "SSL - No client certification received from the client, but required by the authentication mode");
		}
		if use_ret == -(-0x7500)
		{
			snprintf(buf, buflen, "SSL - Our own certificate(s) is/are too large to send in an SSL message");
		}
		if use_ret == -(-0x7580)
		{
			snprintf(buf, buflen, "SSL - The own certificate is not set, but needed by the server");
		}
		if use_ret == -(-0x7600)
		{
			snprintf(buf, buflen, "SSL - The own private key or pre-shared key is not set, but needed");
		}
		if use_ret == -(-0x7680)
		{
			snprintf(buf, buflen, "SSL - No CA Chain is set, but required to operate");
		}
		if use_ret == -(-0x7700)
		{
			snprintf(buf, buflen, "SSL - An unexpected message was received from our peer");
		}
		if use_ret == -(-0x7780)
		{
			snprintf(buf, buflen, "SSL - A fatal alert message was received from our peer");
			return;
		}
		if use_ret == -(-0x7800)
		{
			snprintf(buf, buflen, "SSL - Verification of our peer failed");
		}
		if use_ret == -(-0x7880)
		{
			snprintf(buf, buflen, "SSL - The peer notified us that the connection is going to be closed");
		}
		if use_ret == -(-0x7900)
		{
			snprintf(buf, buflen, "SSL - Processing of the ClientHello handshake message failed");
		}
		if use_ret == -(-0x7980)
		{
			snprintf(buf, buflen, "SSL - Processing of the ServerHello handshake message failed");
		}
		if use_ret == -(-0x7A00)
		{
			snprintf(buf, buflen, "SSL - Processing of the Certificate handshake message failed");
		}
		if use_ret == -(-0x7A80)
		{
			snprintf(buf, buflen, "SSL - Processing of the CertificateRequest handshake message failed");
		}
		if use_ret == -(-0x7B00)
		{
			snprintf(buf, buflen, "SSL - Processing of the ServerKeyExchange handshake message failed");
		}
		if use_ret == -(-0x7B80)
		{
			snprintf(buf, buflen, "SSL - Processing of the ServerHelloDone handshake message failed");
		}
		if use_ret == -(-0x7C00)
		{
			snprintf(buf, buflen, "SSL - Processing of the ClientKeyExchange handshake message failed");
		}
		if use_ret == -(-0x7C80)
		{
			snprintf(buf, buflen, "SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public");
		}
		if use_ret == -(-0x7D00)
		{
			snprintf(buf, buflen, "SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret");
		}
		if use_ret == -(-0x7D80)
		{
			snprintf(buf, buflen, "SSL - Processing of the CertificateVerify handshake message failed");
		}
		if use_ret == -(-0x7E00)
		{
			snprintf(buf, buflen, "SSL - Processing of the ChangeCipherSpec handshake message failed");
		}
		if use_ret == -(-0x7E80)
		{
			snprintf(buf, buflen, "SSL - Processing of the Finished handshake message failed");
		}
		if use_ret == -(-0x7F00)
		{
			snprintf(buf, buflen, "SSL - Memory allocation failed");
		}
		if use_ret == -(-0x7F80)
		{
			snprintf(buf, buflen, "SSL - Hardware acceleration function returned with error");
		}
		if use_ret == -(-0x6F80)
		{
			snprintf(buf, buflen, "SSL - Hardware acceleration function skipped / left alone data");
		}
		if use_ret == -(-0x6F00)
		{
			snprintf(buf, buflen, "SSL - Processing of the compression / decompression failed");
		}
		if use_ret == -(-0x6E80)
		{
			snprintf(buf, buflen, "SSL - Handshake protocol not within min/max boundaries");
		}
		if use_ret == -(-0x6E00)
		{
			snprintf(buf, buflen, "SSL - Processing of the NewSessionTicket handshake message failed");
		}
		if use_ret == -(-0x6D80)
		{
			snprintf(buf, buflen, "SSL - Session ticket has expired");
		}
		if use_ret == -(-0x6D00)
		{
			snprintf(buf, buflen, "SSL - Public key type mismatch (eg, asked for RSA key exchange and presented EC key)");
		}
		if use_ret == -(-0x6C80)
		{
			snprintf(buf, buflen, "SSL - Unknown identity received (eg, PSK identity)");
		}
		if use_ret == -(-0x6C00)
		{
			snprintf(buf, buflen, "SSL - Internal error (eg, unexpected failure in lower-level module)");
		}
		if use_ret == -(-0x6B80)
		{
			snprintf(buf, buflen, "SSL - A counter would wrap (eg, too many messages exchanged)");
		}
		if use_ret == -(-0x6B00)
		{
			snprintf(buf, buflen, "SSL - Unexpected message at ServerHello in renegotiation");
		}
		if use_ret == -(-0x6A80)
		{
			snprintf(buf, buflen, "SSL - DTLS client must retry for hello verification");
		}
		if use_ret == -(-0x6A00)
		{
			snprintf(buf, buflen, "SSL - A buffer is too small to receive or write a message");
		}
		if use_ret == -(-0x6980)
		{
			snprintf(buf, buflen, "SSL - None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages)");
		}
		if use_ret == -(-0x6900)
		{
			snprintf(buf, buflen, "SSL - Connection requires a read call");
		}
		if use_ret == -(-0x6880)
		{
			snprintf(buf, buflen, "SSL - Connection requires a write call");
		}
		if use_ret == -(-0x6800)
		{
			snprintf(buf, buflen, "SSL - The operation timed out");
		}
		if use_ret == -(-0x6780)
		{
			snprintf(buf, buflen, "SSL - The client initiated a reconnect from the same port");
		}
		if use_ret == -(-0x6700)
		{
			snprintf(buf, buflen, "SSL - Record header looks valid but is not expected");
		}
		if use_ret == -(-0x2080)
		{
			snprintf(buf, buflen, "X509 - Unavailable feature, e.g. RSA hashing/encryption combination");
		}
		if use_ret == -(-0x2100)
		{
			snprintf(buf, buflen, "X509 - Requested OID is unknown");
		}
		if use_ret == -(-0x2180)
		{
			snprintf(buf, buflen, "X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected");
		}
		if use_ret == -(-0x2200)
		{
			snprintf(buf, buflen, "X509 - The CRT/CRL/CSR version element is invalid");
		}
		if use_ret == -(-0x2280)
		{
			snprintf(buf, buflen, "X509 - The serial tag or value is invalid");
		}
		if use_ret == -(-0x2300)
		{
			snprintf(buf, buflen, "X509 - The algorithm tag or value is invalid");
		}
		if use_ret == -(-0x2380)
		{
			snprintf(buf, buflen, "X509 - The name tag or value is invalid");
		}
		if use_ret == -(-0x2400)
		{
			snprintf(buf, buflen, "X509 - The date tag or value is invalid");
		}
		if use_ret == -(-0x2480)
		{
			snprintf(buf, buflen, "X509 - The signature tag or value invalid");
		}
		if use_ret == -(-0x2500)
		{
			snprintf(buf, buflen, "X509 - The extension tag or value is invalid");
		}
		if use_ret == -(-0x2580)
		{
			snprintf(buf, buflen, "X509 - CRT/CRL/CSR has an unsupported version number");
		}
		if use_ret == -(-0x2600)
		{
			snprintf(buf, buflen, "X509 - Signature algorithm (oid) is unsupported");
		}
		if use_ret == -(-0x2680)
		{
			snprintf(buf, buflen, "X509 - Signature algorithms do not match. (see \\c ::mbedtls_x509_crt sig_oid)");
		}
		if use_ret == -(-0x2700)
		{
			snprintf(buf, buflen, "X509 - Certificate verification failed, e.g. CRL, CA or signature check failed");
		}
		if use_ret == -(-0x2780)
		{
			snprintf(buf, buflen, "X509 - Format not recognized as DER or PEM");
		}
		if use_ret == -(-0x2800)
		{
			snprintf(buf, buflen, "X509 - Input invalid");
		}
		if use_ret == -(-0x2880)
		{
			snprintf(buf, buflen, "X509 - Allocation of memory failed");
		}
		if use_ret == -(-0x2900)
		{
			snprintf(buf, buflen, "X509 - Read/write of file failed");
		}
		if use_ret == -(-0x2980)
		{
			snprintf(buf, buflen, "X509 - Destination buffer is too small");
		}
		if strlen(buf) == 0
		{
			snprintf(buf, buflen, "UNKNOWN ERROR CODE (%04X)", use_ret);
		}
	}
	use_ret = ret & ~0xFF80;
	if use_ret == 0
	{
		return;
	}
	len = strlen(buf);
	if len > 0
	{
		if buflen - len < 5
		{
			return;
		}
		snprintf(buf + len, buflen - len, " : ");
		buf += len + 3;
		buflen -= len + 3;
	}
	if use_ret == -(-0x0020)
	{
		snprintf(buf, buflen, "AES - Invalid key length");
	}
	if use_ret == -(-0x0022)
	{
		snprintf(buf, buflen, "AES - Invalid data input length");
	}
	if use_ret == -(-0x0060)
	{
		snprintf(buf, buflen, "ASN1 - Out of data when parsing an ASN1 data structure");
	}
	if use_ret == -(-0x0062)
	{
		snprintf(buf, buflen, "ASN1 - ASN1 tag was of an unexpected value");
	}
	if use_ret == -(-0x0064)
	{
		snprintf(buf, buflen, "ASN1 - Error when trying to determine the length or invalid length");
	}
	if use_ret == -(-0x0066)
	{
		snprintf(buf, buflen, "ASN1 - Actual length differs from expected length");
	}
	if use_ret == -(-0x0068)
	{
		snprintf(buf, buflen, "ASN1 - Data is invalid. (not used)");
	}
	if use_ret == -(-0x006A)
	{
		snprintf(buf, buflen, "ASN1 - Memory allocation failed");
	}
	if use_ret == -(-0x006C)
	{
		snprintf(buf, buflen, "ASN1 - Buffer too small when writing ASN.1 data structure");
	}
	if use_ret == -(-0x002A)
	{
		snprintf(buf, buflen, "BASE64 - Output buffer too small");
	}
	if use_ret == -(-0x002C)
	{
		snprintf(buf, buflen, "BASE64 - Invalid character in input");
	}
	if use_ret == -(-0x0002)
	{
		snprintf(buf, buflen, "BIGNUM - An error occurred while reading from or writing to a file");
	}
	if use_ret == -(-0x0004)
	{
		snprintf(buf, buflen, "BIGNUM - Bad input parameters to function");
	}
	if use_ret == -(-0x0006)
	{
		snprintf(buf, buflen, "BIGNUM - There is an invalid character in the digit string");
	}
	if use_ret == -(-0x0008)
	{
		snprintf(buf, buflen, "BIGNUM - The buffer is too small to write to");
	}
	if use_ret == -(-0x000A)
	{
		snprintf(buf, buflen, "BIGNUM - The input arguments are negative or result in illegal output");
	}
	if use_ret == -(-0x000C)
	{
		snprintf(buf, buflen, "BIGNUM - The input argument for division is zero, which is not allowed");
	}
	if use_ret == -(-0x000E)
	{
		snprintf(buf, buflen, "BIGNUM - The input arguments are not acceptable");
	}
	if use_ret == -(-0x0010)
	{
		snprintf(buf, buflen, "BIGNUM - Memory allocation failed");
	}
	if use_ret == -(-0x0016)
	{
		snprintf(buf, buflen, "BLOWFISH - Invalid key length");
	}
	if use_ret == -(-0x0018)
	{
		snprintf(buf, buflen, "BLOWFISH - Invalid data input length");
	}
	if use_ret == -(-0x0024)
	{
		snprintf(buf, buflen, "CAMELLIA - Invalid key length");
	}
	if use_ret == -(-0x0026)
	{
		snprintf(buf, buflen, "CAMELLIA - Invalid data input length");
	}
	if use_ret == -(-0x000D)
	{
		snprintf(buf, buflen, "CCM - Bad input parameters to function");
	}
	if use_ret == -(-0x000F)
	{
		snprintf(buf, buflen, "CCM - Authenticated decryption failed");
	}
	if use_ret == -(-0x0034)
	{
		snprintf(buf, buflen, "CTR_DRBG - The entropy source failed");
	}
	if use_ret == -(-0x0036)
	{
		snprintf(buf, buflen, "CTR_DRBG - Too many random requested in single call");
	}
	if use_ret == -(-0x0038)
	{
		snprintf(buf, buflen, "CTR_DRBG - Input too large (Entropy + additional)");
	}
	if use_ret == -(-0x003A)
	{
		snprintf(buf, buflen, "CTR_DRBG - Read/write error in file");
	}
	if use_ret == -(-0x0032)
	{
		snprintf(buf, buflen, "DES - The data input has an invalid length");
	}
	if use_ret == -(-0x003C)
	{
		snprintf(buf, buflen, "ENTROPY - Critical entropy source failure");
	}
	if use_ret == -(-0x003E)
	{
		snprintf(buf, buflen, "ENTROPY - No more sources can be added");
	}
	if use_ret == -(-0x0040)
	{
		snprintf(buf, buflen, "ENTROPY - No sources have been added to poll");
	}
	if use_ret == -(-0x003D)
	{
		snprintf(buf, buflen, "ENTROPY - No strong sources have been added to poll");
	}
	if use_ret == -(-0x003F)
	{
		snprintf(buf, buflen, "ENTROPY - Read/write error in file");
	}
	if use_ret == -(-0x0012)
	{
		snprintf(buf, buflen, "GCM - Authenticated decryption failed");
	}
	if use_ret == -(-0x0014)
	{
		snprintf(buf, buflen, "GCM - Bad input parameters to function");
	}
	if use_ret == -(-0x0003)
	{
		snprintf(buf, buflen, "HMAC_DRBG - Too many random requested in single call");
	}
	if use_ret == -(-0x0005)
	{
		snprintf(buf, buflen, "HMAC_DRBG - Input too large (Entropy + additional)");
	}
	if use_ret == -(-0x0007)
	{
		snprintf(buf, buflen, "HMAC_DRBG - Read/write error in file");
	}
	if use_ret == -(-0x0009)
	{
		snprintf(buf, buflen, "HMAC_DRBG - The entropy source failed");
	}
	if use_ret == -(-0x002E)
	{
		snprintf(buf, buflen, "OID - OID is not found");
	}
	if use_ret == -(-0x000B)
	{
		snprintf(buf, buflen, "OID - output buffer is too small");
	}
	if use_ret == -(-0x0030)
	{
		snprintf(buf, buflen, "PADLOCK - Input data should be aligned");
	}
	if use_ret == -(-0x001A)
	{
		snprintf(buf, buflen, "THREADING - The selected feature is not available");
	}
	if use_ret == -(-0x001C)
	{
		snprintf(buf, buflen, "THREADING - Bad input parameters to function");
	}
	if use_ret == -(-0x001E)
	{
		snprintf(buf, buflen, "THREADING - Locking / unlocking / free failed with error code");
	}
	if use_ret == -(-0x0028)
	{
		snprintf(buf, buflen, "XTEA - The data input has an invalid length");
	}
	if strlen(buf) != 0
	{
		return;
	}
	snprintf(buf, buflen, "UNKNOWN ERROR CODE (%04X)", use_ret);
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_gcm_init(mbedtls_gcm_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_gcm_context));
}

fn gcm_gen_table(mbedtls_gcm_context * ctx) -> i32
{
	i32 ret, i, j;
	u64 hi, lo;
	u64 vl, vh;
	u8 h[16];
	usize olen = 0;
	memset(h, 0, 16);
	if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, h, 16, h, &olen)) != 0
	{
		return ret;
	}
	{
		(hi) = ((u32)(h)[(0)] << 24) | ((u32)(h)[(0) + 1] << 16) | ((u32)(h)[(0) + 2] << 8) | ((u32)(h)[(0) + 3]);
	};
	{
		(lo) = ((u32)(h)[(4)] << 24) | ((u32)(h)[(4) + 1] << 16) | ((u32)(h)[(4) + 2] << 8) | ((u32)(h)[(4) + 3]);
	};
	vh = (u64) hi << 32 | lo;
	{
		(hi) = ((u32)(h)[(8)] << 24) | ((u32)(h)[(8) + 1] << 16) | ((u32)(h)[(8) + 2] << 8) | ((u32)(h)[(8) + 3]);
	};
	{
		(lo) = ((u32)(h)[(12)] << 24) | ((u32)(h)[(12) + 1] << 16) | ((u32)(h)[(12) + 2] << 8) | ((u32)(h)[(12) + 3]);
	};
	vl = (u64) hi << 32 | lo;
	ctx.HL[8] = vl;
	ctx.HH[8] = vh;
	if mbedtls_aesni_has_support(0x00000002u)
	{
		return 0;
	}
	ctx.HH[0] = 0;
	ctx.HL[0] = 0;
	for (i = 4; i > 0; i >>= 1)
	{
		u32 T = (vl & 1) * 0xe1000000U;
		vl = (vh << 63) | (vl >> 1);
		vh = (vh >> 1) ^ ((u64) T << 32);
		ctx.HL[i] = vl;
		ctx.HH[i] = vh;
	}
	for (i = 2; i <= 8; i *= 2)
	{
		u64 *HiL = ctx.HL + i, *HiH = ctx.HH + i;
		vh = *HiH;
		vl = *HiL;
		for (j = 1; j < i; j++)
		{
			HiH[j] = vh ^ ctx.HH[j];
			HiL[j] = vl ^ ctx.HL[j];
		}
	}
	return 0;
}

pub fn mbedtls_gcm_setkey(mbedtls_gcm_context * ctx, mbedtls_cipher_id_t cipher, const u8 * key, u32 keybits) -> i32
{
	i32 ret;
	const mbedtls_cipher_info_t * cipher_info;
	cipher_info = mbedtls_cipher_info_from_values(cipher, keybits, MBEDTLS_MODE_ECB);
	if cipher_info == NULL
	{
		return -0x0014;
	}
	if cipher_info.block_size != 16
	{
		return -0x0014;
	}
	mbedtls_cipher_free(&ctx.cipher_ctx);
	if (ret = mbedtls_cipher_setup(&ctx.cipher_ctx, cipher_info)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_cipher_setkey(&ctx.cipher_ctx, key, keybits, MBEDTLS_ENCRYPT)) != 0
	{
		return ret;
	}
	if (ret = gcm_gen_table(ctx)) != 0
	{
		return ret;
	}
	return 0;
}

static const u64 last4[16] = {0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0, 0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0};
fn gcm_mult(mbedtls_gcm_context * ctx, const u8 x[16], u8 output[16])
{
	i32 i = 0;
	u8 lo, hi, rem;
	u64 zh, zl;
	if mbedtls_aesni_has_support(0x00000002u)
	{
		u8 h[16];
		{
			(h)[(0)] = (i8) ((ctx.HH[8] >> 32) >> 24);
			(h)[(0) + 1] = (i8) ((ctx.HH[8] >> 32) >> 16);
			(h)[(0) + 2] = (i8) ((ctx.HH[8] >> 32) >> 8);
			(h)[(0) + 3] = (i8) ((ctx.HH[8] >> 32));
		};
		{
			(h)[(4)] = (i8) ((ctx.HH[8]) >> 24);
			(h)[(4) + 1] = (i8) ((ctx.HH[8]) >> 16);
			(h)[(4) + 2] = (i8) ((ctx.HH[8]) >> 8);
			(h)[(4) + 3] = (i8) ((ctx.HH[8]));
		};
		{
			(h)[(8)] = (i8) ((ctx.HL[8] >> 32) >> 24);
			(h)[(8) + 1] = (i8) ((ctx.HL[8] >> 32) >> 16);
			(h)[(8) + 2] = (i8) ((ctx.HL[8] >> 32) >> 8);
			(h)[(8) + 3] = (i8) ((ctx.HL[8] >> 32));
		};
		{
			(h)[(12)] = (i8) ((ctx.HL[8]) >> 24);
			(h)[(12) + 1] = (i8) ((ctx.HL[8]) >> 16);
			(h)[(12) + 2] = (i8) ((ctx.HL[8]) >> 8);
			(h)[(12) + 3] = (i8) ((ctx.HL[8]));
		};
		mbedtls_aesni_gcm_mult(output, x, h);
		return;
	}
	lo = x[15] & 0xf;
	zh = ctx.HH[lo];
	zl = ctx.HL[lo];
	for (i = 15; i >= 0; i--)
	{
		lo = x[i] & 0xf;
		hi = x[i] >> 4;
		if i != 15
		{
			rem = (i8) zl & 0xf;
			zl = (zh << 60) | (zl >> 4);
			zh = (zh >> 4);
			zh ^= (u64) last4[rem] << 48;
			zh ^= ctx.HH[lo];
			zl ^= ctx.HL[lo];
		}
		rem = (i8) zl & 0xf;
		zl = (zh << 60) | (zl >> 4);
		zh = (zh >> 4);
		zh ^= (u64) last4[rem] << 48;
		zh ^= ctx.HH[hi];
		zl ^= ctx.HL[hi];
	}
	{
		(output)[(0)] = (i8) ((zh >> 32) >> 24);
		(output)[(0) + 1] = (i8) ((zh >> 32) >> 16);
		(output)[(0) + 2] = (i8) ((zh >> 32) >> 8);
		(output)[(0) + 3] = (i8) ((zh >> 32));
	};
	{
		(output)[(4)] = (i8) ((zh) >> 24);
		(output)[(4) + 1] = (i8) ((zh) >> 16);
		(output)[(4) + 2] = (i8) ((zh) >> 8);
		(output)[(4) + 3] = (i8) ((zh));
	};
	{
		(output)[(8)] = (i8) ((zl >> 32) >> 24);
		(output)[(8) + 1] = (i8) ((zl >> 32) >> 16);
		(output)[(8) + 2] = (i8) ((zl >> 32) >> 8);
		(output)[(8) + 3] = (i8) ((zl >> 32));
	};
	{
		(output)[(12)] = (i8) ((zl) >> 24);
		(output)[(12) + 1] = (i8) ((zl) >> 16);
		(output)[(12) + 2] = (i8) ((zl) >> 8);
		(output)[(12) + 3] = (i8) ((zl));
	};
}

pub fn mbedtls_gcm_starts(mbedtls_gcm_context * ctx, i32 mode, const u8 * iv, usize iv_len, const u8 * add, usize add_len) -> i32
{
	i32 ret;
	u8 work_buf[16];
	usize i;
	const u8 * p;
	usize use_len, olen = 0;
	if ((u64) iv_len) >> 61 != 0 || ((u64) add_len) >> 61 != 0
	{
		return -0x0014;
	}
	memset(ctx.y, 0x00, sizeof(ctx.y));
	memset(ctx.buf, 0x00, sizeof(ctx.buf));
	ctx.mode = mode;
	ctx.len = 0;
	ctx.add_len = 0;
	if iv_len == 12
	{
		memcpy(ctx.y, iv, iv_len);
		ctx.y[15] = 1;
	}
	else
	{
		memset(work_buf, 0x00, 16);
		{
			(work_buf)[(12)] = (i8) ((iv_len * 8) >> 24);
			(work_buf)[(12) + 1] = (i8) ((iv_len * 8) >> 16);
			(work_buf)[(12) + 2] = (i8) ((iv_len * 8) >> 8);
			(work_buf)[(12) + 3] = (i8) ((iv_len * 8));
		};
		p = iv;
		while (iv_len > 0)
		{
			use_len = (iv_len < 16) ? iv_len : 16;
			for (i = 0; i < use_len; i++)
			{
				ctx.y[i] ^= p[i];
			}
			gcm_mult(ctx, ctx.y, ctx.y);
			iv_len -= use_len;
			p += use_len;
		}
		for (i = 0; i < 16; i++)
		{
			ctx.y[i] ^= work_buf[i];
		}
		gcm_mult(ctx, ctx.y, ctx.y);
	}
	if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, ctx.y, 16, ctx.base_ectr, &olen)) != 0
	{
		return ret;
	}
	ctx.add_len = add_len;
	p = add;
	while (add_len > 0)
	{
		use_len = (add_len < 16) ? add_len : 16;
		for (i = 0; i < use_len; i++)
		{
			ctx.buf[i] ^= p[i];
		}
		gcm_mult(ctx, ctx.buf, ctx.buf);
		add_len -= use_len;
		p += use_len;
	}
	return 0;
}

pub fn mbedtls_gcm_update(mbedtls_gcm_context * ctx, usize length, const u8 * input, u8 * output) -> i32
{
	i32 ret;
	u8 ectr[16];
	usize i;
	const u8 * p;
	u8 * out_p = output;
	usize use_len, olen = 0;
	if output > input && (usize)(output - input) < length
	{
		return -0x0014;
	}
	if ctx.len + length < ctx.len || (u64) ctx.len + length > 0xFFFFFFFE0ull
	{
		return -0x0014;
	}
	ctx.len += length;
	p = input;
	while (length > 0)
	{
		use_len = (length < 16) ? length : 16;
		for (i = 16; i > 12; i--)
			if ++ctx.y[i - 1] != 0
			{
				break;

			}
		if (ret = mbedtls_cipher_update(&ctx.cipher_ctx, ctx.y, 16, ectr, &olen)) != 0
		{
			return ret;
		}
		for (i = 0; i < use_len; i++)
		{
			if ctx.mode == 0
			{
				ctx.buf[i] ^= p[i];
			}
			out_p[i] = ectr[i] ^ p[i];
			if ctx.mode == 1
			{
				ctx.buf[i] ^= out_p[i];
			}
		}
		gcm_mult(ctx, ctx.buf, ctx.buf);
		length -= use_len;
		p += use_len;
		out_p += use_len;
	}
	return 0;
}

pub fn mbedtls_gcm_finish(mbedtls_gcm_context * ctx, u8 * tag, usize tag_len) -> i32
{
	u8 work_buf[16];
	usize i;
	u64 orig_len = ctx.len * 8;
	u64 orig_add_len = ctx.add_len * 8;
	if tag_len > 16 || tag_len < 4
	{
		return -0x0014;
	}
	if tag_len != 0
	{
		memcpy(tag, ctx.base_ectr, tag_len);
	}
	if orig_len || orig_add_len
	{
		memset(work_buf, 0x00, 16);
		{
			(work_buf)[(0)] = (i8) (((orig_add_len >> 32)) >> 24);
			(work_buf)[(0) + 1] = (i8) (((orig_add_len >> 32)) >> 16);
			(work_buf)[(0) + 2] = (i8) (((orig_add_len >> 32)) >> 8);
			(work_buf)[(0) + 3] = (i8) (((orig_add_len >> 32)));
		};
		{
			(work_buf)[(4)] = (i8) (((orig_add_len)) >> 24);
			(work_buf)[(4) + 1] = (i8) (((orig_add_len)) >> 16);
			(work_buf)[(4) + 2] = (i8) (((orig_add_len)) >> 8);
			(work_buf)[(4) + 3] = (i8) (((orig_add_len)));
		};
		{
			(work_buf)[(8)] = (i8) (((orig_len >> 32)) >> 24);
			(work_buf)[(8) + 1] = (i8) (((orig_len >> 32)) >> 16);
			(work_buf)[(8) + 2] = (i8) (((orig_len >> 32)) >> 8);
			(work_buf)[(8) + 3] = (i8) (((orig_len >> 32)));
		};
		{
			(work_buf)[(12)] = (i8) (((orig_len)) >> 24);
			(work_buf)[(12) + 1] = (i8) (((orig_len)) >> 16);
			(work_buf)[(12) + 2] = (i8) (((orig_len)) >> 8);
			(work_buf)[(12) + 3] = (i8) (((orig_len)));
		};
		for (i = 0; i < 16; i++)
		{
			ctx.buf[i] ^= work_buf[i];
		}
		gcm_mult(ctx, ctx.buf, ctx.buf);
		for (i = 0; i < tag_len; i++)
		{
			tag[i] ^= ctx.buf[i];
		}
	}
	return 0;
}

pub fn mbedtls_gcm_crypt_and_tag(mbedtls_gcm_context * ctx, i32 mode, usize length, const u8 * iv, usize iv_len, const u8 * add, usize add_len, const u8 * input, u8 * output, usize tag_len, u8 * tag) -> i32
{
	i32 ret;
	if (ret = mbedtls_gcm_starts(ctx, mode, iv, iv_len, add, add_len)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_gcm_update(ctx, length, input, output)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_gcm_finish(ctx, tag, tag_len)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_gcm_auth_decrypt(mbedtls_gcm_context * ctx, usize length, const u8 * iv, usize iv_len, const u8 * add, usize add_len, const u8 * tag, usize tag_len, const u8 * input, u8 * output) -> i32
{
	i32 ret;
	u8 check_tag[16];
	usize i;
	i32 diff;
	if (ret = mbedtls_gcm_crypt_and_tag(ctx, 0, length, iv, iv_len, add, add_len, input, output, tag_len, check_tag)) != 0
	{
		return ret;
	}
	for (diff = 0, i = 0; i < tag_len; i++)
	{
		diff |= tag[i] ^ check_tag[i];
	}
	if diff != 0
	{
		zeroize(output, length);
		return -0x0012;
	}
	return 0;
}

pub fn mbedtls_gcm_free(mbedtls_gcm_context * ctx)
{
	mbedtls_cipher_free(&ctx.cipher_ctx);
	zeroize(ctx, sizeof(mbedtls_gcm_context));
}

static const i32 key_index[6] = {0, 0, 1, 1, 1, 1};
static const u8 key[6][32] =
{
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08},
};
static const usize iv_len[6] = {12, 12, 12, 12, 8, 60};
static const i32 iv_index[6] = {0, 0, 1, 1, 1, 2};
static const u8 iv[6][64] =
{
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88}, {0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa, 0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28, 0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54, 0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 0xa6, 0x37, 0xb3, 0x9b},
};
static const usize add_len[6] = {0, 0, 0, 20, 20, 20};
static const i32 add_index[6] = {0, 0, 0, 1, 1, 1};
static const u8 additional[6][64] =
{
	{0x00}, {0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xab, 0xad, 0xda, 0xd2},
};
static const usize pt_len[6] = {0, 16, 64, 60, 60, 60};
static const i32 pt_index[6] = {0, 0, 1, 1, 1, 1};
static const u8 pt[6][64] =
{
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55},
};
static const u8 ct[6 * 3][64] =
{
	{0x00}, {0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78}, {0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85}, {0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91}, {0x61, 0x35, 0x3b, 0x4c, 0x28, 0x06, 0x93, 0x4a, 0x77, 0x7f, 0xf5, 0x1f, 0xa2, 0x2a, 0x47, 0x55, 0x69, 0x9b, 0x2a, 0x71, 0x4f, 0xcd, 0xc6, 0xf8, 0x37, 0x66, 0xe5, 0xf9, 0x7b, 0x6c, 0x74, 0x23, 0x73, 0x80, 0x69, 0x00, 0xe4, 0x9f, 0x24, 0xb2, 0x2b, 0x09, 0x75, 0x44, 0xd4, 0x89, 0x6b, 0x42, 0x49, 0x89, 0xb5, 0xe1, 0xeb, 0xac, 0x0f, 0x07, 0xc2, 0x3f, 0x45, 0x98}, {0x8c, 0xe2, 0x49, 0x98, 0x62, 0x56, 0x15, 0xb6, 0x03, 0xa0, 0x33, 0xac, 0xa1, 0x3f, 0xb8, 0x94, 0xbe, 0x91, 0x12, 0xa5, 0xc3, 0xa2, 0x11, 0xa8, 0xba, 0x26, 0x2a, 0x3c, 0xca, 0x7e, 0x2c, 0xa7, 0x01, 0xe4, 0xa9, 0xa4, 0xfb, 0xa4, 0x3c, 0x90, 0xcc, 0xdc, 0xb2, 0x81, 0xd4, 0x8c, 0x7c, 0x6f, 0xd6, 0x28, 0x75, 0xd2, 0xac, 0xa4, 0x17, 0x03, 0x4c, 0x34, 0xae, 0xe5}, {0x00}, {0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41, 0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6, 0x00}, {0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57, 0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25, 0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9, 0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56}, {0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57, 0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25, 0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9, 0xcc, 0xda, 0x27, 0x10}, {0x0f, 0x10, 0xf5, 0x99, 0xae, 0x14, 0xa1, 0x54, 0xed, 0x24, 0xb3, 0x6e, 0x25, 0x32, 0x4d, 0xb8, 0xc5, 0x66, 0x63, 0x2e, 0xf2, 0xbb, 0xb3, 0x4f, 0x83, 0x47, 0x28, 0x0f, 0xc4, 0x50, 0x70, 0x57, 0xfd, 0xdc, 0x29, 0xdf, 0x9a, 0x47, 0x1f, 0x75, 0xc6, 0x65, 0x41, 0xd4, 0xd4, 0xda, 0xd1, 0xc9, 0xe9, 0x3a, 0x19, 0xa5, 0x8e, 0x8b, 0x47, 0x3f, 0xa0, 0xf0, 0x62, 0xf7}, {0xd2, 0x7e, 0x88, 0x68, 0x1c, 0xe3, 0x24, 0x3c, 0x48, 0x30, 0x16, 0x5a, 0x8f, 0xdc, 0xf9, 0xff, 0x1d, 0xe9, 0xa1, 0xd8, 0xe6, 0xb4, 0x47, 0xef, 0x6e, 0xf7, 0xb7, 0x98, 0x28, 0x66, 0x6e, 0x45, 0x81, 0xe7, 0x90, 0x12, 0xaf, 0x34, 0xdd, 0xd9, 0xe2, 0xf0, 0x37, 0x58, 0x9b, 0x29, 0x2d, 0xb3, 0xe6, 0x7c, 0x03, 0x67, 0x45, 0xfa, 0x22, 0xe7, 0xe9, 0xb7, 0x37, 0x3b}, {0x00}, {0xce, 0xa7, 0x40, 0x3d, 0x4d, 0x60, 0x6b, 0x6e, 0x07, 0x4e, 0xc5, 0xd3, 0xba, 0xf3, 0x9d, 0x18}, {0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d, 0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad}, {0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d, 0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62}, {0xc3, 0x76, 0x2d, 0xf1, 0xca, 0x78, 0x7d, 0x32, 0xae, 0x47, 0xc1, 0x3b, 0xf1, 0x98, 0x44, 0xcb, 0xaf, 0x1a, 0xe1, 0x4d, 0x0b, 0x97, 0x6a, 0xfa, 0xc5, 0x2f, 0xf7, 0xd7, 0x9b, 0xba, 0x9d, 0xe0, 0xfe, 0xb5, 0x82, 0xd3, 0x39, 0x34, 0xa4, 0xf0, 0x95, 0x4c, 0xc2, 0x36, 0x3b, 0xc7, 0x3f, 0x78, 0x62, 0xac, 0x43, 0x0e, 0x64, 0xab, 0xe4, 0x99, 0xf4, 0x7c, 0x9b, 0x1f}, {0x5a, 0x8d, 0xef, 0x2f, 0x0c, 0x9e, 0x53, 0xf1, 0xf7, 0x5d, 0x78, 0x53, 0x65, 0x9e, 0x2a, 0x20, 0xee, 0xb2, 0xb2, 0x2a, 0xaf, 0xde, 0x64, 0x19, 0xa0, 0x58, 0xab, 0x4f, 0x6f, 0x74, 0x6b, 0xf4, 0x0f, 0xc0, 0xc3, 0xb7, 0x80, 0xf2, 0x44, 0x45, 0x2d, 0xa3, 0xeb, 0xf1, 0xc5, 0xd8, 0x2c, 0xde, 0xa2, 0x41, 0x89, 0x97, 0x20, 0x0e, 0xf8, 0x2e, 0x44, 0xae, 0x7e, 0x3f},
};
static const u8 tag[6 * 3][16] =
{
	{0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61, 0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a}, {0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd, 0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf}, {0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6, 0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4}, {0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb, 0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47}, {0x36, 0x12, 0xd2, 0xe7, 0x9e, 0x3b, 0x07, 0x85, 0x56, 0x1b, 0xe1, 0x4a, 0xac, 0xa2, 0xfc, 0xcb}, {0x61, 0x9c, 0xc5, 0xae, 0xff, 0xfe, 0x0b, 0xfa, 0x46, 0x2a, 0xf4, 0x3c, 0x16, 0x99, 0xd0, 0x50}, {0xcd, 0x33, 0xb2, 0x8a, 0xc7, 0x73, 0xf7, 0x4b, 0xa0, 0x0e, 0xd1, 0xf3, 0x12, 0x57, 0x24, 0x35}, {0x2f, 0xf5, 0x8d, 0x80, 0x03, 0x39, 0x27, 0xab, 0x8e, 0xf4, 0xd4, 0x58, 0x75, 0x14, 0xf0, 0xfb}, {0x99, 0x24, 0xa7, 0xc8, 0x58, 0x73, 0x36, 0xbf, 0xb1, 0x18, 0x02, 0x4d, 0xb8, 0x67, 0x4a, 0x14}, {0x25, 0x19, 0x49, 0x8e, 0x80, 0xf1, 0x47, 0x8f, 0x37, 0xba, 0x55, 0xbd, 0x6d, 0x27, 0x61, 0x8c}, {0x65, 0xdc, 0xc5, 0x7f, 0xcf, 0x62, 0x3a, 0x24, 0x09, 0x4f, 0xcc, 0xa4, 0x0d, 0x35, 0x33, 0xf8}, {0xdc, 0xf5, 0x66, 0xff, 0x29, 0x1c, 0x25, 0xbb, 0xb8, 0x56, 0x8f, 0xc3, 0xd3, 0x76, 0xa6, 0xd9}, {0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9, 0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b}, {0xd0, 0xd1, 0xc8, 0xa7, 0x99, 0x99, 0x6b, 0xf0, 0x26, 0x5b, 0x98, 0xb5, 0xd4, 0x8a, 0xb9, 0x19}, {0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd, 0xec, 0x1a, 0x50, 0x22, 0x70, 0xe3, 0xcc, 0x6c}, {0x76, 0xfc, 0x6e, 0xce, 0x0f, 0x4e, 0x17, 0x68, 0xcd, 0xdf, 0x88, 0x53, 0xbb, 0x2d, 0x55, 0x1b}, {0x3a, 0x33, 0x7d, 0xbf, 0x46, 0xa7, 0x92, 0xc4, 0x5e, 0x45, 0x49, 0x13, 0xfe, 0x2e, 0xa8, 0xf2}, {0xa4, 0x4a, 0x82, 0x66, 0xee, 0x1c, 0x8e, 0xb0, 0xc8, 0xb5, 0xd4, 0xcf, 0x5a, 0xe9, 0xf1, 0x9a},
};
pub fn mbedtls_gcm_self_test(i32 verbose) -> i32
{
	mbedtls_gcm_context ctx;
	u8 buf[64];
	u8 tag_buf[16];
	i32 i, j, ret;
	mbedtls_cipher_id_t cipher = MBEDTLS_CIPHER_ID_AES;
	mbedtls_gcm_init(&ctx);
	for (j = 0; j < 3; j++)
	{
		i32 key_len = 128 + 64 * j;
		for (i = 0; i < 6; i++)
		{
			if verbose != 0
			{
				printf("  AES-GCM-%3d #%d (%s): ", key_len, i, "enc");
			}
			mbedtls_gcm_setkey(&ctx, cipher, key[key_index[i]], key_len);
			ret = mbedtls_gcm_crypt_and_tag(&ctx, 1, pt_len[i], iv[iv_index[i]], iv_len[i], additional[add_index[i]], add_len[i], pt[pt_index[i]], buf, 16, tag_buf);
			if ret != 0 || memcmp(buf, ct[j * 6 + i], pt_len[i]) != 0 || memcmp(tag_buf, tag[j * 6 + i], 16) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
			mbedtls_gcm_free(&ctx);
			if verbose != 0
			{
				printf("passed\n");
			}
			if verbose != 0
			{
				printf("  AES-GCM-%3d #%d (%s): ", key_len, i, "dec");
			}
			mbedtls_gcm_setkey(&ctx, cipher, key[key_index[i]], key_len);
			ret = mbedtls_gcm_crypt_and_tag(&ctx, 0, pt_len[i], iv[iv_index[i]], iv_len[i], additional[add_index[i]], add_len[i], ct[j * 6 + i], buf, 16, tag_buf);
			if ret != 0 || memcmp(buf, pt[pt_index[i]], pt_len[i]) != 0 || memcmp(tag_buf, tag[j * 6 + i], 16) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
			mbedtls_gcm_free(&ctx);
			if verbose != 0
			{
				printf("passed\n");
			}
			if verbose != 0
			{
				printf("  AES-GCM-%3d #%d split (%s): ", key_len, i, "enc");
			}
			mbedtls_gcm_setkey(&ctx, cipher, key[key_index[i]], key_len);
			ret = mbedtls_gcm_starts(&ctx, 1, iv[iv_index[i]], iv_len[i], additional[add_index[i]], add_len[i]);
			if ret != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
			if pt_len[i] > 32
			{
				usize rest_len = pt_len[i] - 32;
				ret = mbedtls_gcm_update(&ctx, 32, pt[pt_index[i]], buf);
				if ret != 0
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
				ret = mbedtls_gcm_update(&ctx, rest_len, pt[pt_index[i]] + 32, buf + 32);
				if ret != 0
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
			}
			else
			{
				ret = mbedtls_gcm_update(&ctx, pt_len[i], pt[pt_index[i]], buf);
				if ret != 0
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
			}
			ret = mbedtls_gcm_finish(&ctx, tag_buf, 16);
			if ret != 0 || memcmp(buf, ct[j * 6 + i], pt_len[i]) != 0 || memcmp(tag_buf, tag[j * 6 + i], 16) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
			mbedtls_gcm_free(&ctx);
			if verbose != 0
			{
				printf("passed\n");
			}
			if verbose != 0
			{
				printf("  AES-GCM-%3d #%d split (%s): ", key_len, i, "dec");
			}
			mbedtls_gcm_setkey(&ctx, cipher, key[key_index[i]], key_len);
			ret = mbedtls_gcm_starts(&ctx, 0, iv[iv_index[i]], iv_len[i], additional[add_index[i]], add_len[i]);
			if ret != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
			if pt_len[i] > 32
			{
				usize rest_len = pt_len[i] - 32;
				ret = mbedtls_gcm_update(&ctx, 32, ct[j * 6 + i], buf);
				if ret != 0
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
				ret = mbedtls_gcm_update(&ctx, rest_len, ct[j * 6 + i] + 32, buf + 32);
				if ret != 0
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
			}
			else
			{
				ret = mbedtls_gcm_update(&ctx, pt_len[i], ct[j * 6 + i], buf);
				if ret != 0
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
			}
			ret = mbedtls_gcm_finish(&ctx, tag_buf, 16);
			if ret != 0 || memcmp(buf, pt[pt_index[i]], pt_len[i]) != 0 || memcmp(tag_buf, tag[j * 6 + i], 16) != 0
			{
				if verbose != 0
				{
					printf("failed\n");
				}
				return 1;
			}
			mbedtls_gcm_free(&ctx);
			if verbose != 0
			{
				printf("passed\n");
			}
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
	return 0;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_hmac_drbg_init(mbedtls_hmac_drbg_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_hmac_drbg_context));
	mbedtls_mutex_init(&ctx.mutex);
}

pub fn mbedtls_hmac_drbg_update(mbedtls_hmac_drbg_context * ctx, const u8 * additional, usize add_len)
{
	usize md_len = mbedtls_md_get_size(ctx.md_ctx.md_info);
	u8 rounds = (additional != NULL && add_len != 0) ? 2 : 1;
	u8 sep[1];
	u8 K[64];
	for (sep[0] = 0; sep[0] < rounds; sep[0]++)
	{
		mbedtls_md_hmac_reset(&ctx.md_ctx);
		mbedtls_md_hmac_update(&ctx.md_ctx, ctx.V, md_len);
		mbedtls_md_hmac_update(&ctx.md_ctx, sep, 1);
		if rounds == 2
		{
			mbedtls_md_hmac_update(&ctx.md_ctx, additional, add_len);
		}
		mbedtls_md_hmac_finish(&ctx.md_ctx, K);
		mbedtls_md_hmac_starts(&ctx.md_ctx, K, md_len);
		mbedtls_md_hmac_update(&ctx.md_ctx, ctx.V, md_len);
		mbedtls_md_hmac_finish(&ctx.md_ctx, ctx.V);
	}
}

pub fn mbedtls_hmac_drbg_seed_buf(mbedtls_hmac_drbg_context * ctx, const mbedtls_md_info_t * md_info, const u8 * data, usize data_len) -> i32
{
	i32 ret;
	if (ret = mbedtls_md_setup(&ctx.md_ctx, md_info, 1)) != 0
	{
		return ret;
	}
	mbedtls_md_hmac_starts(&ctx.md_ctx, ctx.V, mbedtls_md_get_size(md_info));
	memset(ctx.V, 0x01, mbedtls_md_get_size(md_info));
	mbedtls_hmac_drbg_update(ctx, data, data_len);
	return 0;
}

pub fn mbedtls_hmac_drbg_reseed(mbedtls_hmac_drbg_context * ctx, const u8 * additional, usize len) -> i32
{
	u8 seed[384];
	usize seedlen;
	if len > 256 || ctx.entropy_len + len > 384
	{
		return -0x0005;
	}
	memset(seed, 0, 384);
	if ctx.f_entropy(ctx.p_entropy, seed, ctx.entropy_len) != 0
	{
		return -0x0009;
	}
	seedlen = ctx.entropy_len;
	if additional != NULL && len != 0
	{
		memcpy(seed + seedlen, additional, len);
		seedlen += len;
	}
	mbedtls_hmac_drbg_update(ctx, seed, seedlen);
	ctx.reseed_counter = 1;
	return 0;
}

pub fn mbedtls_hmac_drbg_seed(mbedtls_hmac_drbg_context * ctx, const mbedtls_md_info_t * md_info, i32 (*f_entropy)(void *, u8 *, usize), void * p_entropy, const u8 * custom, usize len) -> i32
{
	i32 ret;
	usize entropy_len, md_size;
	if (ret = mbedtls_md_setup(&ctx.md_ctx, md_info, 1)) != 0
	{
		return ret;
	}
	md_size = mbedtls_md_get_size(md_info);
	mbedtls_md_hmac_starts(&ctx.md_ctx, ctx.V, md_size);
	memset(ctx.V, 0x01, md_size);
	ctx.f_entropy = f_entropy;
	ctx.p_entropy = p_entropy;
	ctx.reseed_interval = 10000;
	entropy_len = md_size <= 20 ? 16 : md_size <= 28 ? 24 : 32;
	ctx.entropy_len = entropy_len * 3 / 2;
	if (ret = mbedtls_hmac_drbg_reseed(ctx, custom, len)) != 0
	{
		return ret;
	}
	ctx.entropy_len = entropy_len;
	return 0;
}

pub fn mbedtls_hmac_drbg_set_prediction_resistance(mbedtls_hmac_drbg_context * ctx, i32 resistance)
{
	ctx.prediction_resistance = resistance;
}

pub fn mbedtls_hmac_drbg_set_entropy_len(mbedtls_hmac_drbg_context * ctx, usize len)
{
	ctx.entropy_len = len;
}

pub fn mbedtls_hmac_drbg_set_reseed_interval(mbedtls_hmac_drbg_context * ctx, i32 interval)
{
	ctx.reseed_interval = interval;
}

pub fn mbedtls_hmac_drbg_random_with_add(void * p_rng, u8 * output, usize out_len, const u8 * additional, usize add_len) -> i32
{
	i32 ret;
	mbedtls_hmac_drbg_context * ctx = (mbedtls_hmac_drbg_context *) p_rng;
	usize md_len = mbedtls_md_get_size(ctx.md_ctx.md_info);
	usize left = out_len;
	u8 * out = output;
	if out_len > 1024
	{
		return -0x0003;
	}
	if add_len > 256
	{
		return -0x0005;
	}
	if ctx.f_entropy != NULL && (ctx.prediction_resistance == 1 || ctx.reseed_counter > ctx.reseed_interval)
	{
		if (ret = mbedtls_hmac_drbg_reseed(ctx, additional, add_len)) != 0
		{
			return ret;
		}
		add_len = 0;
	}
	if additional != NULL && add_len != 0
	{
		mbedtls_hmac_drbg_update(ctx, additional, add_len);
	}
	while (left != 0)
	{
		usize use_len = left > md_len ? md_len : left;
		mbedtls_md_hmac_reset(&ctx.md_ctx);
		mbedtls_md_hmac_update(&ctx.md_ctx, ctx.V, md_len);
		mbedtls_md_hmac_finish(&ctx.md_ctx, ctx.V);
		memcpy(out, ctx.V, use_len);
		out += use_len;
		left -= use_len;
	}
	mbedtls_hmac_drbg_update(ctx, additional, add_len);
	ctx.reseed_counter++;
	return 0;
}

pub fn mbedtls_hmac_drbg_random(void * p_rng, u8 * output, usize out_len) -> i32
{
	i32 ret;
	mbedtls_hmac_drbg_context * ctx = (mbedtls_hmac_drbg_context *) p_rng;
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	ret = mbedtls_hmac_drbg_random_with_add(ctx, output, out_len, NULL, 0);
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

pub fn mbedtls_hmac_drbg_free(mbedtls_hmac_drbg_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	mbedtls_mutex_free(&ctx.mutex);
	mbedtls_md_free(&ctx.md_ctx);
	zeroize(ctx, sizeof(mbedtls_hmac_drbg_context));
}

pub fn mbedtls_hmac_drbg_write_seed_file(mbedtls_hmac_drbg_context * ctx, const i8 * path) -> i32
{
	i32 ret;
	FILE * f;
	u8 buf[256];
	if (f = fopen(path, "wb")) == NULL
	{
		return -0x0007;
	}
	if (ret = mbedtls_hmac_drbg_random(ctx, buf, sizeof(buf))) != 0
	{
		goto exit;
	}
	if fwrite(buf, 1, sizeof(buf), f) != sizeof(buf)
	{
		ret = -0x0007;
		goto exit;
	}
	ret = 0;
exit:
	fclose(f);
	return ret;
}

pub fn mbedtls_hmac_drbg_update_seed_file(mbedtls_hmac_drbg_context * ctx, const i8 * path) -> i32
{
	FILE * f;
	usize n;
	u8 buf[256];
	if (f = fopen(path, "rb")) == NULL
	{
		return -0x0007;
	}
	fseek(f, 0, SEEK_END);
	n = (usize) ftell(f);
	fseek(f, 0, SEEK_SET);
	if n > 256
	{
		fclose(f);
		return -0x0005;
	}
	if fread(buf, 1, n, f) != n
	{
		fclose(f);
		return -0x0007;
	}
	fclose(f);
	mbedtls_hmac_drbg_update(ctx, buf, n);
	return mbedtls_hmac_drbg_write_seed_file(ctx, path);
}

static const u8 entropy_pr[] = {0xa0, 0xc9, 0xab, 0x58, 0xf1, 0xe2, 0xe5, 0xa4, 0xde, 0x3e, 0xbd, 0x4f, 0xf7, 0x3e, 0x9c, 0x5b, 0x64, 0xef, 0xd8, 0xca, 0x02, 0x8c, 0xf8, 0x11, 0x48, 0xa5, 0x84, 0xfe, 0x69, 0xab, 0x5a, 0xee, 0x42, 0xaa, 0x4d, 0x42, 0x17, 0x60, 0x99, 0xd4, 0x5e, 0x13, 0x97, 0xdc, 0x40, 0x4d, 0x86, 0xa3, 0x7b, 0xf5, 0x59, 0x54, 0x75, 0x69, 0x51, 0xe4};
static const u8 result_pr[80] = {0x9a, 0x00, 0xa2, 0xd0, 0x0e, 0xd5, 0x9b, 0xfe, 0x31, 0xec, 0xb1, 0x39, 0x9b, 0x60, 0x81, 0x48, 0xd1, 0x96, 0x9d, 0x25, 0x0d, 0x3c, 0x1e, 0x94, 0x10, 0x10, 0x98, 0x12, 0x93, 0x25, 0xca, 0xb8, 0xfc, 0xcc, 0x2d, 0x54, 0x73, 0x19, 0x70, 0xc0, 0x10, 0x7a, 0xa4, 0x89, 0x25, 0x19, 0x95, 0x5e, 0x4b, 0xc6, 0x00, 0x1d, 0x7f, 0x4e, 0x6a, 0x2b, 0xf8, 0xa3, 0x01, 0xab, 0x46, 0x05, 0x5c, 0x09, 0xa6, 0x71, 0x88, 0xf1, 0xa7, 0x40, 0xee, 0xf3, 0xe1, 0x5c, 0x02, 0x9b, 0x44, 0xaf, 0x03, 0x44};
static const u8 entropy_nopr[] = {0x79, 0x34, 0x9b, 0xbf, 0x7c, 0xdd, 0xa5, 0x79, 0x95, 0x57, 0x86, 0x66, 0x21, 0xc9, 0x13, 0x83, 0x11, 0x46, 0x73, 0x3a, 0xbf, 0x8c, 0x35, 0xc8, 0xc7, 0x21, 0x5b, 0x5b, 0x96, 0xc4, 0x8e, 0x9b, 0x33, 0x8c, 0x74, 0xe3, 0xe9, 0x9d, 0xfe, 0xdf};
static const u8 result_nopr[80] = {0xc6, 0xa1, 0x6a, 0xb8, 0xd4, 0x20, 0x70, 0x6f, 0x0f, 0x34, 0xab, 0x7f, 0xec, 0x5a, 0xdc, 0xa9, 0xd8, 0xca, 0x3a, 0x13, 0x3e, 0x15, 0x9c, 0xa6, 0xac, 0x43, 0xc6, 0xf8, 0xa2, 0xbe, 0x22, 0x83, 0x4a, 0x4c, 0x0a, 0x0a, 0xff, 0xb1, 0x0d, 0x71, 0x94, 0xf1, 0xc1, 0xa5, 0xcf, 0x73, 0x22, 0xec, 0x1a, 0xe0, 0x96, 0x4e, 0xd4, 0xbf, 0x12, 0x27, 0x46, 0xe0, 0x87, 0xfd, 0xb5, 0xb3, 0xe9, 0x1b, 0x34, 0x93, 0xd5, 0xbb, 0x98, 0xfa, 0xed, 0x49, 0xe8, 0x5f, 0x13, 0x0f, 0xc8, 0xa4, 0x59, 0xb7};
static usize test_offset;
fn hmac_drbg_self_test_entropy(void * data, u8 * buf, usize len) -> i32
{
	const u8 * p = data;
	memcpy(buf, p + test_offset, len);
	test_offset += len;
	return 0;
}

pub fn mbedtls_hmac_drbg_self_test(i32 verbose) -> i32
{
	mbedtls_hmac_drbg_context ctx;
	u8 buf[80];
	const mbedtls_md_info_t * md_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);
	mbedtls_hmac_drbg_init(&ctx);
	if verbose != 0
	{
		printf("  HMAC_DRBG (PR = True) : ");
	}
	test_offset = 0;
	if (mbedtls_hmac_drbg_seed(&ctx, md_info, hmac_drbg_self_test_entropy, (void *) entropy_pr, NULL, 0)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	mbedtls_hmac_drbg_set_prediction_resistance(&ctx, 1);
	if (mbedtls_hmac_drbg_random(&ctx, buf, 80)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_hmac_drbg_random(&ctx, buf, 80)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (memcmp(buf, result_pr, 80)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	mbedtls_hmac_drbg_free(&ctx);
	mbedtls_hmac_drbg_free(&ctx);
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  HMAC_DRBG (PR = False) : ");
	}
	mbedtls_hmac_drbg_init(&ctx);
	test_offset = 0;
	if (mbedtls_hmac_drbg_seed(&ctx, md_info, hmac_drbg_self_test_entropy, (void *) entropy_nopr, NULL, 0)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_hmac_drbg_reseed(&ctx, NULL, 0)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_hmac_drbg_random(&ctx, buf, 80)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (mbedtls_hmac_drbg_random(&ctx, buf, 80)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	if (memcmp(buf, result_nopr, 80)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	};
	mbedtls_hmac_drbg_free(&ctx);
	mbedtls_hmac_drbg_free(&ctx);
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("\n");
	}
	return 0;
}

struct mbedtls_md_info_t
{
	mbedtls_md_type_t type;
	const i8 * name;
	i32 size;
	i32 block_size;
	void (*starts_func)(void * ctx);
	void (*update_func)(void * ctx, const u8 * input, usize ilen);
	void (*finish_func)(void * ctx, u8 * output);
	void (*digest_func)(const u8 * input, usize ilen, u8 * output);
	void * (*ctx_alloc_func)(void);
	void (*ctx_free_func)(void * ctx);
	void (*clone_func)(void * dst, const void * src);
	void (*process_func)(void * ctx, const u8 * input);
};
static  mbedtls_md_info_t mbedtls_md5_info;
static  mbedtls_md_info_t mbedtls_ripemd160_info;
static  mbedtls_md_info_t mbedtls_sha1_info;
static  mbedtls_md_info_t mbedtls_sha224_info;
static  mbedtls_md_info_t mbedtls_sha256_info;
static  mbedtls_md_info_t mbedtls_sha384_info;
static  mbedtls_md_info_t mbedtls_sha512_info;
fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

static const i32 supported_digests[] = {MBEDTLS_MD_SHA512, MBEDTLS_MD_SHA384, MBEDTLS_MD_SHA256, MBEDTLS_MD_SHA224, MBEDTLS_MD_SHA1, MBEDTLS_MD_RIPEMD160, MBEDTLS_MD_MD5, MBEDTLS_MD_NONE};
pub fn i32 * mbedtls_md_list() -> const
{
	return supported_digests;
}

pub fn mbedtls_md_info_t * mbedtls_md_info_from_string(const i8 * md_name) -> const
{
	if NULL == md_name
	{
		return NULL;
	}
	if !strcmp("MD5", md_name)
	{
		return mbedtls_md_info_from_type(MBEDTLS_MD_MD5);
	}
	if !strcmp("RIPEMD160", md_name)
	{
		return mbedtls_md_info_from_type(MBEDTLS_MD_RIPEMD160);
	}
	if !strcmp("SHA1", md_name) || !strcmp("SHA", md_name)
	{
		return mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);
	}
	if !strcmp("SHA224", md_name)
	{
		return mbedtls_md_info_from_type(MBEDTLS_MD_SHA224);
	}
	if !strcmp("SHA256", md_name)
	{
		return mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
	}
	if !strcmp("SHA384", md_name)
	{
		return mbedtls_md_info_from_type(MBEDTLS_MD_SHA384);
	}
	if !strcmp("SHA512", md_name)
	{
		return mbedtls_md_info_from_type(MBEDTLS_MD_SHA512);
	}
	return NULL;
}

pub fn mbedtls_md_info_t * mbedtls_md_info_from_type(mbedtls_md_type_t md_type) -> const
{
	switch (md_type)
	{
		case MBEDTLS_MD_MD5:
		return &mbedtls_md5_info;
		case MBEDTLS_MD_RIPEMD160:
		return &mbedtls_ripemd160_info;
		case MBEDTLS_MD_SHA1:
		return &mbedtls_sha1_info;
		case MBEDTLS_MD_SHA224:
		return &mbedtls_sha224_info;
		case MBEDTLS_MD_SHA256:
		return &mbedtls_sha256_info;
		case MBEDTLS_MD_SHA384:
		return &mbedtls_sha384_info;
		case MBEDTLS_MD_SHA512:
		return &mbedtls_sha512_info;
	default:
		return NULL;
	}
}

pub fn mbedtls_md_init(mbedtls_md_context_t * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_md_context_t));
}

pub fn mbedtls_md_free(mbedtls_md_context_t * ctx)
{
	if ctx == NULL || ctx.md_info == NULL
	{
		return;
	}
	if ctx.md_ctx != NULL
	{
		ctx.md_info.ctx_free_func(ctx.md_ctx);
	}
	if ctx.hmac_ctx != NULL
	{
		zeroize(ctx.hmac_ctx, 2 * ctx.md_info.block_size);
		mbedtls_free(ctx.hmac_ctx);
	}
	zeroize(ctx, sizeof(mbedtls_md_context_t));
}

pub fn mbedtls_md_clone(mbedtls_md_context_t * dst, const mbedtls_md_context_t * src) -> i32
{
	if dst == NULL || dst.md_info == NULL || src == NULL || src.md_info == NULL || dst.md_info != src.md_info
	{
		return -0x5100;
	}
	dst.md_info.clone_func(dst.md_ctx, src.md_ctx);
	return 0;
}

pub fn mbedtls_md_setup(mbedtls_md_context_t * ctx, const mbedtls_md_info_t * md_info, i32 hmac) -> i32
{
	if md_info == NULL || ctx == NULL
	{
		return -0x5100;
	}
	if (ctx.md_ctx = md_info.ctx_alloc_func()) == NULL
	{
		return -0x5180;
	}
	if hmac != 0
	{
		ctx.hmac_ctx = mbedtls_calloc(2, md_info.block_size);
		if ctx.hmac_ctx == NULL
		{
			md_info.ctx_free_func(ctx.md_ctx);
			return -0x5180;
		}
	}
	ctx.md_info = md_info;
	return 0;
}

pub fn mbedtls_md_starts(mbedtls_md_context_t * ctx) -> i32
{
	if ctx == NULL || ctx.md_info == NULL
	{
		return -0x5100;
	}
	ctx.md_info.starts_func(ctx.md_ctx);
	return 0;
}

pub fn mbedtls_md_update(mbedtls_md_context_t * ctx, const u8 * input, usize ilen) -> i32
{
	if ctx == NULL || ctx.md_info == NULL
	{
		return -0x5100;
	}
	ctx.md_info.update_func(ctx.md_ctx, input, ilen);
	return 0;
}

pub fn mbedtls_md_finish(mbedtls_md_context_t * ctx, u8 * output) -> i32
{
	if ctx == NULL || ctx.md_info == NULL
	{
		return -0x5100;
	}
	ctx.md_info.finish_func(ctx.md_ctx, output);
	return 0;
}

pub fn mbedtls_md(const mbedtls_md_info_t * md_info, const u8 * input, usize ilen, u8 * output) -> i32
{
	if md_info == NULL
	{
		return -0x5100;
	}
	md_info.digest_func(input, ilen, output);
	return 0;
}

pub fn mbedtls_md_file(const mbedtls_md_info_t * md_info, const i8 * path, u8 * output) -> i32
{
	i32 ret;
	FILE * f;
	usize n;
	mbedtls_md_context_t ctx;
	u8 buf[1024];
	if md_info == NULL
	{
		return -0x5100;
	}
	if (f = fopen(path, "rb")) == NULL
	{
		return -0x5200;
	}
	mbedtls_md_init(&ctx);
	if (ret = mbedtls_md_setup(&ctx, md_info, 0)) != 0
	{
		goto cleanup;
	}
	md_info.starts_func(ctx.md_ctx);
	while ((n = fread(buf, 1, sizeof(buf), f)) > 0)
	{
		md_info.update_func(ctx.md_ctx, buf, n);
	}
	if ferror(f) != 0
	{
		ret = -0x5200;
		goto cleanup;
	}
	md_info.finish_func(ctx.md_ctx, output);
cleanup:
	fclose(f);
	mbedtls_md_free(&ctx);
	return ret;
}

pub fn mbedtls_md_hmac_starts(mbedtls_md_context_t * ctx, const u8 * key, usize keylen) -> i32
{
	u8 sum[64];
	u8 *ipad, *opad;
	usize i;
	if ctx == NULL || ctx.md_info == NULL || ctx.hmac_ctx == NULL
	{
		return -0x5100;
	}
	if keylen > (usize) ctx.md_info.block_size
	{
		ctx.md_info.starts_func(ctx.md_ctx);
		ctx.md_info.update_func(ctx.md_ctx, key, keylen);
		ctx.md_info.finish_func(ctx.md_ctx, sum);
		keylen = ctx.md_info.size;
		key = sum;
	}
	ipad = (u8 *) ctx.hmac_ctx;
	opad = (u8 *) ctx.hmac_ctx + ctx.md_info.block_size;
	memset(ipad, 0x36, ctx.md_info.block_size);
	memset(opad, 0x5C, ctx.md_info.block_size);
	for (i = 0; i < keylen; i++)
	{
		ipad[i] = (i8) (ipad[i] ^ key[i]);
		opad[i] = (i8) (opad[i] ^ key[i]);
	}
	zeroize(sum, sizeof(sum));
	ctx.md_info.starts_func(ctx.md_ctx);
	ctx.md_info.update_func(ctx.md_ctx, ipad, ctx.md_info.block_size);
	return 0;
}

pub fn mbedtls_md_hmac_update(mbedtls_md_context_t * ctx, const u8 * input, usize ilen) -> i32
{
	if ctx == NULL || ctx.md_info == NULL || ctx.hmac_ctx == NULL
	{
		return -0x5100;
	}
	ctx.md_info.update_func(ctx.md_ctx, input, ilen);
	return 0;
}

pub fn mbedtls_md_hmac_finish(mbedtls_md_context_t * ctx, u8 * output) -> i32
{
	u8 tmp[64];
	u8 * opad;
	if ctx == NULL || ctx.md_info == NULL || ctx.hmac_ctx == NULL
	{
		return -0x5100;
	}
	opad = (u8 *) ctx.hmac_ctx + ctx.md_info.block_size;
	ctx.md_info.finish_func(ctx.md_ctx, tmp);
	ctx.md_info.starts_func(ctx.md_ctx);
	ctx.md_info.update_func(ctx.md_ctx, opad, ctx.md_info.block_size);
	ctx.md_info.update_func(ctx.md_ctx, tmp, ctx.md_info.size);
	ctx.md_info.finish_func(ctx.md_ctx, output);
	return 0;
}

pub fn mbedtls_md_hmac_reset(mbedtls_md_context_t * ctx) -> i32
{
	u8 * ipad;
	if ctx == NULL || ctx.md_info == NULL || ctx.hmac_ctx == NULL
	{
		return -0x5100;
	}
	ipad = (u8 *) ctx.hmac_ctx;
	ctx.md_info.starts_func(ctx.md_ctx);
	ctx.md_info.update_func(ctx.md_ctx, ipad, ctx.md_info.block_size);
	return 0;
}

pub fn mbedtls_md_hmac(const mbedtls_md_info_t * md_info, const u8 * key, usize keylen, const u8 * input, usize ilen, u8 * output) -> i32
{
	mbedtls_md_context_t ctx;
	i32 ret;
	if md_info == NULL
	{
		return -0x5100;
	}
	mbedtls_md_init(&ctx);
	if (ret = mbedtls_md_setup(&ctx, md_info, 1)) != 0
	{
		return ret;
	}
	mbedtls_md_hmac_starts(&ctx, key, keylen);
	mbedtls_md_hmac_update(&ctx, input, ilen);
	mbedtls_md_hmac_finish(&ctx, output);
	mbedtls_md_free(&ctx);
	return 0;
}

pub fn mbedtls_md_process(mbedtls_md_context_t * ctx, const u8 * data) -> i32
{
	if ctx == NULL || ctx.md_info == NULL
	{
		return -0x5100;
	}
	ctx.md_info.process_func(ctx.md_ctx, data);
	return 0;
}

pub fn mbedtls_md_get_size(const mbedtls_md_info_t * md_info) -> u8
{
	if md_info == NULL
	{
		return 0;
	}
	return md_info.size;
}

pub fn mbedtls_md_get_type(const mbedtls_md_info_t * md_info) -> mbedtls_md_type_t
{
	if md_info == NULL
	{
		return MBEDTLS_MD_NONE;
	}
	return md_info.type;
}

pub fn i8 * mbedtls_md_get_name(const mbedtls_md_info_t * md_info) -> const
{
	if md_info == NULL
	{
		return NULL;
	}
	return md_info.name;
}

typedef struct
{
	u32 total[2];
	u32 state[4];
	u8 buffer[64];
} mbedtls_md5_context;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_md5_init(mbedtls_md5_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_md5_context));
}

pub fn mbedtls_md5_free(mbedtls_md5_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_md5_context));
}

pub fn mbedtls_md5_clone(mbedtls_md5_context * dst, const mbedtls_md5_context * src)
{
	*dst = *src;
}

pub fn mbedtls_md5_starts(mbedtls_md5_context * ctx)
{
	ctx.total[0] = 0;
	ctx.total[1] = 0;
	ctx.state[0] = 0x67452301;
	ctx.state[1] = 0xEFCDAB89;
	ctx.state[2] = 0x98BADCFE;
	ctx.state[3] = 0x10325476;
}

pub fn mbedtls_md5_process(mbedtls_md5_context * ctx, const u8 data[64])
{
	u32 X[16], A, B, C, D;
	GET_UINT32_LE(X[0], data, 0);
	GET_UINT32_LE(X[1], data, 4);
	GET_UINT32_LE(X[2], data, 8);
	GET_UINT32_LE(X[3], data, 12);
	GET_UINT32_LE(X[4], data, 16);
	GET_UINT32_LE(X[5], data, 20);
	GET_UINT32_LE(X[6], data, 24);
	GET_UINT32_LE(X[7], data, 28);
	GET_UINT32_LE(X[8], data, 32);
	GET_UINT32_LE(X[9], data, 36);
	GET_UINT32_LE(X[10], data, 40);
	GET_UINT32_LE(X[11], data, 44);
	GET_UINT32_LE(X[12], data, 48);
	GET_UINT32_LE(X[13], data, 52);
	GET_UINT32_LE(X[14], data, 56);
	GET_UINT32_LE(X[15], data, 60);
	A = ctx.state[0];
	B = ctx.state[1];
	C = ctx.state[2];
	D = ctx.state[3];
	{
		A += (D ^ (B & (C ^ D))) + X[0] + 0xD76AA478;
		A = ((A << 7) | ((A & 0xFFFFFFFF) >> (32 - 7))) + B;
	};
	{
		D += (C ^ (A & (B ^ C))) + X[1] + 0xE8C7B756;
		D = ((D << 12) | ((D & 0xFFFFFFFF) >> (32 - 12))) + A;
	};
	{
		C += (B ^ (D & (A ^ B))) + X[2] + 0x242070DB;
		C = ((C << 17) | ((C & 0xFFFFFFFF) >> (32 - 17))) + D;
	};
	{
		B += (A ^ (C & (D ^ A))) + X[3] + 0xC1BDCEEE;
		B = ((B << 22) | ((B & 0xFFFFFFFF) >> (32 - 22))) + C;
	};
	{
		A += (D ^ (B & (C ^ D))) + X[4] + 0xF57C0FAF;
		A = ((A << 7) | ((A & 0xFFFFFFFF) >> (32 - 7))) + B;
	};
	{
		D += (C ^ (A & (B ^ C))) + X[5] + 0x4787C62A;
		D = ((D << 12) | ((D & 0xFFFFFFFF) >> (32 - 12))) + A;
	};
	{
		C += (B ^ (D & (A ^ B))) + X[6] + 0xA8304613;
		C = ((C << 17) | ((C & 0xFFFFFFFF) >> (32 - 17))) + D;
	};
	{
		B += (A ^ (C & (D ^ A))) + X[7] + 0xFD469501;
		B = ((B << 22) | ((B & 0xFFFFFFFF) >> (32 - 22))) + C;
	};
	{
		A += (D ^ (B & (C ^ D))) + X[8] + 0x698098D8;
		A = ((A << 7) | ((A & 0xFFFFFFFF) >> (32 - 7))) + B;
	};
	{
		D += (C ^ (A & (B ^ C))) + X[9] + 0x8B44F7AF;
		D = ((D << 12) | ((D & 0xFFFFFFFF) >> (32 - 12))) + A;
	};
	{
		C += (B ^ (D & (A ^ B))) + X[10] + 0xFFFF5BB1;
		C = ((C << 17) | ((C & 0xFFFFFFFF) >> (32 - 17))) + D;
	};
	{
		B += (A ^ (C & (D ^ A))) + X[11] + 0x895CD7BE;
		B = ((B << 22) | ((B & 0xFFFFFFFF) >> (32 - 22))) + C;
	};
	{
		A += (D ^ (B & (C ^ D))) + X[12] + 0x6B901122;
		A = ((A << 7) | ((A & 0xFFFFFFFF) >> (32 - 7))) + B;
	};
	{
		D += (C ^ (A & (B ^ C))) + X[13] + 0xFD987193;
		D = ((D << 12) | ((D & 0xFFFFFFFF) >> (32 - 12))) + A;
	};
	{
		C += (B ^ (D & (A ^ B))) + X[14] + 0xA679438E;
		C = ((C << 17) | ((C & 0xFFFFFFFF) >> (32 - 17))) + D;
	};
	{
		B += (A ^ (C & (D ^ A))) + X[15] + 0x49B40821;
		B = ((B << 22) | ((B & 0xFFFFFFFF) >> (32 - 22))) + C;
	};
	{
		A += (C ^ (D & (B ^ C))) + X[1] + 0xF61E2562;
		A = ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + B;
	};
	{
		D += (B ^ (C & (A ^ B))) + X[6] + 0xC040B340;
		D = ((D << 9) | ((D & 0xFFFFFFFF) >> (32 - 9))) + A;
	};
	{
		C += (A ^ (B & (D ^ A))) + X[11] + 0x265E5A51;
		C = ((C << 14) | ((C & 0xFFFFFFFF) >> (32 - 14))) + D;
	};
	{
		B += (D ^ (A & (C ^ D))) + X[0] + 0xE9B6C7AA;
		B = ((B << 20) | ((B & 0xFFFFFFFF) >> (32 - 20))) + C;
	};
	{
		A += (C ^ (D & (B ^ C))) + X[5] + 0xD62F105D;
		A = ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + B;
	};
	{
		D += (B ^ (C & (A ^ B))) + X[10] + 0x02441453;
		D = ((D << 9) | ((D & 0xFFFFFFFF) >> (32 - 9))) + A;
	};
	{
		C += (A ^ (B & (D ^ A))) + X[15] + 0xD8A1E681;
		C = ((C << 14) | ((C & 0xFFFFFFFF) >> (32 - 14))) + D;
	};
	{
		B += (D ^ (A & (C ^ D))) + X[4] + 0xE7D3FBC8;
		B = ((B << 20) | ((B & 0xFFFFFFFF) >> (32 - 20))) + C;
	};
	{
		A += (C ^ (D & (B ^ C))) + X[9] + 0x21E1CDE6;
		A = ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + B;
	};
	{
		D += (B ^ (C & (A ^ B))) + X[14] + 0xC33707D6;
		D = ((D << 9) | ((D & 0xFFFFFFFF) >> (32 - 9))) + A;
	};
	{
		C += (A ^ (B & (D ^ A))) + X[3] + 0xF4D50D87;
		C = ((C << 14) | ((C & 0xFFFFFFFF) >> (32 - 14))) + D;
	};
	{
		B += (D ^ (A & (C ^ D))) + X[8] + 0x455A14ED;
		B = ((B << 20) | ((B & 0xFFFFFFFF) >> (32 - 20))) + C;
	};
	{
		A += (C ^ (D & (B ^ C))) + X[13] + 0xA9E3E905;
		A = ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + B;
	};
	{
		D += (B ^ (C & (A ^ B))) + X[2] + 0xFCEFA3F8;
		D = ((D << 9) | ((D & 0xFFFFFFFF) >> (32 - 9))) + A;
	};
	{
		C += (A ^ (B & (D ^ A))) + X[7] + 0x676F02D9;
		C = ((C << 14) | ((C & 0xFFFFFFFF) >> (32 - 14))) + D;
	};
	{
		B += (D ^ (A & (C ^ D))) + X[12] + 0x8D2A4C8A;
		B = ((B << 20) | ((B & 0xFFFFFFFF) >> (32 - 20))) + C;
	};
	{
		A += (B ^ C ^ D) + X[5] + 0xFFFA3942;
		A = ((A << 4) | ((A & 0xFFFFFFFF) >> (32 - 4))) + B;
	};
	{
		D += (A ^ B ^ C) + X[8] + 0x8771F681;
		D = ((D << 11) | ((D & 0xFFFFFFFF) >> (32 - 11))) + A;
	};
	{
		C += (D ^ A ^ B) + X[11] + 0x6D9D6122;
		C = ((C << 16) | ((C & 0xFFFFFFFF) >> (32 - 16))) + D;
	};
	{
		B += (C ^ D ^ A) + X[14] + 0xFDE5380C;
		B = ((B << 23) | ((B & 0xFFFFFFFF) >> (32 - 23))) + C;
	};
	{
		A += (B ^ C ^ D) + X[1] + 0xA4BEEA44;
		A = ((A << 4) | ((A & 0xFFFFFFFF) >> (32 - 4))) + B;
	};
	{
		D += (A ^ B ^ C) + X[4] + 0x4BDECFA9;
		D = ((D << 11) | ((D & 0xFFFFFFFF) >> (32 - 11))) + A;
	};
	{
		C += (D ^ A ^ B) + X[7] + 0xF6BB4B60;
		C = ((C << 16) | ((C & 0xFFFFFFFF) >> (32 - 16))) + D;
	};
	{
		B += (C ^ D ^ A) + X[10] + 0xBEBFBC70;
		B = ((B << 23) | ((B & 0xFFFFFFFF) >> (32 - 23))) + C;
	};
	{
		A += (B ^ C ^ D) + X[13] + 0x289B7EC6;
		A = ((A << 4) | ((A & 0xFFFFFFFF) >> (32 - 4))) + B;
	};
	{
		D += (A ^ B ^ C) + X[0] + 0xEAA127FA;
		D = ((D << 11) | ((D & 0xFFFFFFFF) >> (32 - 11))) + A;
	};
	{
		C += (D ^ A ^ B) + X[3] + 0xD4EF3085;
		C = ((C << 16) | ((C & 0xFFFFFFFF) >> (32 - 16))) + D;
	};
	{
		B += (C ^ D ^ A) + X[6] + 0x04881D05;
		B = ((B << 23) | ((B & 0xFFFFFFFF) >> (32 - 23))) + C;
	};
	{
		A += (B ^ C ^ D) + X[9] + 0xD9D4D039;
		A = ((A << 4) | ((A & 0xFFFFFFFF) >> (32 - 4))) + B;
	};
	{
		D += (A ^ B ^ C) + X[12] + 0xE6DB99E5;
		D = ((D << 11) | ((D & 0xFFFFFFFF) >> (32 - 11))) + A;
	};
	{
		C += (D ^ A ^ B) + X[15] + 0x1FA27CF8;
		C = ((C << 16) | ((C & 0xFFFFFFFF) >> (32 - 16))) + D;
	};
	{
		B += (C ^ D ^ A) + X[2] + 0xC4AC5665;
		B = ((B << 23) | ((B & 0xFFFFFFFF) >> (32 - 23))) + C;
	};
	{
		A += (C ^ (B | ~D)) + X[0] + 0xF4292244;
		A = ((A << 6) | ((A & 0xFFFFFFFF) >> (32 - 6))) + B;
	};
	{
		D += (B ^ (A | ~C)) + X[7] + 0x432AFF97;
		D = ((D << 10) | ((D & 0xFFFFFFFF) >> (32 - 10))) + A;
	};
	{
		C += (A ^ (D | ~B)) + X[14] + 0xAB9423A7;
		C = ((C << 15) | ((C & 0xFFFFFFFF) >> (32 - 15))) + D;
	};
	{
		B += (D ^ (C | ~A)) + X[5] + 0xFC93A039;
		B = ((B << 21) | ((B & 0xFFFFFFFF) >> (32 - 21))) + C;
	};
	{
		A += (C ^ (B | ~D)) + X[12] + 0x655B59C3;
		A = ((A << 6) | ((A & 0xFFFFFFFF) >> (32 - 6))) + B;
	};
	{
		D += (B ^ (A | ~C)) + X[3] + 0x8F0CCC92;
		D = ((D << 10) | ((D & 0xFFFFFFFF) >> (32 - 10))) + A;
	};
	{
		C += (A ^ (D | ~B)) + X[10] + 0xFFEFF47D;
		C = ((C << 15) | ((C & 0xFFFFFFFF) >> (32 - 15))) + D;
	};
	{
		B += (D ^ (C | ~A)) + X[1] + 0x85845DD1;
		B = ((B << 21) | ((B & 0xFFFFFFFF) >> (32 - 21))) + C;
	};
	{
		A += (C ^ (B | ~D)) + X[8] + 0x6FA87E4F;
		A = ((A << 6) | ((A & 0xFFFFFFFF) >> (32 - 6))) + B;
	};
	{
		D += (B ^ (A | ~C)) + X[15] + 0xFE2CE6E0;
		D = ((D << 10) | ((D & 0xFFFFFFFF) >> (32 - 10))) + A;
	};
	{
		C += (A ^ (D | ~B)) + X[6] + 0xA3014314;
		C = ((C << 15) | ((C & 0xFFFFFFFF) >> (32 - 15))) + D;
	};
	{
		B += (D ^ (C | ~A)) + X[13] + 0x4E0811A1;
		B = ((B << 21) | ((B & 0xFFFFFFFF) >> (32 - 21))) + C;
	};
	{
		A += (C ^ (B | ~D)) + X[4] + 0xF7537E82;
		A = ((A << 6) | ((A & 0xFFFFFFFF) >> (32 - 6))) + B;
	};
	{
		D += (B ^ (A | ~C)) + X[11] + 0xBD3AF235;
		D = ((D << 10) | ((D & 0xFFFFFFFF) >> (32 - 10))) + A;
	};
	{
		C += (A ^ (D | ~B)) + X[2] + 0x2AD7D2BB;
		C = ((C << 15) | ((C & 0xFFFFFFFF) >> (32 - 15))) + D;
	};
	{
		B += (D ^ (C | ~A)) + X[9] + 0xEB86D391;
		B = ((B << 21) | ((B & 0xFFFFFFFF) >> (32 - 21))) + C;
	};
	ctx.state[0] += A;
	ctx.state[1] += B;
	ctx.state[2] += C;
	ctx.state[3] += D;
}

pub fn mbedtls_md5_update(mbedtls_md5_context * ctx, const u8 * input, usize ilen)
{
	usize fill;
	u32 left;
	if ilen == 0
	{
		return;
	}
	left = ctx.total[0] & 0x3F;
	fill = 64 - left;
	ctx.total[0] += (u32) ilen;
	ctx.total[0] &= 0xFFFFFFFF;
	if ctx.total[0] < (u32) ilen
	{
		ctx.total[1]++;
	}
	if left && ilen >= fill
	{
		memcpy((void *) (ctx.buffer + left), input, fill);
		mbedtls_md5_process(ctx, ctx.buffer);
		input += fill;
		ilen -= fill;
		left = 0;
	}
	while (ilen >= 64)
	{
		mbedtls_md5_process(ctx, input);
		input += 64;
		ilen -= 64;
	}
	if ilen > 0
	{
		memcpy((void *) (ctx.buffer + left), input, ilen);
	}
}

static const u8 md5_padding[64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
pub fn mbedtls_md5_finish(mbedtls_md5_context * ctx, u8 output[16])
{
	u32 last, padn;
	u32 high, low;
	u8 msglen[8];
	high = (ctx.total[0] >> 29) | (ctx.total[1] << 3);
	low = (ctx.total[0] << 3);
	PUT_UINT32_LE(low, msglen, 0);
	PUT_UINT32_LE(high, msglen, 4);
	last = ctx.total[0] & 0x3F;
	padn = (last < 56) ? (56 - last) : (120 - last);
	mbedtls_md5_update(ctx, md5_padding, padn);
	mbedtls_md5_update(ctx, msglen, 8);
	PUT_UINT32_LE(ctx.state[0], output, 0);
	PUT_UINT32_LE(ctx.state[1], output, 4);
	PUT_UINT32_LE(ctx.state[2], output, 8);
	PUT_UINT32_LE(ctx.state[3], output, 12);
}

pub fn mbedtls_md5(const u8 * input, usize ilen, u8 output[16])
{
	mbedtls_md5_context ctx;
	mbedtls_md5_init(&ctx);
	mbedtls_md5_starts(&ctx);
	mbedtls_md5_update(&ctx, input, ilen);
	mbedtls_md5_finish(&ctx, output);
	mbedtls_md5_free(&ctx);
}

static const u8 md5_test_buf[7][81] = {{""}, {"a"}, {"abc"}, {"message digest"}, {"abcdefghijklmnopqrstuvwxyz"}, {"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"}, {"12345678901234567890123456789012345678901234567890123456789012"
		"345678901234567890"
	}
};
static const i32 md5_test_buflen[7] = {0, 1, 3, 14, 26, 62, 80};
static const u8 md5_test_sum[7][16] = {{0xD4, 0x1D, 0x8C, 0xD9, 0x8F, 0x00, 0xB2, 0x04, 0xE9, 0x80, 0x09, 0x98, 0xEC, 0xF8, 0x42, 0x7E}, {0x0C, 0xC1, 0x75, 0xB9, 0xC0, 0xF1, 0xB6, 0xA8, 0x31, 0xC3, 0x99, 0xE2, 0x69, 0x77, 0x26, 0x61}, {0x90, 0x01, 0x50, 0x98, 0x3C, 0xD2, 0x4F, 0xB0, 0xD6, 0x96, 0x3F, 0x7D, 0x28, 0xE1, 0x7F, 0x72}, {0xF9, 0x6B, 0x69, 0x7D, 0x7C, 0xB7, 0x93, 0x8D, 0x52, 0x5A, 0x2F, 0x31, 0xAA, 0xF1, 0x61, 0xD0}, {0xC3, 0xFC, 0xD3, 0xD7, 0x61, 0x92, 0xE4, 0x00, 0x7D, 0xFB, 0x49, 0x6C, 0xCA, 0x67, 0xE1, 0x3B}, {0xD1, 0x74, 0xAB, 0x98, 0xD2, 0x77, 0xD9, 0xF5, 0xA5, 0x61, 0x1C, 0x2C, 0x9F, 0x41, 0x9D, 0x9F}, {0x57, 0xED, 0xF4, 0xA2, 0x2B, 0xE3, 0xC9, 0x55, 0xAC, 0x49, 0xDA, 0x2E, 0x21, 0x07, 0xB6, 0x7A}};
pub fn mbedtls_md5_self_test(i32 verbose) -> i32
{
	i32 i;
	u8 md5sum[16];
	for (i = 0; i < 7; i++)
	{
		if verbose != 0
		{
			printf("  MD5 test #%d: ", i + 1);
		}
		mbedtls_md5(md5_test_buf[i], md5_test_buflen[i], md5sum);
		if memcmp(md5sum, md5_test_sum[i], 16) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			return 1;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
	return 0;
}

typedef struct
{
	u32 total[2];
	u32 state[5];
	u8 buffer[64];
} mbedtls_ripemd160_context;

typedef struct
{
	u32 total[2];
	u32 state[5];
	u8 buffer[64];
} mbedtls_sha1_context;

typedef struct
{
	u32 total[2];
	u32 state[8];
	u8 buffer[64];
	i32 is224;
} mbedtls_sha256_context;

fn md5_starts_wrap(void * ctx)
{
	mbedtls_md5_starts((mbedtls_md5_context *) ctx);
}

fn md5_update_wrap(void * ctx, const u8 * input, usize ilen)
{
	mbedtls_md5_update((mbedtls_md5_context *) ctx, input, ilen);
}

fn md5_finish_wrap(void * ctx, u8 * output)
{
	mbedtls_md5_finish((mbedtls_md5_context *) ctx, output);
}

fn * md5_ctx_alloc()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_md5_context));
	if ctx != NULL
	{
		mbedtls_md5_init((mbedtls_md5_context *) ctx);
	}
	return ctx;
}

fn md5_ctx_free(void * ctx)
{
	mbedtls_md5_free((mbedtls_md5_context *) ctx);
	mbedtls_free(ctx);
}

fn md5_clone_wrap(void * dst, const void * src)
{
	mbedtls_md5_clone((mbedtls_md5_context *) dst, (const mbedtls_md5_context *) src);
}

fn md5_process_wrap(void * ctx, const u8 * data)
{
	mbedtls_md5_process((mbedtls_md5_context *) ctx, data);
}

const mbedtls_md_info_t mbedtls_md5_info =
{
	MBEDTLS_MD_MD5, "MD5", 16, 64, md5_starts_wrap, md5_update_wrap, md5_finish_wrap, mbedtls_md5, md5_ctx_alloc, md5_ctx_free, md5_clone_wrap, md5_process_wrap,
};
fn ripemd160_starts_wrap(void * ctx)
{
	mbedtls_ripemd160_starts((mbedtls_ripemd160_context *) ctx);
}

fn ripemd160_update_wrap(void * ctx, const u8 * input, usize ilen)
{
	mbedtls_ripemd160_update((mbedtls_ripemd160_context *) ctx, input, ilen);
}

fn ripemd160_finish_wrap(void * ctx, u8 * output)
{
	mbedtls_ripemd160_finish((mbedtls_ripemd160_context *) ctx, output);
}

fn * ripemd160_ctx_alloc()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_ripemd160_context));
	if ctx != NULL
	{
		mbedtls_ripemd160_init((mbedtls_ripemd160_context *) ctx);
	}
	return ctx;
}

fn ripemd160_ctx_free(void * ctx)
{
	mbedtls_ripemd160_free((mbedtls_ripemd160_context *) ctx);
	mbedtls_free(ctx);
}

fn ripemd160_clone_wrap(void * dst, const void * src)
{
	mbedtls_ripemd160_clone((mbedtls_ripemd160_context *) dst, (const mbedtls_ripemd160_context *) src);
}

fn ripemd160_process_wrap(void * ctx, const u8 * data)
{
	mbedtls_ripemd160_process((mbedtls_ripemd160_context *) ctx, data);
}

const mbedtls_md_info_t mbedtls_ripemd160_info =
{
	MBEDTLS_MD_RIPEMD160, "RIPEMD160", 20, 64, ripemd160_starts_wrap, ripemd160_update_wrap, ripemd160_finish_wrap, mbedtls_ripemd160, ripemd160_ctx_alloc, ripemd160_ctx_free, ripemd160_clone_wrap, ripemd160_process_wrap,
};
fn sha1_starts_wrap(void * ctx)
{
	mbedtls_sha1_starts((mbedtls_sha1_context *) ctx);
}

fn sha1_update_wrap(void * ctx, const u8 * input, usize ilen)
{
	mbedtls_sha1_update((mbedtls_sha1_context *) ctx, input, ilen);
}

fn sha1_finish_wrap(void * ctx, u8 * output)
{
	mbedtls_sha1_finish((mbedtls_sha1_context *) ctx, output);
}

fn * sha1_ctx_alloc()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_sha1_context));
	if ctx != NULL
	{
		mbedtls_sha1_init((mbedtls_sha1_context *) ctx);
	}
	return ctx;
}

fn sha1_clone_wrap(void * dst, const void * src)
{
	mbedtls_sha1_clone((mbedtls_sha1_context *) dst, (const mbedtls_sha1_context *) src);
}

fn sha1_ctx_free(void * ctx)
{
	mbedtls_sha1_free((mbedtls_sha1_context *) ctx);
	mbedtls_free(ctx);
}

fn sha1_process_wrap(void * ctx, const u8 * data)
{
	mbedtls_sha1_process((mbedtls_sha1_context *) ctx, data);
}

const mbedtls_md_info_t mbedtls_sha1_info =
{
	MBEDTLS_MD_SHA1, "SHA1", 20, 64, sha1_starts_wrap, sha1_update_wrap, sha1_finish_wrap, mbedtls_sha1, sha1_ctx_alloc, sha1_ctx_free, sha1_clone_wrap, sha1_process_wrap,
};
fn sha224_starts_wrap(void * ctx)
{
	mbedtls_sha256_starts((mbedtls_sha256_context *) ctx, 1);
}

fn sha224_update_wrap(void * ctx, const u8 * input, usize ilen)
{
	mbedtls_sha256_update((mbedtls_sha256_context *) ctx, input, ilen);
}

fn sha224_finish_wrap(void * ctx, u8 * output)
{
	mbedtls_sha256_finish((mbedtls_sha256_context *) ctx, output);
}

fn sha224_wrap(const u8 * input, usize ilen, u8 * output)
{
	mbedtls_sha256(input, ilen, output, 1);
}

fn * sha224_ctx_alloc()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_sha256_context));
	if ctx != NULL
	{
		mbedtls_sha256_init((mbedtls_sha256_context *) ctx);
	}
	return ctx;
}

fn sha224_ctx_free(void * ctx)
{
	mbedtls_sha256_free((mbedtls_sha256_context *) ctx);
	mbedtls_free(ctx);
}

fn sha224_clone_wrap(void * dst, const void * src)
{
	mbedtls_sha256_clone((mbedtls_sha256_context *) dst, (const mbedtls_sha256_context *) src);
}

fn sha224_process_wrap(void * ctx, const u8 * data)
{
	mbedtls_sha256_process((mbedtls_sha256_context *) ctx, data);
}

const mbedtls_md_info_t mbedtls_sha224_info =
{
	MBEDTLS_MD_SHA224, "SHA224", 28, 64, sha224_starts_wrap, sha224_update_wrap, sha224_finish_wrap, sha224_wrap, sha224_ctx_alloc, sha224_ctx_free, sha224_clone_wrap, sha224_process_wrap,
};
fn sha256_starts_wrap(void * ctx)
{
	mbedtls_sha256_starts((mbedtls_sha256_context *) ctx, 0);
}

fn sha256_wrap(const u8 * input, usize ilen, u8 * output)
{
	mbedtls_sha256(input, ilen, output, 0);
}

const mbedtls_md_info_t mbedtls_sha256_info =
{
	MBEDTLS_MD_SHA256, "SHA256", 32, 64, sha256_starts_wrap, sha224_update_wrap, sha224_finish_wrap, sha256_wrap, sha224_ctx_alloc, sha224_ctx_free, sha224_clone_wrap, sha224_process_wrap,
};
fn sha384_starts_wrap(void * ctx)
{
	mbedtls_sha512_starts((mbedtls_sha512_context *) ctx, 1);
}

fn sha384_update_wrap(void * ctx, const u8 * input, usize ilen)
{
	mbedtls_sha512_update((mbedtls_sha512_context *) ctx, input, ilen);
}

fn sha384_finish_wrap(void * ctx, u8 * output)
{
	mbedtls_sha512_finish((mbedtls_sha512_context *) ctx, output);
}

fn sha384_wrap(const u8 * input, usize ilen, u8 * output)
{
	mbedtls_sha512(input, ilen, output, 1);
}

fn * sha384_ctx_alloc()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_sha512_context));
	if ctx != NULL
	{
		mbedtls_sha512_init((mbedtls_sha512_context *) ctx);
	}
	return ctx;
}

fn sha384_ctx_free(void * ctx)
{
	mbedtls_sha512_free((mbedtls_sha512_context *) ctx);
	mbedtls_free(ctx);
}

fn sha384_clone_wrap(void * dst, const void * src)
{
	mbedtls_sha512_clone((mbedtls_sha512_context *) dst, (const mbedtls_sha512_context *) src);
}

fn sha384_process_wrap(void * ctx, const u8 * data)
{
	mbedtls_sha512_process((mbedtls_sha512_context *) ctx, data);
}

const mbedtls_md_info_t mbedtls_sha384_info =
{
	MBEDTLS_MD_SHA384, "SHA384", 48, 128, sha384_starts_wrap, sha384_update_wrap, sha384_finish_wrap, sha384_wrap, sha384_ctx_alloc, sha384_ctx_free, sha384_clone_wrap, sha384_process_wrap,
};
fn sha512_starts_wrap(void * ctx)
{
	mbedtls_sha512_starts((mbedtls_sha512_context *) ctx, 0);
}

fn sha512_wrap(const u8 * input, usize ilen, u8 * output)
{
	mbedtls_sha512(input, ilen, output, 0);
}

const mbedtls_md_info_t mbedtls_sha512_info =
{
	MBEDTLS_MD_SHA512, "SHA512", 64, 128, sha512_starts_wrap, sha384_update_wrap, sha384_finish_wrap, sha512_wrap, sha384_ctx_alloc, sha384_ctx_free, sha384_clone_wrap, sha384_process_wrap,
};

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

typedef struct _memory_header memory_header;
struct _memory_header
{
	usize magic1;
	usize size;
	usize alloc;
	memory_header * prev;
	memory_header * next;
	memory_header * prev_free;
	memory_header * next_free;
	usize magic2;
};
typedef struct
{
	u8 * buf;
	usize len;
	memory_header * first;
	memory_header * first_free;
	i32 verify;
	mbedtls_threading_mutex_t mutex;
} buffer_alloc_ctx;
static buffer_alloc_ctx heap;
fn verify_header(memory_header * hdr) -> i32
{
	if hdr.magic1 != 0xFF00AA55
	{
		return 1;
	}
	if hdr.magic2 != 0xEE119966
	{
		return 1;
	}
	if hdr.alloc > 1
	{
		return 1;
	}
	if hdr.prev != NULL && hdr.prev == hdr.next
	{
		return 1;
	}
	if hdr.prev_free != NULL && hdr.prev_free == hdr.next_free
	{
		return 1;
	}
	return 0;
}

fn verify_chain() -> i32
{
	memory_header *prv = heap.first, *cur = heap.first.next;
	if verify_header(heap.first) != 0
	{
		return 1;
	}
	if heap.first.prev != NULL
	{
		return 1;
	}
	while (cur != NULL)
	{
		if verify_header(cur) != 0
		{
			return 1;
		}
		if cur.prev != prv
		{
			return 1;
		}
		prv = cur;
		cur = cur.next;
	}
	return 0;
}

fn * buffer_alloc_calloc(usize n, usize size)
{
	memory_header * new, *cur = heap.first_free;
	u8 * p;
	void * ret;
	usize original_len, len;
	if heap.buf == NULL || heap.first == NULL
	{
		return NULL;
	}
	original_len = len = n * size;
	if n != 0 && len / n != size
	{
		return NULL;
	}
	if len % 4
	{
		len -= len % 4;
		len += 4;
	}
	while (cur != NULL)
	{
		if cur.size >= len
		{
			break;

		}
		cur = cur.next_free;
	}
	if cur == NULL
	{
		return NULL;
	}
	if cur.alloc != 0
	{
		exit(1);
	}
	if cur.size - len < sizeof(memory_header) + 4
	{
		cur.alloc = 1;
		if cur.prev_free != NULL
		{
			cur.prev_free.next_free = cur.next_free;
		}
		else
		{
			heap.first_free = cur.next_free;
		}
		if cur.next_free != NULL
		{
			cur.next_free.prev_free = cur.prev_free;
		}
		cur.prev_free = NULL;
		cur.next_free = NULL;
		if (heap.verify & (1 << 0)) && verify_chain() != 0
		{
			exit(1);
		}
		ret = (u8 *) cur + sizeof(memory_header);
		memset(ret, 0, original_len);
		return ret;
	}
	p = ((u8 *) cur) + sizeof(memory_header) + len;
	new = (memory_header *) p;
	new.size = cur.size - len - sizeof(memory_header);
	new.alloc = 0;
	new.prev = cur;
	new.next = cur.next;
	new.magic1 = 0xFF00AA55;
	new.magic2 = 0xEE119966;
	if new.next != NULL
	{
		new.next.prev = new;
	}
	new.prev_free = cur.prev_free;
	new.next_free = cur.next_free;
	if new.prev_free != NULL
	{
		new.prev_free.next_free = new;
	}
	else
	{
		heap.first_free = new;
	}
	if new.next_free != NULL
	{
		new.next_free.prev_free = new;
	}
	cur.alloc = 1;
	cur.size = len;
	cur.next = new;
	cur.prev_free = NULL;
	cur.next_free = NULL;
	if (heap.verify & (1 << 0)) && verify_chain() != 0
	{
		exit(1);
	}
	ret = (u8 *) cur + sizeof(memory_header);
	memset(ret, 0, original_len);
	return ret;
}

fn buffer_alloc_free(void * ptr)
{
	memory_header *hdr, *old = NULL;
	u8 * p = (u8 *) ptr;
	if ptr == NULL || heap.buf == NULL || heap.first == NULL
	{
		return;
	}
	if p < heap.buf || p > heap.buf + heap.len
	{
		exit(1);
	}
	p -= sizeof(memory_header);
	hdr = (memory_header *) p;
	if verify_header(hdr) != 0
	{
		exit(1);
	}
	if hdr.alloc != 1
	{
		exit(1);
	}
	hdr.alloc = 0;
	if hdr.prev != NULL && hdr.prev.alloc == 0
	{
		hdr.prev.size += sizeof(memory_header) + hdr.size;
		hdr.prev.next = hdr.next;
		old = hdr;
		hdr = hdr.prev;
		if hdr.next != NULL
		{
			hdr.next.prev = hdr;
		}
		memset(old, 0, sizeof(memory_header));
	}
	if hdr.next != NULL && hdr.next.alloc == 0
	{
		hdr.size += sizeof(memory_header) + hdr.next.size;
		old = hdr.next;
		hdr.next = hdr.next.next;
		if hdr.prev_free != NULL || hdr.next_free != NULL
		{
			if hdr.prev_free != NULL
			{
				hdr.prev_free.next_free = hdr.next_free;
			}
			else
			{
				heap.first_free = hdr.next_free;
			}
			if hdr.next_free != NULL
			{
				hdr.next_free.prev_free = hdr.prev_free;
			}
		}
		hdr.prev_free = old.prev_free;
		hdr.next_free = old.next_free;
		if hdr.prev_free != NULL
		{
			hdr.prev_free.next_free = hdr;
		}
		else
		{
			heap.first_free = hdr;
		}
		if hdr.next_free != NULL
		{
			hdr.next_free.prev_free = hdr;
		}
		if hdr.next != NULL
		{
			hdr.next.prev = hdr;
		}
		memset(old, 0, sizeof(memory_header));
	}
	if old == NULL
	{
		hdr.next_free = heap.first_free;
		if heap.first_free != NULL
		{
			heap.first_free.prev_free = hdr;
		}
		heap.first_free = hdr;
	}
	if (heap.verify & (1 << 1)) && verify_chain() != 0
	{
		exit(1);
	}
}

pub fn mbedtls_memory_buffer_set_verify(i32 verify)
{
	heap.verify = verify;
}

pub fn mbedtls_memory_buffer_alloc_verify() -> i32
{
	return verify_chain();
}

fn * buffer_alloc_calloc_mutexed(usize n, usize size)
{
	void * buf;
	if mbedtls_mutex_lock(&heap.mutex) != 0
	{
		return NULL;
	}
	buf = buffer_alloc_calloc(n, size);
	if mbedtls_mutex_unlock(&heap.mutex)
	{
		return NULL;
	}
	return buf;
}

fn buffer_alloc_free_mutexed(void * ptr)
{
	if mbedtls_mutex_lock(&heap.mutex)
	{
		return;
	}
	buffer_alloc_free(ptr);
	(void) mbedtls_mutex_unlock(&heap.mutex);
}

pub fn mbedtls_memory_buffer_alloc_init(u8 * buf, usize len)
{
	memset(&heap, 0, sizeof(buffer_alloc_ctx));
	memset(buf, 0, len);
	mbedtls_mutex_init(&heap.mutex);
	mbedtls_platform_set_calloc_free(buffer_alloc_calloc_mutexed, buffer_alloc_free_mutexed);
	if (usize) buf % 4
	{
		len -= 4 - (usize) buf % 4;
		buf += 4 - (usize) buf % 4;
	}
	heap.buf = buf;
	heap.len = len;
	heap.first = (memory_header *) buf;
	heap.first.size = len - sizeof(memory_header);
	heap.first.magic1 = 0xFF00AA55;
	heap.first.magic2 = 0xEE119966;
	heap.first_free = heap.first;
}

pub fn mbedtls_memory_buffer_alloc_free()
{
	mbedtls_mutex_free(&heap.mutex);
	zeroize(&heap, sizeof(buffer_alloc_ctx));
}

fn check_pointer(void * p) -> i32
{
	if p == NULL
	{
		return -1;
	}
	if (usize) p % 4 != 0
	{
		return -1;
	}
	return 0;
}

fn check_all_free() -> i32
{
	if heap.first != heap.first_free || (void *) heap.first != (void *) heap.buf
	{
		return -1;
	}
	return 0;
}

pub fn mbedtls_memory_buffer_alloc_self_test(i32 verbose) -> i32
{
	u8 buf[1024];
	u8 *p, *q, *r, *end;
	i32 ret = 0;
	if verbose != 0
	{
		printf("  MBA test #1 (basic alloc-free cycle): ");
	}
	mbedtls_memory_buffer_alloc_init(buf, sizeof(buf));
	p = mbedtls_calloc(1, 1);
	q = mbedtls_calloc(1, 128);
	r = mbedtls_calloc(1, 16);
	if !(check_pointer(p) == 0 && check_pointer(q) == 0 && check_pointer(r) == 0)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	mbedtls_free(r);
	mbedtls_free(q);
	mbedtls_free(p);
	if !(check_all_free() == 0)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	end = heap.buf + heap.len;
	mbedtls_memory_buffer_alloc_free();
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  MBA test #2 (buf not aligned): ");
	}
	mbedtls_memory_buffer_alloc_init(buf + 1, sizeof(buf) - 1);
	if !(heap.buf + heap.len == end)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	p = mbedtls_calloc(1, 1);
	q = mbedtls_calloc(1, 128);
	r = mbedtls_calloc(1, 16);
	if !(check_pointer(p) == 0 && check_pointer(q) == 0 && check_pointer(r) == 0)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	mbedtls_free(r);
	mbedtls_free(q);
	mbedtls_free(p);
	if !(check_all_free() == 0)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	mbedtls_memory_buffer_alloc_free();
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  MBA test #3 (full): ");
	}
	mbedtls_memory_buffer_alloc_init(buf, sizeof(buf));
	p = mbedtls_calloc(1, sizeof(buf) - sizeof(memory_header));
	if !(check_pointer(p) == 0)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	if !(mbedtls_calloc(1, 1) == NULL)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	mbedtls_free(p);
	p = mbedtls_calloc(1, sizeof(buf) - 2 * sizeof(memory_header) - 16);
	q = mbedtls_calloc(1, 16);
	if !(check_pointer(p) == 0 && check_pointer(q) == 0)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	if !(mbedtls_calloc(1, 1) == NULL)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	mbedtls_free(q);
	if !(mbedtls_calloc(1, 17) == NULL)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	mbedtls_free(p);
	if !(check_all_free() == 0)
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		ret = 1;
		goto cleanup;
	};
	mbedtls_memory_buffer_alloc_free();
	if verbose != 0
	{
		printf("passed\n");
	}
cleanup:
	mbedtls_memory_buffer_alloc_free();
	return ret;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	const i8 * short_name;
} oid_x520_attr_t;
static const oid_x520_attr_t oid_x520_attr_type[] = {{
		{
			"\x55"
			"\x04"
			"\x03",
			(sizeof("\x55"
			"\x04"
			"\x03") -
			1),
			"id-at-commonName", "Common Name"
		},
		"CN",
	},
	{
		{
			"\x55"
			"\x04"
			"\x06",
			(sizeof("\x55"
			"\x04"
			"\x06") -
			1),
			"id-at-countryName", "Country"
		},
		"C",
	},
	{
		{
			"\x55"
			"\x04"
			"\x07",
			(sizeof("\x55"
			"\x04"
			"\x07") -
			1),
			"id-at-locality", "Locality"
		},
		"L",
	},
	{
		{
			"\x55"
			"\x04"
			"\x08",
			(sizeof("\x55"
			"\x04"
			"\x08") -
			1),
			"id-at-state", "State"
		},
		"ST",
	},
	{
		{
			"\x55"
			"\x04"
			"\x0A",
			(sizeof("\x55"
			"\x04"
			"\x0A") -
			1),
			"id-at-organizationName", "Organization"
		},
		"O",
	},
	{
		{
			"\x55"
			"\x04"
			"\x0B",
			(sizeof("\x55"
			"\x04"
			"\x0B") -
			1),
			"id-at-organizationalUnitName", "Org Unit"
		},
		"OU",
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x09"
			"\x01",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x09"
			"\x01") -
			1),
			"emailAddress", "E-mail address"
		},
		"emailAddress",
	},
	{
		{
			"\x55"
			"\x04"
			"\x05",
			(sizeof("\x55"
			"\x04"
			"\x05") -
			1),
			"id-at-serialNumber", "Serial number"
		},
		"serialNumber",
	},
	{
		{
			"\x55"
			"\x04"
			"\x10",
			(sizeof("\x55"
			"\x04"
			"\x10") -
			1),
			"id-at-postalAddress", "Postal address"
		},
		"postalAddress",
	},
	{
		{
			"\x55"
			"\x04"
			"\x11",
			(sizeof("\x55"
			"\x04"
			"\x11") -
			1),
			"id-at-postalCode", "Postal code"
		},
		"postalCode",
	},
	{
		{
			"\x55"
			"\x04"
			"\x04",
			(sizeof("\x55"
			"\x04"
			"\x04") -
			1),
			"id-at-surName", "Surname"
		},
		"SN",
	},
	{
		{
			"\x55"
			"\x04"
			"\x2A",
			(sizeof("\x55"
			"\x04"
			"\x2A") -
			1),
			"id-at-givenName", "Given name"
		},
		"GN",
	},
	{
		{
			"\x55"
			"\x04"
			"\x2B",
			(sizeof("\x55"
			"\x04"
			"\x2B") -
			1),
			"id-at-initials", "Initials"
		},
		"initials",
	},
	{
		{
			"\x55"
			"\x04"
			"\x2C",
			(sizeof("\x55"
			"\x04"
			"\x2C") -
			1),
			"id-at-generationQualifier", "Generation qualifier"
		},
		"generationQualifier",
	},
	{
		{
			"\x55"
			"\x04"
			"\x0C",
			(sizeof("\x55"
			"\x04"
			"\x0C") -
			1),
			"id-at-title", "Title"
		},
		"title",
	},
	{
		{
			"\x55"
			"\x04"
			"\x2E",
			(sizeof("\x55"
			"\x04"
			"\x2E") -
			1),
			"id-at-dnQualifier", "Distinguished Name qualifier"
		},
		"dnQualifier",
	},
	{
		{
			"\x55"
			"\x04"
			"\x41",
			(sizeof("\x55"
			"\x04"
			"\x41") -
			1),
			"id-at-pseudonym", "Pseudonym"
		},
		"pseudonym",
	},
	{
		{"\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x19", (sizeof("\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x19") - 1), "id-domainComponent", "Domain component"}, "DC",
	},
	{
		{
			"\x55"
			"\x04"
			"\x2D",
			(sizeof("\x55"
			"\x04"
			"\x2D") -
			1),
			"id-at-uniqueIdentifier", "Unique Identifier"
		},
		"uniqueIdentifier",
	},
	{
		{NULL, 0, NULL, NULL}, NULL,
	}
};
fn oid_x520_attr_t * oid_x520_attr_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_x520_attr_t * p = oid_x520_attr_type;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_attr_short_name(const mbedtls_asn1_buf * oid, const i8 ** short_name) -> i32
{
	const oid_x520_attr_t * data = oid_x520_attr_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*short_name = data.short_name;
	return 0;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	i32 ext_type;
} oid_x509_ext_t;
static const oid_x509_ext_t oid_x509_ext[] =
{
	{
		{
			"\x55"
			"\x1D"
			"\x13",
			(sizeof("\x55"
			"\x1D"
			"\x13") -
			1),
			"id-ce-basicConstraints", "Basic Constraints"
		},
		(1 << 8),
	},
	{
		{
			"\x55"
			"\x1D"
			"\x0F",
			(sizeof("\x55"
			"\x1D"
			"\x0F") -
			1),
			"id-ce-keyUsage", "Key Usage"
		},
		(1 << 2),
	},
	{
		{
			"\x55"
			"\x1D"
			"\x25",
			(sizeof("\x55"
			"\x1D"
			"\x25") -
			1),
			"id-ce-extKeyUsage", "Extended Key Usage"
		},
		(1 << 11),
	},
	{
		{
			"\x55"
			"\x1D"
			"\x11",
			(sizeof("\x55"
			"\x1D"
			"\x11") -
			1),
			"id-ce-subjectAltName", "Subject Alt Name"
		},
		(1 << 5),
	},
	{
		{
			"\x60"
			"\x86\x48"
			"\x01"
			"\x86\xF8\x42"
			"\x01"
			"\x01",
			(sizeof("\x60"
			"\x86\x48"
			"\x01"
			"\x86\xF8\x42"
			"\x01"
			"\x01") -
			1),
			"id-netscape-certtype", "Netscape Certificate Type"
		},
		(1 << 16),
	},
	{
		{NULL, 0, NULL, NULL}, 0,
	},
};
fn oid_x509_ext_t * oid_x509_ext_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_x509_ext_t * p = oid_x509_ext;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_x509_ext_type(const mbedtls_asn1_buf * oid, i32 * ext_type) -> i32
{
	const oid_x509_ext_t * data = oid_x509_ext_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*ext_type = data.ext_type;
	return 0;
}

static const mbedtls_oid_descriptor_t oid_ext_key_usage[] =
{
	{
		"\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x01",
		(sizeof("\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x01") -
		1),
		"id-kp-serverAuth", "TLS Web Server Authentication"
	},
	{
		"\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x02",
		(sizeof("\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x02") -
		1),
		"id-kp-clientAuth", "TLS Web Client Authentication"
	},
	{
		"\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x03",
		(sizeof("\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x03") -
		1),
		"id-kp-codeSigning", "Code Signing"
	},
	{
		"\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x04",
		(sizeof("\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x04") -
		1),
		"id-kp-emailProtection", "E-mail Protection"
	},
	{
		"\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x08",
		(sizeof("\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x08") -
		1),
		"id-kp-timeStamping", "Time Stamping"
	},
	{
		"\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x09",
		(sizeof("\x2b"
		"\x06"
		"\x01\x05\x05\x07"
		"\x03"
		"\x09") -
		1),
		"id-kp-OCSPSigning", "OCSP Signing"
	},
	{NULL, 0, NULL, NULL},
};
fn mbedtls_oid_descriptor_t * oid_ext_key_usage_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const mbedtls_oid_descriptor_t * p = oid_ext_key_usage;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_extended_key_usage(const mbedtls_asn1_buf * oid, const i8 ** description) -> i32
{
	const mbedtls_oid_descriptor_t * data = oid_ext_key_usage_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*description = data.description;
	return 0;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	mbedtls_md_type_t md_alg;
	mbedtls_pk_type_t pk_alg;
} oid_sig_alg_t;
static const oid_sig_alg_t oid_sig_alg[] =
{
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x02",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x02") -
			1),
			"md2WithRSAEncryption", "RSA with MD2"
		},
		MBEDTLS_MD_MD2, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x03",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x03") -
			1),
			"md4WithRSAEncryption", "RSA with MD4"
		},
		MBEDTLS_MD_MD4, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x04",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x04") -
			1),
			"md5WithRSAEncryption", "RSA with MD5"
		},
		MBEDTLS_MD_MD5, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x05",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x05") -
			1),
			"sha-1WithRSAEncryption", "RSA with SHA1"
		},
		MBEDTLS_MD_SHA1, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0e",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0e") -
			1),
			"sha224WithRSAEncryption", "RSA with SHA-224"
		},
		MBEDTLS_MD_SHA224, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0b",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0b") -
			1),
			"sha256WithRSAEncryption", "RSA with SHA-256"
		},
		MBEDTLS_MD_SHA256, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0c",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0c") -
			1),
			"sha384WithRSAEncryption", "RSA with SHA-384"
		},
		MBEDTLS_MD_SHA384, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0d",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0d") -
			1),
			"sha512WithRSAEncryption", "RSA with SHA-512"
		},
		MBEDTLS_MD_SHA512, MBEDTLS_PK_RSA,
	},
	{
		{"\x2B\x0E\x03\x02\x1D", (sizeof("\x2B\x0E\x03\x02\x1D") - 1), "sha-1WithRSAEncryption", "RSA with SHA1"}, MBEDTLS_MD_SHA1, MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x01",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x01") -
			1),
			"ecdsa-with-SHA1", "ECDSA with SHA1"
		},
		MBEDTLS_MD_SHA1, MBEDTLS_PK_ECDSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x01",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x01") -
			1),
			"ecdsa-with-SHA224", "ECDSA with SHA224"
		},
		MBEDTLS_MD_SHA224, MBEDTLS_PK_ECDSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x02",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x02") -
			1),
			"ecdsa-with-SHA256", "ECDSA with SHA256"
		},
		MBEDTLS_MD_SHA256, MBEDTLS_PK_ECDSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x03",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x03") -
			1),
			"ecdsa-with-SHA384", "ECDSA with SHA384"
		},
		MBEDTLS_MD_SHA384, MBEDTLS_PK_ECDSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x04",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x04"
			"\x03"
			"\x04") -
			1),
			"ecdsa-with-SHA512", "ECDSA with SHA512"
		},
		MBEDTLS_MD_SHA512, MBEDTLS_PK_ECDSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0a",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x0a") -
			1),
			"RSASSA-PSS", "RSASSA-PSS"
		},
		MBEDTLS_MD_NONE, MBEDTLS_PK_RSASSA_PSS,
	},
	{
		{NULL, 0, NULL, NULL}, MBEDTLS_MD_NONE, MBEDTLS_PK_NONE,
	},
};
fn oid_sig_alg_t * oid_sig_alg_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_sig_alg_t * p = oid_sig_alg;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_sig_alg_desc(const mbedtls_asn1_buf * oid, const i8 ** description) -> i32
{
	const oid_sig_alg_t * data = oid_sig_alg_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*description = data.descriptor.description;
	return 0;
}

pub fn mbedtls_oid_get_sig_alg(const mbedtls_asn1_buf * oid, mbedtls_md_type_t * md_alg, mbedtls_pk_type_t * pk_alg) -> i32
{
	const oid_sig_alg_t * data = oid_sig_alg_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*md_alg = data.md_alg;
	*pk_alg = data.pk_alg;
	return 0;
}

pub fn mbedtls_oid_get_oid_by_sig_alg(mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg, const i8 ** oid, usize * olen) -> i32
{
	const oid_sig_alg_t * cur = oid_sig_alg;
	while (cur.descriptor.asn1 != NULL)
	{
		if cur.pk_alg == pk_alg && cur.md_alg == md_alg
		{
			*oid = cur.descriptor.asn1;
			*olen = cur.descriptor.asn1_len;
			return 0;
		}
		cur++;
	}
	return -0x002E;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	mbedtls_pk_type_t pk_alg;
} oid_pk_alg_t;
static const oid_pk_alg_t oid_pk_alg[] =
{
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x01",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x01"
			"\x01") -
			1),
			"rsaEncryption", "RSA"
		},
		MBEDTLS_PK_RSA,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x02\01",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x02\01") -
			1),
			"id-ecPublicKey", "Generic EC key"
		},
		MBEDTLS_PK_ECKEY,
	},
	{
		{
			"\x2b"
			"\x81\x04"
			"\x01\x0c",
			(sizeof("\x2b"
			"\x81\x04"
			"\x01\x0c") -
			1),
			"id-ecDH", "EC key for ECDH"
		},
		MBEDTLS_PK_ECKEY_DH,
	},
	{
		{NULL, 0, NULL, NULL}, MBEDTLS_PK_NONE,
	},
};
fn oid_pk_alg_t * oid_pk_alg_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_pk_alg_t * p = oid_pk_alg;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_pk_alg(const mbedtls_asn1_buf * oid, mbedtls_pk_type_t * pk_alg) -> i32
{
	const oid_pk_alg_t * data = oid_pk_alg_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*pk_alg = data.pk_alg;
	return 0;
}

pub fn mbedtls_oid_get_oid_by_pk_alg(mbedtls_pk_type_t pk_alg, const i8 ** oid, usize * olen) -> i32
{
	const oid_pk_alg_t * cur = oid_pk_alg;
	while (cur.descriptor.asn1 != NULL)
	{
		if cur.pk_alg == pk_alg
		{
			*oid = cur.descriptor.asn1;
			*olen = cur.descriptor.asn1_len;
			return 0;
		}
		cur++;
	}
	return -0x002E;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	mbedtls_ecp_group_id grp_id;
} oid_ecp_grp_t;
static const oid_ecp_grp_t oid_ecp_grp[] =
{
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x03\x01\x01",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x03\x01\x01") -
			1),
			"secp192r1", "secp192r1"
		},
		MBEDTLS_ECP_DP_SECP192R1,
	},
	{
		{
			"\x2b"
			"\x81\x04"
			"\x00\x21",
			(sizeof("\x2b"
			"\x81\x04"
			"\x00\x21") -
			1),
			"secp224r1", "secp224r1"
		},
		MBEDTLS_ECP_DP_SECP224R1,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x03\x01\x07",
			(sizeof("\x2a"
			"\x86\x48"
			"\xce\x3d"
			"\x03\x01\x07") -
			1),
			"secp256r1", "secp256r1"
		},
		MBEDTLS_ECP_DP_SECP256R1,
	},
	{
		{
			"\x2b"
			"\x81\x04"
			"\x00\x22",
			(sizeof("\x2b"
			"\x81\x04"
			"\x00\x22") -
			1),
			"secp384r1", "secp384r1"
		},
		MBEDTLS_ECP_DP_SECP384R1,
	},
	{
		{
			"\x2b"
			"\x81\x04"
			"\x00\x23",
			(sizeof("\x2b"
			"\x81\x04"
			"\x00\x23") -
			1),
			"secp521r1", "secp521r1"
		},
		MBEDTLS_ECP_DP_SECP521R1,
	},
	{
		{
			"\x2b"
			"\x81\x04"
			"\x00\x1f",
			(sizeof("\x2b"
			"\x81\x04"
			"\x00\x1f") -
			1),
			"secp192k1", "secp192k1"
		},
		MBEDTLS_ECP_DP_SECP192K1,
	},
	{
		{
			"\x2b"
			"\x81\x04"
			"\x00\x20",
			(sizeof("\x2b"
			"\x81\x04"
			"\x00\x20") -
			1),
			"secp224k1", "secp224k1"
		},
		MBEDTLS_ECP_DP_SECP224K1,
	},
	{
		{
			"\x2b"
			"\x81\x04"
			"\x00\x0a",
			(sizeof("\x2b"
			"\x81\x04"
			"\x00\x0a") -
			1),
			"secp256k1", "secp256k1"
		},
		MBEDTLS_ECP_DP_SECP256K1,
	},
	{
		{
			"\x2b"
			"\x24"
			"\x03\x03\x02\x08\x01\x01"
			"\x07",
			(sizeof("\x2b"
			"\x24"
			"\x03\x03\x02\x08\x01\x01"
			"\x07") -
			1),
			"brainpoolP256r1", "brainpool256r1"
		},
		MBEDTLS_ECP_DP_BP256R1,
	},
	{
		{
			"\x2b"
			"\x24"
			"\x03\x03\x02\x08\x01\x01"
			"\x0B",
			(sizeof("\x2b"
			"\x24"
			"\x03\x03\x02\x08\x01\x01"
			"\x0B") -
			1),
			"brainpoolP384r1", "brainpool384r1"
		},
		MBEDTLS_ECP_DP_BP384R1,
	},
	{
		{
			"\x2b"
			"\x24"
			"\x03\x03\x02\x08\x01\x01"
			"\x0D",
			(sizeof("\x2b"
			"\x24"
			"\x03\x03\x02\x08\x01\x01"
			"\x0D") -
			1),
			"brainpoolP512r1", "brainpool512r1"
		},
		MBEDTLS_ECP_DP_BP512R1,
	},
	{
		{NULL, 0, NULL, NULL}, MBEDTLS_ECP_DP_NONE,
	},
};
fn oid_ecp_grp_t * oid_grp_id_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_ecp_grp_t * p = oid_ecp_grp;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_ec_grp(const mbedtls_asn1_buf * oid, mbedtls_ecp_group_id * grp_id) -> i32
{
	const oid_ecp_grp_t * data = oid_grp_id_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*grp_id = data.grp_id;
	return 0;
}

pub fn mbedtls_oid_get_oid_by_ec_grp(mbedtls_ecp_group_id grp_id, const i8 ** oid, usize * olen) -> i32
{
	const oid_ecp_grp_t * cur = oid_ecp_grp;
	while (cur.descriptor.asn1 != NULL)
	{
		if cur.grp_id == grp_id
		{
			*oid = cur.descriptor.asn1;
			*olen = cur.descriptor.asn1_len;
			return 0;
		}
		cur++;
	}
	return -0x002E;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	mbedtls_cipher_type_t cipher_alg;
} oid_cipher_alg_t;
static const oid_cipher_alg_t oid_cipher_alg[] =
{
	{
		{
			"\x2b"
			"\x0e"
			"\x03"
			"\x02"
			"\x07",
			(sizeof("\x2b"
			"\x0e"
			"\x03"
			"\x02"
			"\x07") -
			1),
			"desCBC", "DES-CBC"
		},
		MBEDTLS_CIPHER_DES_CBC,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x03\x07",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x03\x07") -
			1),
			"des-ede3-cbc", "DES-EDE3-CBC"
		},
		MBEDTLS_CIPHER_DES_EDE3_CBC,
	},
	{
		{NULL, 0, NULL, NULL}, MBEDTLS_CIPHER_NONE,
	},
};
fn oid_cipher_alg_t * oid_cipher_alg_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_cipher_alg_t * p = oid_cipher_alg;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_cipher_alg(const mbedtls_asn1_buf * oid, mbedtls_cipher_type_t * cipher_alg) -> i32
{
	const oid_cipher_alg_t * data = oid_cipher_alg_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*cipher_alg = data.cipher_alg;
	return 0;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	mbedtls_md_type_t md_alg;
} oid_md_alg_t;
static const oid_md_alg_t oid_md_alg[] =
{
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x02\x02",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x02\x02") -
			1),
			"id-md2", "MD2"
		},
		MBEDTLS_MD_MD2,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x02\x04",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x02\x04") -
			1),
			"id-md4", "MD4"
		},
		MBEDTLS_MD_MD4,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x02\x05",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x02\x05") -
			1),
			"id-md5", "MD5"
		},
		MBEDTLS_MD_MD5,
	},
	{
		{
			"\x2b"
			"\x0e"
			"\x03"
			"\x02"
			"\x1a",
			(sizeof("\x2b"
			"\x0e"
			"\x03"
			"\x02"
			"\x1a") -
			1),
			"id-sha1", "SHA-1"
		},
		MBEDTLS_MD_SHA1,
	},
	{
		{
			"\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x04",
			(sizeof("\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x04") -
			1),
			"id-sha224", "SHA-224"
		},
		MBEDTLS_MD_SHA224,
	},
	{
		{
			"\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x01",
			(sizeof("\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x01") -
			1),
			"id-sha256", "SHA-256"
		},
		MBEDTLS_MD_SHA256,
	},
	{
		{
			"\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x02",
			(sizeof("\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x02") -
			1),
			"id-sha384", "SHA-384"
		},
		MBEDTLS_MD_SHA384,
	},
	{
		{
			"\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x03",
			(sizeof("\x60"
			"\x86\x48"
			"\x01"
			"\x65"
			"\x03\x04\x02\x03") -
			1),
			"id-sha512", "SHA-512"
		},
		MBEDTLS_MD_SHA512,
	},
	{
		{NULL, 0, NULL, NULL}, MBEDTLS_MD_NONE,
	},
};
fn oid_md_alg_t * oid_md_alg_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_md_alg_t * p = oid_md_alg;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_md_alg(const mbedtls_asn1_buf * oid, mbedtls_md_type_t * md_alg) -> i32
{
	const oid_md_alg_t * data = oid_md_alg_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*md_alg = data.md_alg;
	return 0;
}

pub fn mbedtls_oid_get_oid_by_md(mbedtls_md_type_t md_alg, const i8 ** oid, usize * olen) -> i32
{
	const oid_md_alg_t * cur = oid_md_alg;
	while (cur.descriptor.asn1 != NULL)
	{
		if cur.md_alg == md_alg
		{
			*oid = cur.descriptor.asn1;
			*olen = cur.descriptor.asn1_len;
			return 0;
		}
		cur++;
	}
	return -0x002E;
}

typedef struct
{
	mbedtls_oid_descriptor_t descriptor;
	mbedtls_md_type_t md_alg;
	mbedtls_cipher_type_t cipher_alg;
} oid_pkcs12_pbe_alg_t;
static const oid_pkcs12_pbe_alg_t oid_pkcs12_pbe_alg[] =
{
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x0c"
			"\x01"
			"\x03",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x0c"
			"\x01"
			"\x03") -
			1),
			"pbeWithSHAAnd3-KeyTripleDES-CBC", "PBE with SHA1 and 3-Key 3DES"
		},
		MBEDTLS_MD_SHA1, MBEDTLS_CIPHER_DES_EDE3_CBC,
	},
	{
		{
			"\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x0c"
			"\x01"
			"\x04",
			(sizeof("\x2a"
			"\x86\x48"
			"\x86\xf7\x0d"
			"\x01"
			"\x0c"
			"\x01"
			"\x04") -
			1),
			"pbeWithSHAAnd2-KeyTripleDES-CBC", "PBE with SHA1 and 2-Key 3DES"
		},
		MBEDTLS_MD_SHA1, MBEDTLS_CIPHER_DES_EDE_CBC,
	},
	{
		{NULL, 0, NULL, NULL}, MBEDTLS_MD_NONE, MBEDTLS_CIPHER_NONE,
	},
};
fn oid_pkcs12_pbe_alg_t * oid_pkcs12_pbe_alg_from_asn1(const mbedtls_asn1_buf * oid) -> const
{
	const oid_pkcs12_pbe_alg_t * p = oid_pkcs12_pbe_alg;
	const mbedtls_oid_descriptor_t * cur = (const mbedtls_oid_descriptor_t *) p;
	if p == NULL || oid == NULL
	{
		return NULL;
	}
	while (cur.asn1 != NULL)
	{
		if cur.asn1_len == oid.len && memcmp(cur.asn1, oid.p, oid.len) == 0
		{
			return p;
		}
		p++;
		cur = (const mbedtls_oid_descriptor_t *) p;
	}
	return NULL;
}

pub fn mbedtls_oid_get_pkcs12_pbe_alg(const mbedtls_asn1_buf * oid, mbedtls_md_type_t * md_alg, mbedtls_cipher_type_t * cipher_alg) -> i32
{
	const oid_pkcs12_pbe_alg_t * data = oid_pkcs12_pbe_alg_from_asn1(oid);
	if data == NULL
	{
		return -0x002E;
	}
	*md_alg = data.md_alg;
	*cipher_alg = data.cipher_alg;
	return 0;
}

pub fn mbedtls_oid_get_numeric_string(i8 * buf, usize size, const mbedtls_asn1_buf * oid) -> i32
{
	i32 ret;
	usize i, n;
	u32 value;
	i8 * p;
	p = buf;
	n = size;
	if oid.len > 0
	{
		ret = snprintf(p, n, "%d.%d", oid.p[0] / 40, oid.p[0] % 40);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x000B;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
	}
	value = 0;
	for (i = 1; i < oid.len; i++)
	{
		if ((value << 7) >> 7) != value
		{
			return -0x000B;
		}
		value <<= 7;
		value += oid.p[i] & 0x7F;
		if !(oid.p[i] & 0x80)
		{
			ret = snprintf(p, n, ".%d", value);
			do
			{
				if ret < 0 || (usize) ret >= n
				{
					return -0x000B;
				}
				n -= (usize) ret;
				p += (usize) ret;
			}
			while (0);
			value = 0;
		}
	}
	return (int) (size - n);
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_pem_init(mbedtls_pem_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_pem_context));
}

fn pem_get_iv(const u8 * s, u8 * iv, usize iv_len) -> i32
{
	usize i, j, k;
	memset(iv, 0, iv_len);
	for (i = 0; i < iv_len * 2; i++, s++)
	{
		if *s >= '0' && *s <= '9'
		{
			j = *s - '0';
		}
		else
			if *s >= 'A' && *s <= 'F'
			{
				j = *s - '7';
			}
			else
				if *s >= 'a' && *s <= 'f'
				{
					j = *s - 'W';
				}
				else
				{
					return -0x1200;
				}
		k = ((i & 1) != 0) ? j : j << 4;
		iv[i >> 1] = (i8) (iv[i >> 1] | k);
	}
	return 0;
}

fn pem_pbkdf1(u8 * key, usize keylen, u8 * iv, const u8 * pwd, usize pwdlen)
{
	mbedtls_md5_context md5_ctx;
	u8 md5sum[16];
	usize use_len;
	mbedtls_md5_init(&md5_ctx);
	mbedtls_md5_starts(&md5_ctx);
	mbedtls_md5_update(&md5_ctx, pwd, pwdlen);
	mbedtls_md5_update(&md5_ctx, iv, 8);
	mbedtls_md5_finish(&md5_ctx, md5sum);
	if keylen <= 16
	{
		memcpy(key, md5sum, keylen);
		mbedtls_md5_free(&md5_ctx);
		zeroize(md5sum, 16);
		return;
	}
	memcpy(key, md5sum, 16);
	mbedtls_md5_starts(&md5_ctx);
	mbedtls_md5_update(&md5_ctx, md5sum, 16);
	mbedtls_md5_update(&md5_ctx, pwd, pwdlen);
	mbedtls_md5_update(&md5_ctx, iv, 8);
	mbedtls_md5_finish(&md5_ctx, md5sum);
	use_len = 16;
	if keylen < 32
	{
		use_len = keylen - 16;
	}
	memcpy(key + 16, md5sum, use_len);
	mbedtls_md5_free(&md5_ctx);
	zeroize(md5sum, 16);
}

fn pem_des_decrypt(u8 des_iv[8], u8 * buf, usize buflen, const u8 * pwd, usize pwdlen)
{
	mbedtls_des_context des_ctx;
	u8 des_key[8];
	mbedtls_des_init(&des_ctx);
	pem_pbkdf1(des_key, 8, des_iv, pwd, pwdlen);
	mbedtls_des_setkey_dec(&des_ctx, des_key);
	mbedtls_des_crypt_cbc(&des_ctx, 0, buflen, des_iv, buf, buf);
	mbedtls_des_free(&des_ctx);
	zeroize(des_key, 8);
}

fn pem_des3_decrypt(u8 des3_iv[8], u8 * buf, usize buflen, const u8 * pwd, usize pwdlen)
{
	mbedtls_des3_context des3_ctx;
	u8 des3_key[24];
	mbedtls_des3_init(&des3_ctx);
	pem_pbkdf1(des3_key, 24, des3_iv, pwd, pwdlen);
	mbedtls_des3_set3key_dec(&des3_ctx, des3_key);
	mbedtls_des3_crypt_cbc(&des3_ctx, 0, buflen, des3_iv, buf, buf);
	mbedtls_des3_free(&des3_ctx);
	zeroize(des3_key, 24);
}

fn pem_aes_decrypt(u8 aes_iv[16], u32 keylen, u8 * buf, usize buflen, const u8 * pwd, usize pwdlen)
{
	mbedtls_aes_context aes_ctx;
	u8 aes_key[32];
	mbedtls_aes_init(&aes_ctx);
	pem_pbkdf1(aes_key, keylen, aes_iv, pwd, pwdlen);
	mbedtls_aes_setkey_dec(&aes_ctx, aes_key, keylen * 8);
	mbedtls_aes_crypt_cbc(&aes_ctx, 0, buflen, aes_iv, buf, buf);
	mbedtls_aes_free(&aes_ctx);
	zeroize(aes_key, keylen);
}

pub fn mbedtls_pem_read_buffer(mbedtls_pem_context * ctx, const i8 * header, const i8 * footer, const u8 * data, const u8 * pwd, usize pwdlen, usize * use_len) -> i32
{
	i32 ret, enc;
	usize len;
	u8 * buf;
	const u8 *s1, *s2, *end;
	u8 pem_iv[16];
	mbedtls_cipher_type_t enc_alg = MBEDTLS_CIPHER_NONE;
	if ctx == NULL
	{
		return -0x1480;
	}
	s1 = (u8 *) strstr((const i8 *) data, header);
	if s1 == NULL
	{
		return -0x1080;
	}
	s2 = (u8 *) strstr((const i8 *) data, footer);
	if s2 == NULL || s2 <= s1
	{
		return -0x1080;
	}
	s1 += strlen(header);
	if *s1 == ' '
	{
		s1++;
	}
	if *s1 == '\r'
	{
		s1++;
	}
	if *s1 == '\n'
	{
		s1++;
	}
	else
	{
		return -0x1080;
	}
	end = s2;
	end += strlen(footer);
	if *end == ' '
	{
		end++;
	}
	if *end == '\r'
	{
		end++;
	}
	if *end == '\n'
	{
		end++;
	}
	*use_len = end - data;
	enc = 0;
	if memcmp(s1, "Proc-Type: 4,ENCRYPTED", 22) == 0
	{
		enc++;
		s1 += 22;
		if *s1 == '\r'
		{
			s1++;
		}
		if *s1 == '\n'
		{
			s1++;
		}
		else
		{
			return -0x1100;
		}
		if memcmp(s1, "DEK-Info: DES-EDE3-CBC,", 23) == 0
		{
			enc_alg = MBEDTLS_CIPHER_DES_EDE3_CBC;
			s1 += 23;
			if pem_get_iv(s1, pem_iv, 8) != 0
			{
				return -0x1200;
			}
			s1 += 16;
		}
		else
			if memcmp(s1, "DEK-Info: DES-CBC,", 18) == 0
			{
				enc_alg = MBEDTLS_CIPHER_DES_CBC;
				s1 += 18;
				if pem_get_iv(s1, pem_iv, 8) != 0
				{
					return -0x1200;
				}
				s1 += 16;
			}
		if memcmp(s1, "DEK-Info: AES-", 14) == 0
		{
			if memcmp(s1, "DEK-Info: AES-128-CBC,", 22) == 0
			{
				enc_alg = MBEDTLS_CIPHER_AES_128_CBC;
			}
			else
				if memcmp(s1, "DEK-Info: AES-192-CBC,", 22) == 0
				{
					enc_alg = MBEDTLS_CIPHER_AES_192_CBC;
				}
				else
					if memcmp(s1, "DEK-Info: AES-256-CBC,", 22) == 0
					{
						enc_alg = MBEDTLS_CIPHER_AES_256_CBC;
					}
					else
					{
						return -0x1280;
					}
			s1 += 22;
			if pem_get_iv(s1, pem_iv, 16) != 0
			{
				return -0x1200;
			}
			s1 += 32;
		}
		if enc_alg == MBEDTLS_CIPHER_NONE
		{
			return -0x1280;
		}
		if *s1 == '\r'
		{
			s1++;
		}
		if *s1 == '\n'
		{
			s1++;
		}
		else
		{
			return -0x1100;
		}
	}
	if s1 == s2
	{
		return -0x1100;
	}
	ret = mbedtls_base64_decode(NULL, 0, &len, s1, s2 - s1);
	if ret == -0x002C
	{
		return -0x1100 + ret;
	}
	if (buf = mbedtls_calloc(1, len)) == NULL
	{
		return -0x1180;
	}
	if (ret = mbedtls_base64_decode(buf, len, &len, s1, s2 - s1)) != 0
	{
		mbedtls_free(buf);
		return -0x1100 + ret;
	}
	if enc != 0
	{
		if pwd == NULL
		{
			mbedtls_free(buf);
			return -0x1300;
		}
		if enc_alg == MBEDTLS_CIPHER_DES_EDE3_CBC
		{
			pem_des3_decrypt(pem_iv, buf, len, pwd, pwdlen);
		}
		else
			if enc_alg == MBEDTLS_CIPHER_DES_CBC
			{
				pem_des_decrypt(pem_iv, buf, len, pwd, pwdlen);
			}
		if enc_alg == MBEDTLS_CIPHER_AES_128_CBC
		{
			pem_aes_decrypt(pem_iv, 16, buf, len, pwd, pwdlen);
		}
		else
			if enc_alg == MBEDTLS_CIPHER_AES_192_CBC
			{
				pem_aes_decrypt(pem_iv, 24, buf, len, pwd, pwdlen);
			}
			else
				if enc_alg == MBEDTLS_CIPHER_AES_256_CBC
				{
					pem_aes_decrypt(pem_iv, 32, buf, len, pwd, pwdlen);
				}
		if len <= 2 || buf[0] != 0x30 || buf[1] > 0x83
		{
			mbedtls_free(buf);
			return -0x1380;
		}
	}
	ctx.buf = buf;
	ctx.buflen = len;
	return 0;
}

pub fn mbedtls_pem_free(mbedtls_pem_context * ctx)
{
	mbedtls_free(ctx.buf);
	mbedtls_free(ctx.info);
	zeroize(ctx, sizeof(mbedtls_pem_context));
}

pub fn mbedtls_pem_write_buffer(const i8 * header, const i8 * footer, const u8 * der_data, usize der_len, u8 * buf, usize buf_len, usize * olen) -> i32
{
	i32 ret;
	u8 *encode_buf, *c, *p = buf;
	usize len = 0, use_len, add_len = 0;
	mbedtls_base64_encode(NULL, 0, &use_len, der_data, der_len);
	add_len = strlen(header) + strlen(footer) + (use_len / 64) + 1;
	if use_len + add_len > buf_len
	{
		*olen = use_len + add_len;
		return -0x002A;
	}
	if (encode_buf = mbedtls_calloc(1, use_len)) == NULL
	{
		return -0x1180;
	}
	if (ret = mbedtls_base64_encode(encode_buf, use_len, &use_len, der_data, der_len)) != 0
	{
		mbedtls_free(encode_buf);
		return ret;
	}
	memcpy(p, header, strlen(header));
	p += strlen(header);
	c = encode_buf;
	while (use_len)
	{
		len = (use_len > 64) ? 64 : use_len;
		memcpy(p, c, len);
		use_len -= len;
		p += len;
		c += len;
		*p++ = '\n';
	}
	memcpy(p, footer, strlen(footer));
	p += strlen(footer);
	*p++ = '\0';
	*olen = p - buf;
	mbedtls_free(encode_buf);
	return 0;
}

struct mbedtls_pk_info_t
{
	mbedtls_pk_type_t type;
	const i8 * name;
	usize (*get_bitlen)(const void *);
	i32 (*can_do)(mbedtls_pk_type_t type);
	i32 (*verify_func)(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, const u8 * sig, usize sig_len);
	i32 (*sign_func)(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, u8 * sig, usize * sig_len, i32 (*f_rng)(void *, u8 *, usize), void * p_rng);
	i32 (*decrypt_func)(void * ctx, const u8 * input, usize ilen, u8 * output, usize * olen, usize osize, i32 (*f_rng)(void *, u8 *, usize), void * p_rng);
	i32 (*encrypt_func)(void * ctx, const u8 * input, usize ilen, u8 * output, usize * olen, usize osize, i32 (*f_rng)(void *, u8 *, usize), void * p_rng);
	i32 (*check_pair_func)(const void * pub, const void * prv);
	void * (*ctx_alloc_func)(void);
	void (*ctx_free_func)(void * ctx);
	void (*debug_func)(const void * ctx, mbedtls_pk_debug_item * items);
};
typedef struct
{
	void * key;
	mbedtls_pk_rsa_alt_decrypt_func decrypt_func;
	mbedtls_pk_rsa_alt_sign_func sign_func;
	mbedtls_pk_rsa_alt_key_len_func key_len_func;
} mbedtls_rsa_alt_context;
static  mbedtls_pk_info_t mbedtls_rsa_info;
static  mbedtls_pk_info_t mbedtls_eckey_info;
static  mbedtls_pk_info_t mbedtls_eckeydh_info;
static  mbedtls_pk_info_t mbedtls_ecdsa_info;
static  mbedtls_pk_info_t mbedtls_rsa_alt_info;
fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_pk_init(mbedtls_pk_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	ctx.pk_info = NULL;
	ctx.pk_ctx = NULL;
}

pub fn mbedtls_pk_free(mbedtls_pk_context * ctx)
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return;
	}
	ctx.pk_info.ctx_free_func(ctx.pk_ctx);
	zeroize(ctx, sizeof(mbedtls_pk_context));
}

pub fn mbedtls_pk_info_t * mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type) -> const
{
	switch (pk_type)
	{
		case MBEDTLS_PK_RSA:
		return &mbedtls_rsa_info;
		case MBEDTLS_PK_ECKEY:
		return &mbedtls_eckey_info;
		case MBEDTLS_PK_ECKEY_DH:
		return &mbedtls_eckeydh_info;
		case MBEDTLS_PK_ECDSA:
		return &mbedtls_ecdsa_info;
	default:
		return NULL;
	}
}

pub fn mbedtls_pk_setup(mbedtls_pk_context * ctx, const mbedtls_pk_info_t * info) -> i32
{
	if ctx == NULL || info == NULL || ctx.pk_info != NULL
	{
		return -0x3E80;
	}
	if (ctx.pk_ctx = info.ctx_alloc_func()) == NULL
	{
		return -0x3F80;
	}
	ctx.pk_info = info;
	return 0;
}

pub fn mbedtls_pk_setup_rsa_alt(mbedtls_pk_context * ctx, void * key, mbedtls_pk_rsa_alt_decrypt_func decrypt_func, mbedtls_pk_rsa_alt_sign_func sign_func, mbedtls_pk_rsa_alt_key_len_func key_len_func) -> i32
{
	mbedtls_rsa_alt_context * rsa_alt;
	const mbedtls_pk_info_t * info = &mbedtls_rsa_alt_info;
	if ctx == NULL || ctx.pk_info != NULL
	{
		return -0x3E80;
	}
	if (ctx.pk_ctx = info.ctx_alloc_func()) == NULL
	{
		return -0x3F80;
	}
	ctx.pk_info = info;
	rsa_alt = (mbedtls_rsa_alt_context *) ctx.pk_ctx;
	rsa_alt.key = key;
	rsa_alt.decrypt_func = decrypt_func;
	rsa_alt.sign_func = sign_func;
	rsa_alt.key_len_func = key_len_func;
	return 0;
}

pub fn mbedtls_pk_can_do(const mbedtls_pk_context * ctx, mbedtls_pk_type_t type) -> i32
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return 0;
	}
	return ctx.pk_info.can_do(type);
}

fn i32 pk_hashlen_helper(mbedtls_md_type_t md_alg, usize * hash_len) -> inline
{
	const mbedtls_md_info_t * md_info;
	if *hash_len != 0
	{
		return 0;
	}
	if (md_info = mbedtls_md_info_from_type(md_alg)) == NULL
	{
		return -1;
	}
	*hash_len = mbedtls_md_get_size(md_info);
	return 0;
}

pub fn mbedtls_pk_verify(mbedtls_pk_context * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, const u8 * sig, usize sig_len) -> i32
{
	if ctx == NULL || ctx.pk_info == NULL || pk_hashlen_helper(md_alg, &hash_len) != 0
	{
		return -0x3E80;
	}
	if ctx.pk_info.verify_func == NULL
	{
		return -0x3F00;
	}
	return ctx.pk_info.verify_func(ctx.pk_ctx, md_alg, hash, hash_len, sig, sig_len);
}

pub fn mbedtls_pk_verify_ext(mbedtls_pk_type_t type, const void * options, mbedtls_pk_context * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, const u8 * sig, usize sig_len) -> i32
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return -0x3E80;
	}
	if !mbedtls_pk_can_do(ctx, type)
	{
		return -0x3F00;
	}
	if type == MBEDTLS_PK_RSASSA_PSS
	{
		i32 ret;
		const mbedtls_pk_rsassa_pss_options * pss_opts;
		if options == NULL
		{
			return -0x3E80;
		}
		pss_opts = (const mbedtls_pk_rsassa_pss_options *) options;
		if sig_len < mbedtls_pk_get_len(ctx)
		{
			return -0x4380;
		}
		ret = mbedtls_rsa_rsassa_pss_verify_ext(mbedtls_pk_rsa(*ctx), NULL, NULL, 0, md_alg, (i32 int) hash_len, hash, pss_opts.mgf1_hash_id, pss_opts.expected_salt_len, sig);
		if ret != 0
		{
			return ret;
		}
		if sig_len > mbedtls_pk_get_len(ctx)
		{
			return -0x3900;
		}
		return 0;
	}
	if options != NULL
	{
		return -0x3E80;
	}
	return mbedtls_pk_verify(ctx, md_alg, hash, hash_len, sig, sig_len);
}

pub fn mbedtls_pk_sign(mbedtls_pk_context * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, u8 * sig, usize * sig_len, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	if ctx == NULL || ctx.pk_info == NULL || pk_hashlen_helper(md_alg, &hash_len) != 0
	{
		return -0x3E80;
	}
	if ctx.pk_info.sign_func == NULL
	{
		return -0x3F00;
	}
	return ctx.pk_info.sign_func(ctx.pk_ctx, md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng);
}

pub fn mbedtls_pk_decrypt(mbedtls_pk_context * ctx, const u8 * input, usize ilen, u8 * output, usize * olen, usize osize, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return -0x3E80;
	}
	if ctx.pk_info.decrypt_func == NULL
	{
		return -0x3F00;
	}
	return ctx.pk_info.decrypt_func(ctx.pk_ctx, input, ilen, output, olen, osize, f_rng, p_rng);
}

pub fn mbedtls_pk_encrypt(mbedtls_pk_context * ctx, const u8 * input, usize ilen, u8 * output, usize * olen, usize osize, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return -0x3E80;
	}
	if ctx.pk_info.encrypt_func == NULL
	{
		return -0x3F00;
	}
	return ctx.pk_info.encrypt_func(ctx.pk_ctx, input, ilen, output, olen, osize, f_rng, p_rng);
}

pub fn mbedtls_pk_check_pair(const mbedtls_pk_context * pub, const mbedtls_pk_context * prv) -> i32
{
	if pub == NULL || pub.pk_info == NULL || prv == NULL || prv.pk_info == NULL || prv.pk_info.check_pair_func == NULL
	{
		return -0x3E80;
	}
	if prv.pk_info.type == MBEDTLS_PK_RSA_ALT
	{
		if pub.pk_info.type != MBEDTLS_PK_RSA
		{
			return -0x3F00;
		}
	}
	else
	{
		if pub.pk_info != prv.pk_info
		{
			return -0x3F00;
		}
	}
	return prv.pk_info.check_pair_func(pub.pk_ctx, prv.pk_ctx);
}

pub fn mbedtls_pk_get_bitlen(const mbedtls_pk_context * ctx) -> usize
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return 0;
	}
	return ctx.pk_info.get_bitlen(ctx.pk_ctx);
}

pub fn mbedtls_pk_debug(const mbedtls_pk_context * ctx, mbedtls_pk_debug_item * items) -> i32
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return -0x3E80;
	}
	if ctx.pk_info.debug_func == NULL
	{
		return -0x3F00;
	}
	ctx.pk_info.debug_func(ctx.pk_ctx, items);
	return 0;
}

pub fn i8 * mbedtls_pk_get_name(const mbedtls_pk_context * ctx) -> const
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return "invalid PK";
	}
	return ctx.pk_info.name;
}

pub fn mbedtls_pk_get_type(const mbedtls_pk_context * ctx) -> mbedtls_pk_type_t
{
	if ctx == NULL || ctx.pk_info == NULL
	{
		return MBEDTLS_PK_NONE;
	}
	return ctx.pk_info.type;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

fn rsa_can_do(mbedtls_pk_type_t type) -> i32
{
	return type == MBEDTLS_PK_RSA || type == MBEDTLS_PK_RSASSA_PSS;
}

fn rsa_get_bitlen(const void * ctx) -> usize
{
	return 8 * ((const mbedtls_rsa_context *) ctx)->len;
}

fn rsa_verify_wrap(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, const u8 * sig, usize sig_len) -> i32
{
	i32 ret;
	if sig_len < ((mbedtls_rsa_context *) ctx)->len
	{
		return -0x4380;
	}
	if (ret = mbedtls_rsa_pkcs1_verify((mbedtls_rsa_context *) ctx, NULL, NULL, 0, md_alg, (i32 int) hash_len, hash, sig)) != 0
	{
		return ret;
	}
	if sig_len > ((mbedtls_rsa_context *) ctx)->len
	{
		return -0x3900;
	}
	return 0;
}

fn rsa_sign_wrap(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, u8 * sig, usize * sig_len, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	*sig_len = ((mbedtls_rsa_context *) ctx)->len;
	return mbedtls_rsa_pkcs1_sign((mbedtls_rsa_context *) ctx, f_rng, p_rng, 1, md_alg, (i32 int) hash_len, hash, sig);
}

fn rsa_decrypt_wrap(void * ctx, const u8 * input, usize ilen, u8 * output, usize * olen, usize osize, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	if ilen != ((mbedtls_rsa_context *) ctx)->len
	{
		return -0x4080;
	}
	return mbedtls_rsa_pkcs1_decrypt((mbedtls_rsa_context *) ctx, f_rng, p_rng, 1, olen, input, output, osize);
}

fn rsa_encrypt_wrap(void * ctx, const u8 * input, usize ilen, u8 * output, usize * olen, usize osize, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	*olen = ((mbedtls_rsa_context *) ctx)->len;
	if *olen > osize
	{
		return -0x4400;
	}
	return mbedtls_rsa_pkcs1_encrypt((mbedtls_rsa_context *) ctx, f_rng, p_rng, 0, ilen, input, output);
}

fn rsa_check_pair_wrap(const void * pub, const void * prv) -> i32
{
	return mbedtls_rsa_check_pub_priv((const mbedtls_rsa_context *) pub, (const mbedtls_rsa_context *) prv);
}

fn * rsa_alloc_wrap()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_rsa_context));
	if ctx != NULL
	{
		mbedtls_rsa_init((mbedtls_rsa_context *) ctx, 0, 0);
	}
	return ctx;
}

fn rsa_free_wrap(void * ctx)
{
	mbedtls_rsa_free((mbedtls_rsa_context *) ctx);
	mbedtls_free(ctx);
}

fn rsa_debug(const void * ctx, mbedtls_pk_debug_item * items)
{
	items.type = MBEDTLS_PK_DEBUG_MPI;
	items.name = "rsa.N";
	items.value = &(((mbedtls_rsa_context *) ctx)->N);
	items++;
	items.type = MBEDTLS_PK_DEBUG_MPI;
	items.name = "rsa.E";
	items.value = &(((mbedtls_rsa_context *) ctx)->E);
}

const mbedtls_pk_info_t mbedtls_rsa_info =
{
	MBEDTLS_PK_RSA, "RSA", rsa_get_bitlen, rsa_can_do, rsa_verify_wrap, rsa_sign_wrap, rsa_decrypt_wrap, rsa_encrypt_wrap, rsa_check_pair_wrap, rsa_alloc_wrap, rsa_free_wrap, rsa_debug,
};
fn eckey_can_do(mbedtls_pk_type_t type) -> i32
{
	return type == MBEDTLS_PK_ECKEY || type == MBEDTLS_PK_ECKEY_DH || type == MBEDTLS_PK_ECDSA;
}

fn eckey_get_bitlen(const void * ctx) -> usize
{
	return ((mbedtls_ecp_keypair *) ctx)->grp.pbits;
}

fn eckey_verify_wrap(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, const u8 * sig, usize sig_len) -> i32
{
	i32 ret;
	mbedtls_ecdsa_context ecdsa;
	mbedtls_ecdsa_init(&ecdsa);
	if (ret = mbedtls_ecdsa_from_keypair(&ecdsa, ctx)) == 0
	{
		ret = ecdsa_verify_wrap(&ecdsa, md_alg, hash, hash_len, sig, sig_len);
	}
	mbedtls_ecdsa_free(&ecdsa);
	return ret;
}

fn eckey_sign_wrap(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, u8 * sig, usize * sig_len, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	mbedtls_ecdsa_context ecdsa;
	mbedtls_ecdsa_init(&ecdsa);
	if (ret = mbedtls_ecdsa_from_keypair(&ecdsa, ctx)) == 0
	{
		ret = ecdsa_sign_wrap(&ecdsa, md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng);
	}
	mbedtls_ecdsa_free(&ecdsa);
	return ret;
}

fn eckey_check_pair(const void * pub, const void * prv) -> i32
{
	return mbedtls_ecp_check_pub_priv((const mbedtls_ecp_keypair *) pub, (const mbedtls_ecp_keypair *) prv);
}

fn * eckey_alloc_wrap()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_ecp_keypair));
	if ctx != NULL
	{
		mbedtls_ecp_keypair_init(ctx);
	}
	return ctx;
}

fn eckey_free_wrap(void * ctx)
{
	mbedtls_ecp_keypair_free((mbedtls_ecp_keypair *) ctx);
	mbedtls_free(ctx);
}

fn eckey_debug(const void * ctx, mbedtls_pk_debug_item * items)
{
	items.type = MBEDTLS_PK_DEBUG_ECP;
	items.name = "eckey.Q";
	items.value = &(((mbedtls_ecp_keypair *) ctx)->Q);
}

const mbedtls_pk_info_t mbedtls_eckey_info =
{
	MBEDTLS_PK_ECKEY, "EC", eckey_get_bitlen, eckey_can_do, eckey_verify_wrap, eckey_sign_wrap, NULL, NULL, eckey_check_pair, eckey_alloc_wrap, eckey_free_wrap, eckey_debug,
};
fn eckeydh_can_do(mbedtls_pk_type_t type) -> i32
{
	return type == MBEDTLS_PK_ECKEY || type == MBEDTLS_PK_ECKEY_DH;
}

const mbedtls_pk_info_t mbedtls_eckeydh_info =
{
	MBEDTLS_PK_ECKEY_DH, "EC_DH", eckey_get_bitlen, eckeydh_can_do, NULL, NULL, NULL, NULL, eckey_check_pair, eckey_alloc_wrap, eckey_free_wrap, eckey_debug,
};
fn ecdsa_can_do(mbedtls_pk_type_t type) -> i32
{
	return type == MBEDTLS_PK_ECDSA;
}

fn ecdsa_verify_wrap(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, const u8 * sig, usize sig_len) -> i32
{
	i32 ret;
	((void) md_alg);
	ret = mbedtls_ecdsa_read_signature((mbedtls_ecdsa_context *) ctx, hash, hash_len, sig, sig_len);
	if ret == -0x4C00
	{
		return -0x3900;
	}
	return ret;
}

fn ecdsa_sign_wrap(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, u8 * sig, usize * sig_len, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	return mbedtls_ecdsa_write_signature((mbedtls_ecdsa_context *) ctx, md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng);
}

fn * ecdsa_alloc_wrap()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_ecdsa_context));
	if ctx != NULL
	{
		mbedtls_ecdsa_init((mbedtls_ecdsa_context *) ctx);
	}
	return ctx;
}

fn ecdsa_free_wrap(void * ctx)
{
	mbedtls_ecdsa_free((mbedtls_ecdsa_context *) ctx);
	mbedtls_free(ctx);
}

const mbedtls_pk_info_t mbedtls_ecdsa_info =
{
	MBEDTLS_PK_ECDSA, "ECDSA", eckey_get_bitlen, ecdsa_can_do, ecdsa_verify_wrap, ecdsa_sign_wrap, NULL, NULL, eckey_check_pair, ecdsa_alloc_wrap, ecdsa_free_wrap, eckey_debug,
};
fn rsa_alt_can_do(mbedtls_pk_type_t type) -> i32
{
	return type == MBEDTLS_PK_RSA;
}

fn rsa_alt_get_bitlen(const void * ctx) -> usize
{
	const mbedtls_rsa_alt_context * rsa_alt = (const mbedtls_rsa_alt_context *) ctx;
	return 8 * rsa_alt.key_len_func(rsa_alt.key);
}

fn rsa_alt_sign_wrap(void * ctx, mbedtls_md_type_t md_alg, const u8 * hash, usize hash_len, u8 * sig, usize * sig_len, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	mbedtls_rsa_alt_context * rsa_alt = (mbedtls_rsa_alt_context *) ctx;
	*sig_len = rsa_alt.key_len_func(rsa_alt.key);
	return rsa_alt.sign_func(rsa_alt.key, f_rng, p_rng, 1, md_alg, (i32 int) hash_len, hash, sig);
}

fn rsa_alt_decrypt_wrap(void * ctx, const u8 * input, usize ilen, u8 * output, usize * olen, usize osize, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	mbedtls_rsa_alt_context * rsa_alt = (mbedtls_rsa_alt_context *) ctx;
	((void) f_rng);
	((void) p_rng);
	if ilen != rsa_alt.key_len_func(rsa_alt.key)
	{
		return -0x4080;
	}
	return rsa_alt.decrypt_func(rsa_alt.key, 1, olen, input, output, osize);
}

fn rsa_alt_check_pair(const void * pub, const void * prv) -> i32
{
	u8 sig[1024];
	u8 hash[32];
	usize sig_len = 0;
	i32 ret;
	if rsa_alt_get_bitlen(prv) != rsa_get_bitlen(pub)
	{
		return -0x4200;
	}
	memset(hash, 0x2a, sizeof(hash));
	if (ret = rsa_alt_sign_wrap((void *) prv, MBEDTLS_MD_NONE, hash, sizeof(hash), sig, &sig_len, NULL, NULL)) != 0
	{
		return ret;
	}
	if rsa_verify_wrap((void *) pub, MBEDTLS_MD_NONE, hash, sizeof(hash), sig, sig_len) != 0
	{
		return -0x4200;
	}
	return 0;
}

fn * rsa_alt_alloc_wrap()
{
	void * ctx = mbedtls_calloc(1, sizeof(mbedtls_rsa_alt_context));
	if ctx != NULL
	{
		memset(ctx, 0, sizeof(mbedtls_rsa_alt_context));
	}
	return ctx;
}

fn rsa_alt_free_wrap(void * ctx)
{
	zeroize(ctx, sizeof(mbedtls_rsa_alt_context));
	mbedtls_free(ctx);
}

const mbedtls_pk_info_t mbedtls_rsa_alt_info =
{
	MBEDTLS_PK_RSA_ALT, "RSA-alt", rsa_alt_get_bitlen, rsa_alt_can_do, NULL, rsa_alt_sign_wrap, rsa_alt_decrypt_wrap, NULL, rsa_alt_check_pair, rsa_alt_alloc_wrap, rsa_alt_free_wrap, NULL,
};
fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

fn pkcs12_parse_pbe_params(mbedtls_asn1_buf * params, mbedtls_asn1_buf * salt, i32 * iterations) -> i32
{
	i32 ret;
	u8 ** p = &params.p;
	const u8 * end = params.p + params.len;
	if params.tag != (0x20 | 0x10)
	{
		return -0x1E80 + -0x0062;
	}
	if (ret = mbedtls_asn1_get_tag(p, end, &salt.len, 0x04)) != 0
	{
		return -0x1E80 + ret;
	}
	salt.p = *p;
	*p += salt.len;
	if (ret = mbedtls_asn1_get_int(p, end, iterations)) != 0
	{
		return -0x1E80 + ret;
	}
	if *p != end
	{
		return -0x1E80 + -0x0066;
	}
	return 0;
}

fn pkcs12_pbe_derive_key_iv(mbedtls_asn1_buf * pbe_params, mbedtls_md_type_t md_type, const u8 * pwd, usize pwdlen, u8 * key, usize keylen, u8 * iv, usize ivlen) -> i32
{
	i32 ret, iterations = 0;
	mbedtls_asn1_buf salt;
	usize i;
	u8 unipwd[128 * 2 + 2];
	if pwdlen > 128
	{
		return -0x1F80;
	}
	memset(&salt, 0, sizeof(mbedtls_asn1_buf));
	memset(&unipwd, 0, sizeof(unipwd));
	if (ret = pkcs12_parse_pbe_params(pbe_params, &salt, &iterations)) != 0
	{
		return ret;
	}
	for (i = 0; i < pwdlen; i++)
	{
		unipwd[i * 2 + 1] = pwd[i];
	}
	if (ret = mbedtls_pkcs12_derivation(key, keylen, unipwd, pwdlen * 2 + 2, salt.p, salt.len, md_type, 1, iterations)) != 0
	{
		return ret;
	}
	if iv == NULL || ivlen == 0
	{
		return 0;
	}
	if (ret = mbedtls_pkcs12_derivation(iv, ivlen, unipwd, pwdlen * 2 + 2, salt.p, salt.len, md_type, 2, iterations)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_pkcs12_pbe_sha1_rc4_128(mbedtls_asn1_buf * pbe_params, i32 mode, const u8 * pwd, usize pwdlen, const u8 * data, usize len, u8 * output) -> i32
{
	((void) pbe_params);
	((void) mode);
	((void) pwd);
	((void) pwdlen);
	((void) data);
	((void) len);
	((void) output);
	return -0x1F00;
}

pub fn mbedtls_pkcs12_pbe(mbedtls_asn1_buf * pbe_params, i32 mode, mbedtls_cipher_type_t cipher_type, mbedtls_md_type_t md_type, const u8 * pwd, usize pwdlen, const u8 * data, usize len, u8 * output) -> i32
{
	i32 ret, keylen = 0;
	u8 key[32];
	u8 iv[16];
	const mbedtls_cipher_info_t * cipher_info;
	mbedtls_cipher_context_t cipher_ctx;
	usize olen = 0;
	cipher_info = mbedtls_cipher_info_from_type(cipher_type);
	if cipher_info == NULL
	{
		return -0x1F00;
	}
	keylen = cipher_info.key_bitlen / 8;
	if (ret = pkcs12_pbe_derive_key_iv(pbe_params, md_type, pwd, pwdlen, key, keylen, iv, cipher_info.iv_size)) != 0
	{
		return ret;
	}
	mbedtls_cipher_init(&cipher_ctx);
	if (ret = mbedtls_cipher_setup(&cipher_ctx, cipher_info)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_setkey(&cipher_ctx, key, 8 * keylen, (mbedtls_operation_t) mode)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_set_iv(&cipher_ctx, iv, cipher_info.iv_size)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_reset(&cipher_ctx)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_update(&cipher_ctx, data, len, output, &olen)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_finish(&cipher_ctx, output + olen, &olen)) != 0
	{
		ret = -0x1E00;
	}
exit:
	zeroize(key, sizeof(key));
	zeroize(iv, sizeof(iv));
	mbedtls_cipher_free(&cipher_ctx);
	return ret;
}

fn pkcs12_fill_buffer(u8 * data, usize data_len, const u8 * filler, usize fill_len)
{
	u8 * p = data;
	usize use_len;
	while (data_len > 0)
	{
		use_len = (data_len > fill_len) ? fill_len : data_len;
		memcpy(p, filler, use_len);
		p += use_len;
		data_len -= use_len;
	}
}

pub fn mbedtls_pkcs12_derivation(u8 * data, usize datalen, const u8 * pwd, usize pwdlen, const u8 * salt, usize saltlen, mbedtls_md_type_t md_type, i32 id, i32 iterations) -> i32
{
	i32 ret;
	u32 j;
	u8 diversifier[128];
	u8 salt_block[128], pwd_block[128], hash_block[128];
	u8 hash_output[64];
	u8 * p;
	u8 c;
	usize hlen, use_len, v, i;
	const mbedtls_md_info_t * md_info;
	mbedtls_md_context_t md_ctx;
	if datalen > 128 || pwdlen > 64 || saltlen > 64
	{
		return -0x1F80;
	}
	md_info = mbedtls_md_info_from_type(md_type);
	if md_info == NULL
	{
		return -0x1F00;
	}
	mbedtls_md_init(&md_ctx);
	if (ret = mbedtls_md_setup(&md_ctx, md_info, 0)) != 0
	{
		return ret;
	}
	hlen = mbedtls_md_get_size(md_info);
	if hlen <= 32
	{
		v = 64;
	}
	else
	{
		v = 128;
	}
	memset(diversifier, (i8) id, v);
	pkcs12_fill_buffer(salt_block, v, salt, saltlen);
	pkcs12_fill_buffer(pwd_block, v, pwd, pwdlen);
	p = data;
	while (datalen > 0)
	{
		if (ret = mbedtls_md_starts(&md_ctx)) != 0
		{
			goto exit;
		}
		if (ret = mbedtls_md_update(&md_ctx, diversifier, v)) != 0
		{
			goto exit;
		}
		if (ret = mbedtls_md_update(&md_ctx, salt_block, v)) != 0
		{
			goto exit;
		}
		if (ret = mbedtls_md_update(&md_ctx, pwd_block, v)) != 0
		{
			goto exit;
		}
		if (ret = mbedtls_md_finish(&md_ctx, hash_output)) != 0
		{
			goto exit;
		}
		for (i = 1; i < (usize) iterations; i++)
		{
			if (ret = mbedtls_md(md_info, hash_output, hlen, hash_output)) != 0
			{
				goto exit;
			}
		}
		use_len = (datalen > hlen) ? hlen : datalen;
		memcpy(p, hash_output, use_len);
		datalen -= use_len;
		p += use_len;
		if datalen == 0
		{
			break;

		}
		pkcs12_fill_buffer(hash_block, v, hash_output, hlen);
		for (i = v; i > 0; i--)
			if ++hash_block[i - 1] != 0
			{
				break;

			}
		c = 0;
		for (i = v; i > 0; i--)
		{
			j = salt_block[i - 1] + hash_block[i - 1] + c;
			c = (i8) (j >> 8);
			salt_block[i - 1] = j & 0xFF;
		}
		c = 0;
		for (i = v; i > 0; i--)
		{
			j = pwd_block[i - 1] + hash_block[i - 1] + c;
			c = (i8) (j >> 8);
			pwd_block[i - 1] = j & 0xFF;
		}
	}
	ret = 0;
exit:
	zeroize(salt_block, sizeof(salt_block));
	zeroize(pwd_block, sizeof(pwd_block));
	zeroize(hash_block, sizeof(hash_block));
	zeroize(hash_output, sizeof(hash_output));
	mbedtls_md_free(&md_ctx);
	return ret;
}

fn pkcs5_parse_pbkdf2_params(const mbedtls_asn1_buf * params, mbedtls_asn1_buf * salt, i32 * iterations, i32 * keylen, mbedtls_md_type_t * md_type) -> i32
{
	i32 ret;
	mbedtls_asn1_buf prf_alg_oid;
	u8 * p = params.p;
	const u8 * end = params.p + params.len;
	if params.tag != (0x20 | 0x10)
	{
		return -0x2f00 + -0x0062;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &salt.len, 0x04)) != 0
	{
		return -0x2f00 + ret;
	}
	salt.p = p;
	p += salt.len;
	if (ret = mbedtls_asn1_get_int(&p, end, iterations)) != 0
	{
		return -0x2f00 + ret;
	}
	if p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_int(&p, end, keylen)) != 0
	{
		if ret != -0x0062
		{
			return -0x2f00 + ret;
		}
	}
	if p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_alg_null(&p, end, &prf_alg_oid)) != 0
	{
		return -0x2f00 + ret;
	}
	if ((((sizeof("\x2a"
				  "\x86\x48"
				  "\x86\xf7\x0d"
				  "\x02\x07") -
			1) != (&prf_alg_oid)->len) ||
			memcmp(("\x2a"
					"\x86\x48"
					"\x86\xf7\x0d"
					"\x02\x07"),
				   (&prf_alg_oid)->p, (&prf_alg_oid)->len) != 0) != 0)
	{
		return -0x2e80;
	}
	*md_type = MBEDTLS_MD_SHA1;
	if p != end
	{
		return -0x2f00 + -0x0066;
	}
	return 0;
}

pub fn mbedtls_pkcs5_pbes2(const mbedtls_asn1_buf * pbe_params, i32 mode, const u8 * pwd, usize pwdlen, const u8 * data, usize datalen, u8 * output) -> i32
{
	i32 ret, iterations = 0, keylen = 0;
	u8 *p, *end;
	mbedtls_asn1_buf kdf_alg_oid, enc_scheme_oid, kdf_alg_params, enc_scheme_params;
	mbedtls_asn1_buf salt;
	mbedtls_md_type_t md_type = MBEDTLS_MD_SHA1;
	u8 key[32], iv[32];
	usize olen = 0;
	const mbedtls_md_info_t * md_info;
	const mbedtls_cipher_info_t * cipher_info;
	mbedtls_md_context_t md_ctx;
	mbedtls_cipher_type_t cipher_alg;
	mbedtls_cipher_context_t cipher_ctx;
	p = pbe_params.p;
	end = p + pbe_params.len;
	if pbe_params.tag != (0x20 | 0x10)
	{
		return -0x2f00 + -0x0062;
	}
	if (ret = mbedtls_asn1_get_alg(&p, end, &kdf_alg_oid, &kdf_alg_params)) != 0
	{
		return -0x2f00 + ret;
	}
	if ((((sizeof("\x2a"
				  "\x86\x48"
				  "\x86\xf7\x0d"
				  "\x01"
				  "\x05"
				  "\x0c") -
			1) != (&kdf_alg_oid)->len) ||
			memcmp(("\x2a"
					"\x86\x48"
					"\x86\xf7\x0d"
					"\x01"
					"\x05"
					"\x0c"),
				   (&kdf_alg_oid)->p, (&kdf_alg_oid)->len) != 0) != 0)
	{
		return -0x2e80;
	}
	if (ret = pkcs5_parse_pbkdf2_params(&kdf_alg_params, &salt, &iterations, &keylen, &md_type)) != 0
	{
		return ret;
	}
	md_info = mbedtls_md_info_from_type(md_type);
	if md_info == NULL
	{
		return -0x2e80;
	}
	if (ret = mbedtls_asn1_get_alg(&p, end, &enc_scheme_oid, &enc_scheme_params)) != 0
	{
		return -0x2f00 + ret;
	}
	if mbedtls_oid_get_cipher_alg(&enc_scheme_oid, &cipher_alg) != 0
	{
		return -0x2e80;
	}
	cipher_info = mbedtls_cipher_info_from_type(cipher_alg);
	if cipher_info == NULL
	{
		return -0x2e80;
	}
	keylen = cipher_info.key_bitlen / 8;
	if enc_scheme_params.tag != 0x04 || enc_scheme_params.len != cipher_info.iv_size
	{
		return -0x2f00;
	}
	mbedtls_md_init(&md_ctx);
	mbedtls_cipher_init(&cipher_ctx);
	memcpy(iv, enc_scheme_params.p, enc_scheme_params.len);
	if (ret = mbedtls_md_setup(&md_ctx, md_info, 1)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_pkcs5_pbkdf2_hmac(&md_ctx, pwd, pwdlen, salt.p, salt.len, iterations, keylen, key)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_setup(&cipher_ctx, cipher_info)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_setkey(&cipher_ctx, key, 8 * keylen, (mbedtls_operation_t) mode)) != 0
	{
		goto exit;
	}
	if (ret = mbedtls_cipher_crypt(&cipher_ctx, iv, enc_scheme_params.len, data, datalen, output, &olen)) != 0
	{
		ret = -0x2e00;
	}
exit:
	mbedtls_md_free(&md_ctx);
	mbedtls_cipher_free(&cipher_ctx);
	return ret;
}

pub fn mbedtls_pkcs5_pbkdf2_hmac(mbedtls_md_context_t * ctx, const u8 * password, usize plen, const u8 * salt, usize slen, u32 iteration_count, u32 key_length, u8 * output) -> i32
{
	i32 ret, j;
	u32 i;
	u8 md1[64];
	u8 work[64];
	u8 md_size = mbedtls_md_get_size(ctx.md_info);
	usize use_len;
	u8 * out_p = output;
	u8 counter[4];
	memset(counter, 0, 4);
	counter[3] = 1;
	if iteration_count > 0xFFFFFFFF
	{
		return -0x2f80;
	}
	while (key_length)
	{
		if (ret = mbedtls_md_hmac_starts(ctx, password, plen)) != 0
		{
			return ret;
		}
		if (ret = mbedtls_md_hmac_update(ctx, salt, slen)) != 0
		{
			return ret;
		}
		if (ret = mbedtls_md_hmac_update(ctx, counter, 4)) != 0
		{
			return ret;
		}
		if (ret = mbedtls_md_hmac_finish(ctx, work)) != 0
		{
			return ret;
		}
		memcpy(md1, work, md_size);
		for (i = 1; i < iteration_count; i++)
		{
			if (ret = mbedtls_md_hmac_starts(ctx, password, plen)) != 0
			{
				return ret;
			}
			if (ret = mbedtls_md_hmac_update(ctx, md1, md_size)) != 0
			{
				return ret;
			}
			if (ret = mbedtls_md_hmac_finish(ctx, md1)) != 0
			{
				return ret;
			}
			for (j = 0; j < md_size; j++)
			{
				work[j] ^= md1[j];
			}
		}
		use_len = (key_length < md_size) ? key_length : md_size;
		memcpy(out_p, work, use_len);
		key_length -= (u32) use_len;
		out_p += use_len;
		for (i = 4; i > 0; i--)
			if ++counter[i - 1] != 0
			{
				break;

			}
	}
	return 0;
}

static const usize plen[6] = {8, 8, 8, 24, 9};
static const u8 password[6][32] =
{
	"password", "password", "password", "passwordPASSWORDpassword", "pass\0word",
};
static const usize slen[6] = {4, 4, 4, 36, 5};
static const u8 salt[6][40] =
{
	"salt", "salt", "salt", "saltSALTsaltSALTsaltSALTsaltSALTsalt", "sa\0lt",
};
static const u32 it_cnt[6] = {1, 2, 4096, 4096, 4096};
static const u32 key_len[6] = {20, 20, 20, 25, 16};
static const u8 result_key[6][32] =
{
	{0x0c, 0x60, 0xc8, 0x0f, 0x96, 0x1f, 0x0e, 0x71, 0xf3, 0xa9, 0xb5, 0x24, 0xaf, 0x60, 0x12, 0x06, 0x2f, 0xe0, 0x37, 0xa6}, {0xea, 0x6c, 0x01, 0x4d, 0xc7, 0x2d, 0x6f, 0x8c, 0xcd, 0x1e, 0xd9, 0x2a, 0xce, 0x1d, 0x41, 0xf0, 0xd8, 0xde, 0x89, 0x57}, {0x4b, 0x00, 0x79, 0x01, 0xb7, 0x65, 0x48, 0x9a, 0xbe, 0xad, 0x49, 0xd9, 0x26, 0xf7, 0x21, 0xd0, 0x65, 0xa4, 0x29, 0xc1}, {0x3d, 0x2e, 0xec, 0x4f, 0xe4, 0x1c, 0x84, 0x9b, 0x80, 0xc8, 0xd8, 0x36, 0x62, 0xc0, 0xe4, 0x4a, 0x8b, 0x29, 0x1a, 0x96, 0x4c, 0xf2, 0xf0, 0x70, 0x38}, {0x56, 0xfa, 0x6a, 0xa7, 0x55, 0x48, 0x09, 0x9d, 0xcc, 0x37, 0xd7, 0xf0, 0x34, 0x25, 0xe0, 0xc3},
};
pub fn mbedtls_pkcs5_self_test(i32 verbose) -> i32
{
	mbedtls_md_context_t sha1_ctx;
	const mbedtls_md_info_t * info_sha1;
	i32 ret, i;
	u8 key[64];
	mbedtls_md_init(&sha1_ctx);
	info_sha1 = mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);
	if info_sha1 == NULL
	{
		ret = 1;
		goto exit;
	}
	if (ret = mbedtls_md_setup(&sha1_ctx, info_sha1, 1)) != 0
	{
		ret = 1;
		goto exit;
	}
	for (i = 0; i < 6; i++)
	{
		if verbose != 0
		{
			printf("  PBKDF2 (SHA1) #%d: ", i);
		}
		ret = mbedtls_pkcs5_pbkdf2_hmac(&sha1_ctx, password[i], plen[i], salt[i], slen[i], it_cnt[i], key_len[i], key);
		if ret != 0 || memcmp(result_key[i], key, key_len[i]) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			ret = 1;
			goto exit;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	printf("\n");
exit:
	mbedtls_md_free(&sha1_ctx);
	return ret;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_pk_load_file(const i8 * path, u8 ** buf, usize * n) -> i32
{
	FILE * f;
	i32 size;
	if (f = fopen(path, "rb")) == NULL
	{
		return -0x3E00;
	}
	fseek(f, 0, SEEK_END);
	if (size = ftell(f)) == -1
	{
		fclose(f);
		return -0x3E00;
	}
	fseek(f, 0, SEEK_SET);
	*n = (usize) size;
	if *n + 1 == 0 || (*buf = mbedtls_calloc(1, *n + 1)) == NULL
	{
		fclose(f);
		return -0x3F80;
	}
	if fread(*buf, 1, *n, f) != *n
	{
		fclose(f);
		mbedtls_free(*buf);
		return -0x3E00;
	}
	fclose(f);
	(*buf)[*n] = '\0';
	if strstr((const i8 *) *buf, "-----BEGIN ") != NULL
	{
		++*n;
	}
	return 0;
}

pub fn mbedtls_pk_parse_keyfile(mbedtls_pk_context * ctx, const i8 * path, const i8 * pwd) -> i32
{
	i32 ret;
	usize n;
	u8 * buf;
	if (ret = mbedtls_pk_load_file(path, &buf, &n)) != 0
	{
		return ret;
	}
	if pwd == NULL
	{
		ret = mbedtls_pk_parse_key(ctx, buf, n, NULL, 0);
	}
	else
	{
		ret = mbedtls_pk_parse_key(ctx, buf, n, (const u8 *) pwd, strlen(pwd));
	}
	zeroize(buf, n);
	mbedtls_free(buf);
	return ret;
}

pub fn mbedtls_pk_parse_public_keyfile(mbedtls_pk_context * ctx, const i8 * path) -> i32
{
	i32 ret;
	usize n;
	u8 * buf;
	if (ret = mbedtls_pk_load_file(path, &buf, &n)) != 0
	{
		return ret;
	}
	ret = mbedtls_pk_parse_public_key(ctx, buf, n);
	zeroize(buf, n);
	mbedtls_free(buf);
	return ret;
}

fn pk_get_ecparams(u8 ** p, const u8 * end, mbedtls_asn1_buf * params) -> i32
{
	i32 ret;
	params.tag = **p;
	if params.tag != 0x06 && params.tag != (0x20 | 0x10)
	{
		return -0x3D00 + -0x0062;
	}
	if (ret = mbedtls_asn1_get_tag(p, end, &params.len, params.tag)) != 0
	{
		return -0x3D00 + ret;
	}
	params.p = *p;
	*p += params.len;
	if *p != end
	{
		return -0x3D00 + -0x0066;
	}
	return 0;
}

fn pk_group_from_specified(const mbedtls_asn1_buf * params, mbedtls_ecp_group * grp) -> i32
{
	i32 ret;
	u8 * p = params.p;
	const u8 * const end = params.p + params.len;
	const u8 *end_field, *end_curve;
	usize len;
	i32 ver;
	if (ret = mbedtls_asn1_get_int(&p, end, &ver)) != 0
	{
		return -0x3D00 + ret;
	}
	if ver < 1 || ver > 3
	{
		return -0x3D00;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		return ret;
	}
	end_field = p + len;
	if (ret = mbedtls_asn1_get_tag(&p, end_field, &len, 0x06)) != 0
	{
		return ret;
	}
	if (len != (sizeof("\x2a"
					   "\x86\x48"
					   "\xce\x3d"
					   "\x01"
					   "\x01") -
				1) ||
			memcmp(p, "\x2a"
				   "\x86\x48"
				   "\xce\x3d"
				   "\x01"
				   "\x01",
				   len) != 0)
	{
		return -0x3980;
	}
	p += len;
	if (ret = mbedtls_asn1_get_mpi(&p, end_field, &grp.P)) != 0
	{
		return -0x3D00 + ret;
	}
	grp.pbits = mbedtls_mpi_bitlen(&grp.P);
	if p != end_field
	{
		return -0x3D00 + -0x0066;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		return ret;
	}
	end_curve = p + len;
	if (ret = mbedtls_asn1_get_tag(&p, end_curve, &len, 0x04)) != 0 || (ret = mbedtls_mpi_read_binary(&grp.A, p, len)) != 0
	{
		return -0x3D00 + ret;
	}
	p += len;
	if (ret = mbedtls_asn1_get_tag(&p, end_curve, &len, 0x04)) != 0 || (ret = mbedtls_mpi_read_binary(&grp.B, p, len)) != 0
	{
		return -0x3D00 + ret;
	}
	p += len;
	if (ret = mbedtls_asn1_get_tag(&p, end_curve, &len, 0x03)) == 0
	{
		p += len;
	}
	if p != end_curve
	{
		return -0x3D00 + -0x0066;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x04)) != 0
	{
		return -0x3D00 + ret;
	}
	if (ret = mbedtls_ecp_point_read_binary(grp, &grp.G, (const u8 *) p, len)) != 0
	{
		if ret != -0x4E80 || (p[0] != 0x02 && p[0] != 0x03) || len != mbedtls_mpi_size(&grp.P) + 1 || mbedtls_mpi_read_binary(&grp.G.X, p + 1, len - 1) != 0 || mbedtls_mpi_lset(&grp.G.Y, p[0] - 2) != 0 || mbedtls_mpi_lset(&grp.G.Z, 1) != 0
		{
			return -0x3D00;
		}
	}
	p += len;
	if (ret = mbedtls_asn1_get_mpi(&p, end, &grp.N)) != 0
	{
		return -0x3D00 + ret;
	}
	grp.nbits = mbedtls_mpi_bitlen(&grp.N);
	return 0;
}

fn pk_group_id_from_group(const mbedtls_ecp_group * grp, mbedtls_ecp_group_id * grp_id) -> i32
{
	i32 ret = 0;
	mbedtls_ecp_group ref;
	const mbedtls_ecp_group_id * id;
	mbedtls_ecp_group_init(&ref);
	for (id = mbedtls_ecp_grp_id_list(); *id != MBEDTLS_ECP_DP_NONE; id++)
	{
		mbedtls_ecp_group_free(&ref);
		do
		{
			if (ret = mbedtls_ecp_group_load(&ref, *id)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if grp.pbits == ref.pbits && grp.nbits == ref.nbits && mbedtls_mpi_cmp_mpi(&grp.P, &ref.P) == 0 && mbedtls_mpi_cmp_mpi(&grp.A, &ref.A) == 0 && mbedtls_mpi_cmp_mpi(&grp.B, &ref.B) == 0 && mbedtls_mpi_cmp_mpi(&grp.N, &ref.N) == 0 && mbedtls_mpi_cmp_mpi(&grp.G.X, &ref.G.X) == 0 && mbedtls_mpi_cmp_mpi(&grp.G.Z, &ref.G.Z) == 0 && mbedtls_mpi_get_bit(&grp.G.Y, 0) == mbedtls_mpi_get_bit(&ref.G.Y, 0)
		{
			break;

		}
	}
cleanup:
	mbedtls_ecp_group_free(&ref);
	*grp_id = *id;
	if ret == 0 && *id == MBEDTLS_ECP_DP_NONE
	{
		ret = -0x4E80;
	}
	return ret;
}

fn pk_group_id_from_specified(const mbedtls_asn1_buf * params, mbedtls_ecp_group_id * grp_id) -> i32
{
	i32 ret;
	mbedtls_ecp_group grp;
	mbedtls_ecp_group_init(&grp);
	if (ret = pk_group_from_specified(params, &grp)) != 0
	{
		goto cleanup;
	}
	ret = pk_group_id_from_group(&grp, grp_id);
cleanup:
	mbedtls_ecp_group_free(&grp);
	return ret;
}

fn pk_use_ecparams(const mbedtls_asn1_buf * params, mbedtls_ecp_group * grp) -> i32
{
	i32 ret;
	mbedtls_ecp_group_id grp_id;
	if params.tag == 0x06
	{
		if mbedtls_oid_get_ec_grp(params, &grp_id) != 0
		{
			return -0x3A00;
		}
	}
	else
	{
		if (ret = pk_group_id_from_specified(params, &grp_id)) != 0
		{
			return ret;
		}
	}
	if grp.id != MBEDTLS_ECP_DP_NONE && grp.id != grp_id
	{
		return -0x3D00;
	}
	if (ret = mbedtls_ecp_group_load(grp, grp_id)) != 0
	{
		return ret;
	}
	return 0;
}

fn pk_get_ecpubkey(u8 ** p, const u8 * end, mbedtls_ecp_keypair * key) -> i32
{
	i32 ret;
	if (ret = mbedtls_ecp_point_read_binary(&key.grp, &key.Q, (const u8 *) *p, end - *p)) == 0
	{
		ret = mbedtls_ecp_check_pubkey(&key.grp, &key.Q);
	}
	*p = (u8 *) end;
	return ret;
}

fn pk_get_rsapubkey(u8 ** p, const u8 * end, mbedtls_rsa_context * rsa) -> i32
{
	i32 ret;
	usize len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x3B00 + ret;
	}
	if *p + len != end
	{
		return -0x3B00 + -0x0066;
	}
	if (ret = mbedtls_asn1_get_mpi(p, end, &rsa.N)) != 0 || (ret = mbedtls_asn1_get_mpi(p, end, &rsa.E)) != 0
	{
		return -0x3B00 + ret;
	}
	if *p != end
	{
		return -0x3B00 + -0x0066;
	}
	if (ret = mbedtls_rsa_check_pubkey(rsa)) != 0
	{
		return -0x3B00;
	}
	rsa.len = mbedtls_mpi_size(&rsa.N);
	return 0;
}

fn pk_get_pk_alg(u8 ** p, const u8 * end, mbedtls_pk_type_t * pk_alg, mbedtls_asn1_buf * params) -> i32
{
	i32 ret;
	mbedtls_asn1_buf alg_oid;
	memset(params, 0, sizeof(mbedtls_asn1_buf));
	if (ret = mbedtls_asn1_get_alg(p, end, &alg_oid, params)) != 0
	{
		return -0x3A80 + ret;
	}
	if mbedtls_oid_get_pk_alg(&alg_oid, pk_alg) != 0
	{
		return -0x3C80;
	}
	if *pk_alg == MBEDTLS_PK_RSA && ((params.tag != 0x05 && params.tag != 0) || params.len != 0)
	{
		return -0x3A80;
	}
	return 0;
}

pub fn mbedtls_pk_parse_subpubkey(u8 ** p, const u8 * end, mbedtls_pk_context * pk) -> i32
{
	i32 ret;
	usize len;
	mbedtls_asn1_buf alg_params;
	mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
	const mbedtls_pk_info_t * pk_info;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x3D00 + ret;
	}
	end = *p + len;
	if (ret = pk_get_pk_alg(p, end, &pk_alg, &alg_params)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_asn1_get_bitstring_null(p, end, &len)) != 0
	{
		return -0x3B00 + ret;
	}
	if *p + len != end
	{
		return -0x3B00 + -0x0066;
	}
	if (pk_info = mbedtls_pk_info_from_type(pk_alg)) == NULL
	{
		return -0x3C80;
	}
	if (ret = mbedtls_pk_setup(pk, pk_info)) != 0
	{
		return ret;
	}
	if pk_alg == MBEDTLS_PK_RSA
	{
		ret = pk_get_rsapubkey(p, end, mbedtls_pk_rsa(*pk));
	}
	else
		if pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY
		{
			ret = pk_use_ecparams(&alg_params, &mbedtls_pk_ec(*pk)->grp);
			if ret == 0
			{
				ret = pk_get_ecpubkey(p, end, mbedtls_pk_ec(*pk));
			}
		}
		else
		{
			ret = -0x3C80;
		}
	if ret == 0 && *p != end
	{
		ret = -0x3B00 - 0x0066;
	}
	if ret != 0
	{
		mbedtls_pk_free(pk);
	}
	return ret;
}

fn pk_parse_key_pkcs1_der(mbedtls_rsa_context * rsa, const u8 * key, usize keylen) -> i32
{
	i32 ret;
	usize len;
	u8 *p, *end;
	p = (u8 *) key;
	end = p + keylen;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x3D00 + ret;
	}
	end = p + len;
	if (ret = mbedtls_asn1_get_int(&p, end, &rsa.ver)) != 0
	{
		return -0x3D00 + ret;
	}
	if rsa.ver != 0
	{
		return -0x3D80;
	}
	if (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.N)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.E)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.D)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.P)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.Q)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.DP)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.DQ)) != 0 || (ret = mbedtls_asn1_get_mpi(&p, end, &rsa.QP)) != 0
	{
		mbedtls_rsa_free(rsa);
		return -0x3D00 + ret;
	}
	rsa.len = mbedtls_mpi_size(&rsa.N);
	if p != end
	{
		mbedtls_rsa_free(rsa);
		return -0x3D00 + -0x0066;
	}
	if (ret = mbedtls_rsa_check_privkey(rsa)) != 0
	{
		mbedtls_rsa_free(rsa);
		return ret;
	}
	return 0;
}

fn pk_parse_key_sec1_der(mbedtls_ecp_keypair * eck, const u8 * key, usize keylen) -> i32
{
	i32 ret;
	i32 version, pubkey_done;
	usize len;
	mbedtls_asn1_buf params;
	u8 * p = (u8 *) key;
	u8 * end = p + keylen;
	u8 * end2;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x3D00 + ret;
	}
	end = p + len;
	if (ret = mbedtls_asn1_get_int(&p, end, &version)) != 0
	{
		return -0x3D00 + ret;
	}
	if version != 1
	{
		return -0x3D80;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x04)) != 0
	{
		return -0x3D00 + ret;
	}
	if (ret = mbedtls_mpi_read_binary(&eck.d, p, len)) != 0
	{
		mbedtls_ecp_keypair_free(eck);
		return -0x3D00 + ret;
	}
	p += len;
	pubkey_done = 0;
	if p != end
	{
		if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 0)) == 0
		{
			if (ret = pk_get_ecparams(&p, p + len, &params)) != 0 || (ret = pk_use_ecparams(&params, &eck.grp)) != 0
			{
				mbedtls_ecp_keypair_free(eck);
				return ret;
			}
		}
		else
			if ret != -0x0062
			{
				mbedtls_ecp_keypair_free(eck);
				return -0x3D00 + ret;
			}
		if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 1)) == 0
		{
			end2 = p + len;
			if (ret = mbedtls_asn1_get_bitstring_null(&p, end2, &len)) != 0
			{
				return -0x3D00 + ret;
			}
			if p + len != end2
			{
				return -0x3D00 + -0x0066;
			}
			if (ret = pk_get_ecpubkey(&p, end2, eck)) == 0
			{
				pubkey_done = 1;
			}
			else
			{
				if ret != -0x4E80
				{
					return -0x3D00;
				}
			}
		}
		else
			if ret != -0x0062
			{
				mbedtls_ecp_keypair_free(eck);
				return -0x3D00 + ret;
			}
	}
	if !pubkey_done && (ret = mbedtls_ecp_mul(&eck.grp, &eck.Q, &eck.d, &eck.grp.G, NULL, NULL)) != 0
	{
		mbedtls_ecp_keypair_free(eck);
		return -0x3D00 + ret;
	}
	if (ret = mbedtls_ecp_check_privkey(&eck.grp, &eck.d)) != 0
	{
		mbedtls_ecp_keypair_free(eck);
		return ret;
	}
	return 0;
}

fn pk_parse_key_pkcs8_unencrypted_der(mbedtls_pk_context * pk, const u8 * key, usize keylen) -> i32
{
	i32 ret, version;
	usize len;
	mbedtls_asn1_buf params;
	u8 * p = (u8 *) key;
	u8 * end = p + keylen;
	mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
	const mbedtls_pk_info_t * pk_info;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x3D00 + ret;
	}
	end = p + len;
	if (ret = mbedtls_asn1_get_int(&p, end, &version)) != 0
	{
		return -0x3D00 + ret;
	}
	if version != 0
	{
		return -0x3D80 + ret;
	}
	if (ret = pk_get_pk_alg(&p, end, &pk_alg, &params)) != 0
	{
		return -0x3D00 + ret;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x04)) != 0
	{
		return -0x3D00 + ret;
	}
	if len < 1
	{
		return -0x3D00 + -0x0060;
	}
	if (pk_info = mbedtls_pk_info_from_type(pk_alg)) == NULL
	{
		return -0x3C80;
	}
	if (ret = mbedtls_pk_setup(pk, pk_info)) != 0
	{
		return ret;
	}
	if pk_alg == MBEDTLS_PK_RSA
	{
		if (ret = pk_parse_key_pkcs1_der(mbedtls_pk_rsa(*pk), p, len)) != 0
		{
			mbedtls_pk_free(pk);
			return ret;
		}
	}
	else
		if pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH
		{
			if (ret = pk_use_ecparams(&params, &mbedtls_pk_ec(*pk)->grp)) != 0 || (ret = pk_parse_key_sec1_der(mbedtls_pk_ec(*pk), p, len)) != 0
			{
				mbedtls_pk_free(pk);
				return ret;
			}
		}
		else
		{
			return -0x3C80;
		}
	return 0;
}

fn pk_parse_key_pkcs8_encrypted_der(mbedtls_pk_context * pk, const u8 * key, usize keylen, const u8 * pwd, usize pwdlen) -> i32
{
	i32 ret, decrypted = 0;
	usize len;
	u8 buf[2048];
	u8 *p, *end;
	mbedtls_asn1_buf pbe_alg_oid, pbe_params;
	mbedtls_cipher_type_t cipher_alg;
	mbedtls_md_type_t md_alg;
	memset(buf, 0, sizeof(buf));
	p = (u8 *) key;
	end = p + keylen;
	if pwdlen == 0
	{
		return -0x3C00;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x3D00 + ret;
	}
	end = p + len;
	if (ret = mbedtls_asn1_get_alg(&p, end, &pbe_alg_oid, &pbe_params)) != 0
	{
		return -0x3D00 + ret;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x04)) != 0
	{
		return -0x3D00 + ret;
	}
	if len > sizeof(buf)
	{
		return -0x3E80;
	}
	if mbedtls_oid_get_pkcs12_pbe_alg(&pbe_alg_oid, &md_alg, &cipher_alg) == 0
	{
		if (ret = mbedtls_pkcs12_pbe(&pbe_params, 0, cipher_alg, md_alg, pwd, pwdlen, p, len, buf)) != 0
		{
			if ret == -0x1E00
			{
				return -0x3B80;
			}
			return ret;
		}
		decrypted = 1;
	}
	else
		if ((((sizeof("\x2a"
					  "\x86\x48"
					  "\x86\xf7\x0d"
					  "\x01"
					  "\x0c"
					  "\x01"
					  "\x01") -
				1) != (&pbe_alg_oid)->len) ||
				memcmp(("\x2a"
						"\x86\x48"
						"\x86\xf7\x0d"
						"\x01"
						"\x0c"
						"\x01"
						"\x01"),
					   (&pbe_alg_oid)->p, (&pbe_alg_oid)->len) != 0) == 0)
		{
			if (ret = mbedtls_pkcs12_pbe_sha1_rc4_128(&pbe_params, 0, pwd, pwdlen, p, len, buf)) != 0
			{
				return ret;
			}
			if *buf != (0x20 | 0x10)
			{
				return -0x3B80;
			}
			decrypted = 1;
		}
		else
			if ((((sizeof("\x2a"
						  "\x86\x48"
						  "\x86\xf7\x0d"
						  "\x01"
						  "\x05"
						  "\x0d") -
					1) != (&pbe_alg_oid)->len) ||
					memcmp(("\x2a"
							"\x86\x48"
							"\x86\xf7\x0d"
							"\x01"
							"\x05"
							"\x0d"),
						   (&pbe_alg_oid)->p, (&pbe_alg_oid)->len) != 0) == 0)
			{
				if (ret = mbedtls_pkcs5_pbes2(&pbe_params, 0, pwd, pwdlen, p, len, buf)) != 0
				{
					if ret == -0x2e00
					{
						return -0x3B80;
					}
					return ret;
				}
				decrypted = 1;
			}
			else
			{
				((void) pwd);
			}
	if decrypted == 0
	{
		return -0x3980;
	}
	return pk_parse_key_pkcs8_unencrypted_der(pk, buf, len);
}

pub fn mbedtls_pk_parse_key(mbedtls_pk_context * pk, const u8 * key, usize keylen, const u8 * pwd, usize pwdlen) -> i32
{
	i32 ret;
	const mbedtls_pk_info_t * pk_info;
	usize len;
	mbedtls_pem_context pem;
	mbedtls_pem_init(&pem);
	if keylen == 0 || key[keylen - 1] != '\0'
	{
		ret = -0x1080;
	}
	else
	{
		ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN RSA PRIVATE KEY-----", "-----END RSA PRIVATE KEY-----", key, pwd, pwdlen, &len);
	}
	if ret == 0
	{
		if (pk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA)) == NULL
		{
			return -0x3C80;
		}
		if (ret = mbedtls_pk_setup(pk, pk_info)) != 0 || (ret = pk_parse_key_pkcs1_der(mbedtls_pk_rsa(*pk), pem.buf, pem.buflen)) != 0
		{
			mbedtls_pk_free(pk);
		}
		mbedtls_pem_free(&pem);
		return ret;
	}
	else
		if ret == -0x1380
		{
			return -0x3B80;
		}
		else
			if ret == -0x1300
			{
				return -0x3C00;
			}
			else
				if ret != -0x1080
				{
					return ret;
				}
	if keylen == 0 || key[keylen - 1] != '\0'
	{
		ret = -0x1080;
	}
	else
	{
		ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN EC PRIVATE KEY-----", "-----END EC PRIVATE KEY-----", key, pwd, pwdlen, &len);
	}
	if ret == 0
	{
		if (pk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY)) == NULL
		{
			return -0x3C80;
		}
		if (ret = mbedtls_pk_setup(pk, pk_info)) != 0 || (ret = pk_parse_key_sec1_der(mbedtls_pk_ec(*pk), pem.buf, pem.buflen)) != 0
		{
			mbedtls_pk_free(pk);
		}
		mbedtls_pem_free(&pem);
		return ret;
	}
	else
		if ret == -0x1380
		{
			return -0x3B80;
		}
		else
			if ret == -0x1300
			{
				return -0x3C00;
			}
			else
				if ret != -0x1080
				{
					return ret;
				}
	if keylen == 0 || key[keylen - 1] != '\0'
	{
		ret = -0x1080;
	}
	else
	{
		ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----", key, NULL, 0, &len);
	}
	if ret == 0
	{
		if (ret = pk_parse_key_pkcs8_unencrypted_der(pk, pem.buf, pem.buflen)) != 0
		{
			mbedtls_pk_free(pk);
		}
		mbedtls_pem_free(&pem);
		return ret;
	}
	else
		if ret != -0x1080
		{
			return ret;
		}
	if keylen == 0 || key[keylen - 1] != '\0'
	{
		ret = -0x1080;
	}
	else
	{
		ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN ENCRYPTED PRIVATE KEY-----", "-----END ENCRYPTED PRIVATE KEY-----", key, NULL, 0, &len);
	}
	if ret == 0
	{
		if (ret = pk_parse_key_pkcs8_encrypted_der(pk, pem.buf, pem.buflen, pwd, pwdlen)) != 0
		{
			mbedtls_pk_free(pk);
		}
		mbedtls_pem_free(&pem);
		return ret;
	}
	else
		if ret != -0x1080
		{
			return ret;
		}
	if (ret = pk_parse_key_pkcs8_encrypted_der(pk, key, keylen, pwd, pwdlen)) == 0
	{
		return 0;
	}
	mbedtls_pk_free(pk);
	if ret == -0x3B80
	{
		return ret;
	}
	if (ret = pk_parse_key_pkcs8_unencrypted_der(pk, key, keylen)) == 0
	{
		return 0;
	}
	mbedtls_pk_free(pk);
	if (pk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA)) == NULL
	{
		return -0x3C80;
	}
	if (ret = mbedtls_pk_setup(pk, pk_info)) != 0 || (ret = pk_parse_key_pkcs1_der(mbedtls_pk_rsa(*pk), key, keylen)) == 0
	{
		return 0;
	}
	mbedtls_pk_free(pk);
	if (pk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY)) == NULL
	{
		return -0x3C80;
	}
	if (ret = mbedtls_pk_setup(pk, pk_info)) != 0 || (ret = pk_parse_key_sec1_der(mbedtls_pk_ec(*pk), key, keylen)) == 0
	{
		return 0;
	}
	mbedtls_pk_free(pk);
	return -0x3D00;
}

pub fn mbedtls_pk_parse_public_key(mbedtls_pk_context * ctx, const u8 * key, usize keylen) -> i32
{
	i32 ret;
	u8 * p;
	usize len;
	mbedtls_pem_context pem;
	mbedtls_pem_init(&pem);
	if keylen == 0 || key[keylen - 1] != '\0'
	{
		ret = -0x1080;
	}
	else
	{
		ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN PUBLIC KEY-----", "-----END PUBLIC KEY-----", key, NULL, 0, &len);
	}
	if ret == 0
	{
		key = pem.buf;
		keylen = pem.buflen;
	}
	else
		if ret != -0x1080
		{
			mbedtls_pem_free(&pem);
			return ret;
		}
	p = (u8 *) key;
	ret = mbedtls_pk_parse_subpubkey(&p, p + keylen, ctx);
	mbedtls_pem_free(&pem);
	return ret;
}

fn pk_write_rsa_pubkey(u8 ** p, u8 * start, mbedtls_rsa_context * rsa) -> i32
{
	i32 ret;
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_mpi(p, start, &rsa.E)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_mpi(p, start, &rsa.N)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

fn pk_write_ec_pubkey(u8 ** p, u8 * start, mbedtls_ecp_keypair * ec) -> i32
{
	i32 ret;
	usize len = 0;
	u8 buf[(2 * ((521 + 7) / 8) + 1)];
	if (ret = mbedtls_ecp_point_write_binary(&ec.grp, &ec.Q, 0, &len, buf, sizeof(buf))) != 0
	{
		return ret;
	}
	if *p < start || (usize)(*p - start) < len
	{
		return -0x006C;
	}
	*p -= len;
	memcpy(*p, buf, len);
	return (int) len;
}

fn pk_write_ec_param(u8 ** p, u8 * start, mbedtls_ecp_keypair * ec) -> i32
{
	i32 ret;
	usize len = 0;
	const i8 * oid;
	usize oid_len;
	if (ret = mbedtls_oid_get_oid_by_ec_grp(ec.grp.id, &oid, &oid_len)) != 0
	{
		return ret;
	}
	do
	{
		if (ret = mbedtls_asn1_write_oid(p, start, oid, oid_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_pk_write_pubkey(u8 ** p, u8 * start, const mbedtls_pk_context * key) -> i32
{
	i32 ret;
	usize len = 0;
	if mbedtls_pk_get_type(key) == MBEDTLS_PK_RSA
		do
		{
			if (ret = pk_write_rsa_pubkey(p, start, mbedtls_pk_rsa(*key))) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	else
		if mbedtls_pk_get_type(key) == MBEDTLS_PK_ECKEY
			do
			{
				if (ret = pk_write_ec_pubkey(p, start, mbedtls_pk_ec(*key))) < 0
				{
					return ret;
				}
				else
				{
					len += ret;
				}
			}
			while (0);
		else
		{
			return -0x3980;
		}
	return (int) len;
}

pub fn mbedtls_pk_write_pubkey_der(mbedtls_pk_context * key, u8 * buf, usize size) -> i32
{
	i32 ret;
	u8 * c;
	usize len = 0, par_len = 0, oid_len;
	const i8 * oid;
	c = buf + size;
	do
	{
		if (ret = mbedtls_pk_write_pubkey(&c, buf, key)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	if c - buf < 1
	{
		return -0x006C;
	}
	*--c = 0;
	len += 1;
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, buf, 0x03)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	if (ret = mbedtls_oid_get_oid_by_pk_alg(mbedtls_pk_get_type(key), &oid, &oid_len)) != 0
	{
		return ret;
	}
	if mbedtls_pk_get_type(key) == MBEDTLS_PK_ECKEY
	{
		do
		{
			if (ret = pk_write_ec_param(&c, buf, mbedtls_pk_ec(*key))) < 0
			{
				return ret;
			}
			else
			{
				par_len += ret;
			}
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_asn1_write_algorithm_identifier(&c, buf, oid, oid_len, par_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_pk_write_key_der(mbedtls_pk_context * key, u8 * buf, usize size) -> i32
{
	i32 ret;
	u8 * c = buf + size;
	usize len = 0;
	if mbedtls_pk_get_type(key) == MBEDTLS_PK_RSA
	{
		mbedtls_rsa_context * rsa = mbedtls_pk_rsa(*key);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.QP)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.DQ)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.DP)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.Q)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.P)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.D)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.E)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_mpi(&c, buf, &rsa.N)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_int(&c, buf, 0)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_tag(&c, buf, 0x20 | 0x10)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	else
		if mbedtls_pk_get_type(key) == MBEDTLS_PK_ECKEY
		{
			mbedtls_ecp_keypair * ec = mbedtls_pk_ec(*key);
			usize pub_len = 0, par_len = 0;
			do
			{
				if (ret = pk_write_ec_pubkey(&c, buf, ec)) < 0
				{
					return ret;
				}
				else
				{
					pub_len += ret;
				}
			}
			while (0);
			if c - buf < 1
			{
				return -0x006C;
			}
			*--c = 0;
			pub_len += 1;
			do
			{
				if (ret = mbedtls_asn1_write_len(&c, buf, pub_len)) < 0
				{
					return ret;
				}
				else
				{
					pub_len += ret;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_asn1_write_tag(&c, buf, 0x03)) < 0
				{
					return ret;
				}
				else
				{
					pub_len += ret;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_asn1_write_len(&c, buf, pub_len)) < 0
				{
					return ret;
				}
				else
				{
					pub_len += ret;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_asn1_write_tag(&c, buf, 0x80 | 0x20 | 1)) < 0
				{
					return ret;
				}
				else
				{
					pub_len += ret;
				}
			}
			while (0);
			len += pub_len;
			do
			{
				if (ret = pk_write_ec_param(&c, buf, ec)) < 0
				{
					return ret;
				}
				else
				{
					par_len += ret;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_asn1_write_len(&c, buf, par_len)) < 0
				{
					return ret;
				}
				else
				{
					par_len += ret;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_asn1_write_tag(&c, buf, 0x80 | 0x20 | 0)) < 0
				{
					return ret;
				}
				else
				{
					par_len += ret;
				}
			}
			while (0);
			len += par_len;
			do
			{
				if (ret = mbedtls_asn1_write_mpi(&c, buf, &ec.d)) < 0
				{
					return ret;
				}
				else
				{
					len += ret;
				}
			}
			while (0);
			*c = 0x04;
			do
			{
				if (ret = mbedtls_asn1_write_int(&c, buf, 1)) < 0
				{
					return ret;
				}
				else
				{
					len += ret;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
				{
					return ret;
				}
				else
				{
					len += ret;
				}
			}
			while (0);
			do
			{
				if (ret = mbedtls_asn1_write_tag(&c, buf, 0x20 | 0x10)) < 0
				{
					return ret;
				}
				else
				{
					len += ret;
				}
			}
			while (0);
		}
		else
		{
			return -0x3980;
		}
	return (int) len;
}

pub fn mbedtls_pk_write_pubkey_pem(mbedtls_pk_context * key, u8 * buf, usize size) -> i32
{
	i32 ret;
	u8 output_buf[38 + 2 * 1024 > 30 + 2 * ((521 + 7) / 8) ? 38 + 2 * 1024 : 30 + 2 * ((521 + 7) / 8)];
	usize olen = 0;
	if (ret = mbedtls_pk_write_pubkey_der(key, output_buf, sizeof(output_buf))) < 0
	{
		return ret;
	}
	if (ret = mbedtls_pem_write_buffer("-----BEGIN PUBLIC KEY-----\n", "-----END PUBLIC KEY-----\n", output_buf + sizeof(output_buf) - ret, ret, buf, size, &olen)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_pk_write_key_pem(mbedtls_pk_context * key, u8 * buf, usize size) -> i32
{
	i32 ret;
	u8 output_buf[47 + 3 * 1024 + 5 * 1024 / 2 + 1024 % 2 > 29 + 3 * ((521 + 7) / 8) ? 47 + 3 * 1024 + 5 * 1024 / 2 + 1024 % 2 : 29 + 3 * ((521 + 7) / 8)];
	const i8 *begin, *end;
	usize olen = 0;
	if (ret = mbedtls_pk_write_key_der(key, output_buf, sizeof(output_buf))) < 0
	{
		return ret;
	}
	if mbedtls_pk_get_type(key) == MBEDTLS_PK_RSA
	{
		begin = "-----BEGIN RSA PRIVATE KEY-----\n";
		end = "-----END RSA PRIVATE KEY-----\n";
	}
	else
		if mbedtls_pk_get_type(key) == MBEDTLS_PK_ECKEY
		{
			begin = "-----BEGIN EC PRIVATE KEY-----\n";
			end = "-----END EC PRIVATE KEY-----\n";
		}
		else
		{
			return -0x3980;
		}
	if (ret = mbedtls_pem_write_buffer(begin, end, output_buf + sizeof(output_buf) - ret, ret, buf, size, &olen)) != 0
	{
		return ret;
	}
	return 0;
}

void * (*mbedtls_calloc)(usize, usize) = calloc;
void (*mbedtls_free)(void *) = free;
pub fn mbedtls_platform_set_calloc_free(void * (*calloc_func)(usize, usize), void (*free_func)(void *)) -> i32
{
	mbedtls_calloc = calloc_func;
	mbedtls_free = free_func;
	return 0;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_ripemd160_init(mbedtls_ripemd160_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_ripemd160_context));
}

pub fn mbedtls_ripemd160_free(mbedtls_ripemd160_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_ripemd160_context));
}

pub fn mbedtls_ripemd160_clone(mbedtls_ripemd160_context * dst, const mbedtls_ripemd160_context * src)
{
	*dst = *src;
}

pub fn mbedtls_ripemd160_starts(mbedtls_ripemd160_context * ctx)
{
	ctx.total[0] = 0;
	ctx.total[1] = 0;
	ctx.state[0] = 0x67452301;
	ctx.state[1] = 0xEFCDAB89;
	ctx.state[2] = 0x98BADCFE;
	ctx.state[3] = 0x10325476;
	ctx.state[4] = 0xC3D2E1F0;
}

pub fn mbedtls_ripemd160_process(mbedtls_ripemd160_context * ctx, const u8 data[64])
{
	u32 A, B, C, D, E, Ap, Bp, Cp, Dp, Ep, X[16];
	GET_UINT32_LE(X[0], data, 0);
	GET_UINT32_LE(X[1], data, 4);
	GET_UINT32_LE(X[2], data, 8);
	GET_UINT32_LE(X[3], data, 12);
	GET_UINT32_LE(X[4], data, 16);
	GET_UINT32_LE(X[5], data, 20);
	GET_UINT32_LE(X[6], data, 24);
	GET_UINT32_LE(X[7], data, 28);
	GET_UINT32_LE(X[8], data, 32);
	GET_UINT32_LE(X[9], data, 36);
	GET_UINT32_LE(X[10], data, 40);
	GET_UINT32_LE(X[11], data, 44);
	GET_UINT32_LE(X[12], data, 48);
	GET_UINT32_LE(X[13], data, 52);
	GET_UINT32_LE(X[14], data, 56);
	GET_UINT32_LE(X[15], data, 60);
	A = Ap = ctx.state[0];
	B = Bp = ctx.state[1];
	C = Cp = ctx.state[2];
	D = Dp = ctx.state[3];
	E = Ep = ctx.state[4];
	A += (B ^ C ^ D) + X[0] + 0x00000000;
	A = ((A << 11) | (A >> (32 - 11))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += (Bp ^ (Cp | ~Dp)) + X[5] + 0x50A28BE6;
	Ap = ((Ap << 8) | (Ap >> (32 - 8))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += (A ^ B ^ C) + X[1] + 0x00000000;
	E = ((E << 14) | (E >> (32 - 14))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += (Ap ^ (Bp | ~Cp)) + X[14] + 0x50A28BE6;
	Ep = ((Ep << 9) | (Ep >> (32 - 9))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += (E ^ A ^ B) + X[2] + 0x00000000;
	D = ((D << 15) | (D >> (32 - 15))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += (Ep ^ (Ap | ~Bp)) + X[7] + 0x50A28BE6;
	Dp = ((Dp << 9) | (Dp >> (32 - 9))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += (D ^ E ^ A) + X[3] + 0x00000000;
	C = ((C << 12) | (C >> (32 - 12))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += (Dp ^ (Ep | ~Ap)) + X[0] + 0x50A28BE6;
	Cp = ((Cp << 11) | (Cp >> (32 - 11))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += (C ^ D ^ E) + X[4] + 0x00000000;
	B = ((B << 5) | (B >> (32 - 5))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += (Cp ^ (Dp | ~Ep)) + X[9] + 0x50A28BE6;
	Bp = ((Bp << 13) | (Bp >> (32 - 13))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += (B ^ C ^ D) + X[5] + 0x00000000;
	A = ((A << 8) | (A >> (32 - 8))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += (Bp ^ (Cp | ~Dp)) + X[2] + 0x50A28BE6;
	Ap = ((Ap << 15) | (Ap >> (32 - 15))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += (A ^ B ^ C) + X[6] + 0x00000000;
	E = ((E << 7) | (E >> (32 - 7))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += (Ap ^ (Bp | ~Cp)) + X[11] + 0x50A28BE6;
	Ep = ((Ep << 15) | (Ep >> (32 - 15))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += (E ^ A ^ B) + X[7] + 0x00000000;
	D = ((D << 9) | (D >> (32 - 9))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += (Ep ^ (Ap | ~Bp)) + X[4] + 0x50A28BE6;
	Dp = ((Dp << 5) | (Dp >> (32 - 5))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += (D ^ E ^ A) + X[8] + 0x00000000;
	C = ((C << 11) | (C >> (32 - 11))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += (Dp ^ (Ep | ~Ap)) + X[13] + 0x50A28BE6;
	Cp = ((Cp << 7) | (Cp >> (32 - 7))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += (C ^ D ^ E) + X[9] + 0x00000000;
	B = ((B << 13) | (B >> (32 - 13))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += (Cp ^ (Dp | ~Ep)) + X[6] + 0x50A28BE6;
	Bp = ((Bp << 7) | (Bp >> (32 - 7))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += (B ^ C ^ D) + X[10] + 0x00000000;
	A = ((A << 14) | (A >> (32 - 14))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += (Bp ^ (Cp | ~Dp)) + X[15] + 0x50A28BE6;
	Ap = ((Ap << 8) | (Ap >> (32 - 8))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += (A ^ B ^ C) + X[11] + 0x00000000;
	E = ((E << 15) | (E >> (32 - 15))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += (Ap ^ (Bp | ~Cp)) + X[8] + 0x50A28BE6;
	Ep = ((Ep << 11) | (Ep >> (32 - 11))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += (E ^ A ^ B) + X[12] + 0x00000000;
	D = ((D << 6) | (D >> (32 - 6))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += (Ep ^ (Ap | ~Bp)) + X[1] + 0x50A28BE6;
	Dp = ((Dp << 14) | (Dp >> (32 - 14))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += (D ^ E ^ A) + X[13] + 0x00000000;
	C = ((C << 7) | (C >> (32 - 7))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += (Dp ^ (Ep | ~Ap)) + X[10] + 0x50A28BE6;
	Cp = ((Cp << 14) | (Cp >> (32 - 14))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += (C ^ D ^ E) + X[14] + 0x00000000;
	B = ((B << 9) | (B >> (32 - 9))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += (Cp ^ (Dp | ~Ep)) + X[3] + 0x50A28BE6;
	Bp = ((Bp << 12) | (Bp >> (32 - 12))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += (B ^ C ^ D) + X[15] + 0x00000000;
	A = ((A << 8) | (A >> (32 - 8))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += (Bp ^ (Cp | ~Dp)) + X[12] + 0x50A28BE6;
	Ap = ((Ap << 6) | (Ap >> (32 - 6))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A & B) | (~A & C)) + X[7] + 0x5A827999;
	E = ((E << 7) | (E >> (32 - 7))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap & Cp) | (Bp & ~Cp)) + X[6] + 0x5C4DD124;
	Ep = ((Ep << 9) | (Ep >> (32 - 9))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E & A) | (~E & B)) + X[4] + 0x5A827999;
	D = ((D << 6) | (D >> (32 - 6))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep & Bp) | (Ap & ~Bp)) + X[11] + 0x5C4DD124;
	Dp = ((Dp << 13) | (Dp >> (32 - 13))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D & E) | (~D & A)) + X[13] + 0x5A827999;
	C = ((C << 8) | (C >> (32 - 8))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp & Ap) | (Ep & ~Ap)) + X[3] + 0x5C4DD124;
	Cp = ((Cp << 15) | (Cp >> (32 - 15))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C & D) | (~C & E)) + X[1] + 0x5A827999;
	B = ((B << 13) | (B >> (32 - 13))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp & Ep) | (Dp & ~Ep)) + X[7] + 0x5C4DD124;
	Bp = ((Bp << 7) | (Bp >> (32 - 7))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B & C) | (~B & D)) + X[10] + 0x5A827999;
	A = ((A << 11) | (A >> (32 - 11))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp & Dp) | (Cp & ~Dp)) + X[0] + 0x5C4DD124;
	Ap = ((Ap << 12) | (Ap >> (32 - 12))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A & B) | (~A & C)) + X[6] + 0x5A827999;
	E = ((E << 9) | (E >> (32 - 9))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap & Cp) | (Bp & ~Cp)) + X[13] + 0x5C4DD124;
	Ep = ((Ep << 8) | (Ep >> (32 - 8))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E & A) | (~E & B)) + X[15] + 0x5A827999;
	D = ((D << 7) | (D >> (32 - 7))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep & Bp) | (Ap & ~Bp)) + X[5] + 0x5C4DD124;
	Dp = ((Dp << 9) | (Dp >> (32 - 9))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D & E) | (~D & A)) + X[3] + 0x5A827999;
	C = ((C << 15) | (C >> (32 - 15))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp & Ap) | (Ep & ~Ap)) + X[10] + 0x5C4DD124;
	Cp = ((Cp << 11) | (Cp >> (32 - 11))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C & D) | (~C & E)) + X[12] + 0x5A827999;
	B = ((B << 7) | (B >> (32 - 7))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp & Ep) | (Dp & ~Ep)) + X[14] + 0x5C4DD124;
	Bp = ((Bp << 7) | (Bp >> (32 - 7))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B & C) | (~B & D)) + X[0] + 0x5A827999;
	A = ((A << 12) | (A >> (32 - 12))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp & Dp) | (Cp & ~Dp)) + X[15] + 0x5C4DD124;
	Ap = ((Ap << 7) | (Ap >> (32 - 7))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A & B) | (~A & C)) + X[9] + 0x5A827999;
	E = ((E << 15) | (E >> (32 - 15))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap & Cp) | (Bp & ~Cp)) + X[8] + 0x5C4DD124;
	Ep = ((Ep << 12) | (Ep >> (32 - 12))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E & A) | (~E & B)) + X[5] + 0x5A827999;
	D = ((D << 9) | (D >> (32 - 9))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep & Bp) | (Ap & ~Bp)) + X[12] + 0x5C4DD124;
	Dp = ((Dp << 7) | (Dp >> (32 - 7))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D & E) | (~D & A)) + X[2] + 0x5A827999;
	C = ((C << 11) | (C >> (32 - 11))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp & Ap) | (Ep & ~Ap)) + X[4] + 0x5C4DD124;
	Cp = ((Cp << 6) | (Cp >> (32 - 6))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C & D) | (~C & E)) + X[14] + 0x5A827999;
	B = ((B << 7) | (B >> (32 - 7))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp & Ep) | (Dp & ~Ep)) + X[9] + 0x5C4DD124;
	Bp = ((Bp << 15) | (Bp >> (32 - 15))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B & C) | (~B & D)) + X[11] + 0x5A827999;
	A = ((A << 13) | (A >> (32 - 13))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp & Dp) | (Cp & ~Dp)) + X[1] + 0x5C4DD124;
	Ap = ((Ap << 13) | (Ap >> (32 - 13))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A & B) | (~A & C)) + X[8] + 0x5A827999;
	E = ((E << 12) | (E >> (32 - 12))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap & Cp) | (Bp & ~Cp)) + X[2] + 0x5C4DD124;
	Ep = ((Ep << 11) | (Ep >> (32 - 11))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E | ~A) ^ B) + X[3] + 0x6ED9EBA1;
	D = ((D << 11) | (D >> (32 - 11))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep | ~Ap) ^ Bp) + X[15] + 0x6D703EF3;
	Dp = ((Dp << 9) | (Dp >> (32 - 9))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D | ~E) ^ A) + X[10] + 0x6ED9EBA1;
	C = ((C << 13) | (C >> (32 - 13))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp | ~Ep) ^ Ap) + X[5] + 0x6D703EF3;
	Cp = ((Cp << 7) | (Cp >> (32 - 7))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C | ~D) ^ E) + X[14] + 0x6ED9EBA1;
	B = ((B << 6) | (B >> (32 - 6))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp | ~Dp) ^ Ep) + X[1] + 0x6D703EF3;
	Bp = ((Bp << 15) | (Bp >> (32 - 15))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B | ~C) ^ D) + X[4] + 0x6ED9EBA1;
	A = ((A << 7) | (A >> (32 - 7))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp | ~Cp) ^ Dp) + X[3] + 0x6D703EF3;
	Ap = ((Ap << 11) | (Ap >> (32 - 11))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A | ~B) ^ C) + X[9] + 0x6ED9EBA1;
	E = ((E << 14) | (E >> (32 - 14))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap | ~Bp) ^ Cp) + X[7] + 0x6D703EF3;
	Ep = ((Ep << 8) | (Ep >> (32 - 8))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E | ~A) ^ B) + X[15] + 0x6ED9EBA1;
	D = ((D << 9) | (D >> (32 - 9))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep | ~Ap) ^ Bp) + X[14] + 0x6D703EF3;
	Dp = ((Dp << 6) | (Dp >> (32 - 6))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D | ~E) ^ A) + X[8] + 0x6ED9EBA1;
	C = ((C << 13) | (C >> (32 - 13))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp | ~Ep) ^ Ap) + X[6] + 0x6D703EF3;
	Cp = ((Cp << 6) | (Cp >> (32 - 6))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C | ~D) ^ E) + X[1] + 0x6ED9EBA1;
	B = ((B << 15) | (B >> (32 - 15))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp | ~Dp) ^ Ep) + X[9] + 0x6D703EF3;
	Bp = ((Bp << 14) | (Bp >> (32 - 14))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B | ~C) ^ D) + X[2] + 0x6ED9EBA1;
	A = ((A << 14) | (A >> (32 - 14))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp | ~Cp) ^ Dp) + X[11] + 0x6D703EF3;
	Ap = ((Ap << 12) | (Ap >> (32 - 12))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A | ~B) ^ C) + X[7] + 0x6ED9EBA1;
	E = ((E << 8) | (E >> (32 - 8))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap | ~Bp) ^ Cp) + X[8] + 0x6D703EF3;
	Ep = ((Ep << 13) | (Ep >> (32 - 13))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E | ~A) ^ B) + X[0] + 0x6ED9EBA1;
	D = ((D << 13) | (D >> (32 - 13))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep | ~Ap) ^ Bp) + X[12] + 0x6D703EF3;
	Dp = ((Dp << 5) | (Dp >> (32 - 5))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D | ~E) ^ A) + X[6] + 0x6ED9EBA1;
	C = ((C << 6) | (C >> (32 - 6))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp | ~Ep) ^ Ap) + X[2] + 0x6D703EF3;
	Cp = ((Cp << 14) | (Cp >> (32 - 14))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C | ~D) ^ E) + X[13] + 0x6ED9EBA1;
	B = ((B << 5) | (B >> (32 - 5))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp | ~Dp) ^ Ep) + X[10] + 0x6D703EF3;
	Bp = ((Bp << 13) | (Bp >> (32 - 13))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B | ~C) ^ D) + X[11] + 0x6ED9EBA1;
	A = ((A << 12) | (A >> (32 - 12))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp | ~Cp) ^ Dp) + X[0] + 0x6D703EF3;
	Ap = ((Ap << 13) | (Ap >> (32 - 13))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A | ~B) ^ C) + X[5] + 0x6ED9EBA1;
	E = ((E << 7) | (E >> (32 - 7))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap | ~Bp) ^ Cp) + X[4] + 0x6D703EF3;
	Ep = ((Ep << 7) | (Ep >> (32 - 7))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E | ~A) ^ B) + X[12] + 0x6ED9EBA1;
	D = ((D << 5) | (D >> (32 - 5))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep | ~Ap) ^ Bp) + X[13] + 0x6D703EF3;
	Dp = ((Dp << 5) | (Dp >> (32 - 5))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D & A) | (E & ~A)) + X[1] + 0x8F1BBCDC;
	C = ((C << 11) | (C >> (32 - 11))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp & Ep) | (~Dp & Ap)) + X[8] + 0x7A6D76E9;
	Cp = ((Cp << 15) | (Cp >> (32 - 15))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C & E) | (D & ~E)) + X[9] + 0x8F1BBCDC;
	B = ((B << 12) | (B >> (32 - 12))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp & Dp) | (~Cp & Ep)) + X[6] + 0x7A6D76E9;
	Bp = ((Bp << 5) | (Bp >> (32 - 5))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B & D) | (C & ~D)) + X[11] + 0x8F1BBCDC;
	A = ((A << 14) | (A >> (32 - 14))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp & Cp) | (~Bp & Dp)) + X[4] + 0x7A6D76E9;
	Ap = ((Ap << 8) | (Ap >> (32 - 8))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A & C) | (B & ~C)) + X[10] + 0x8F1BBCDC;
	E = ((E << 15) | (E >> (32 - 15))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap & Bp) | (~Ap & Cp)) + X[1] + 0x7A6D76E9;
	Ep = ((Ep << 11) | (Ep >> (32 - 11))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E & B) | (A & ~B)) + X[0] + 0x8F1BBCDC;
	D = ((D << 14) | (D >> (32 - 14))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep & Ap) | (~Ep & Bp)) + X[3] + 0x7A6D76E9;
	Dp = ((Dp << 14) | (Dp >> (32 - 14))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D & A) | (E & ~A)) + X[8] + 0x8F1BBCDC;
	C = ((C << 15) | (C >> (32 - 15))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp & Ep) | (~Dp & Ap)) + X[11] + 0x7A6D76E9;
	Cp = ((Cp << 14) | (Cp >> (32 - 14))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C & E) | (D & ~E)) + X[12] + 0x8F1BBCDC;
	B = ((B << 9) | (B >> (32 - 9))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp & Dp) | (~Cp & Ep)) + X[15] + 0x7A6D76E9;
	Bp = ((Bp << 6) | (Bp >> (32 - 6))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B & D) | (C & ~D)) + X[4] + 0x8F1BBCDC;
	A = ((A << 8) | (A >> (32 - 8))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp & Cp) | (~Bp & Dp)) + X[0] + 0x7A6D76E9;
	Ap = ((Ap << 14) | (Ap >> (32 - 14))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A & C) | (B & ~C)) + X[13] + 0x8F1BBCDC;
	E = ((E << 9) | (E >> (32 - 9))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap & Bp) | (~Ap & Cp)) + X[5] + 0x7A6D76E9;
	Ep = ((Ep << 6) | (Ep >> (32 - 6))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E & B) | (A & ~B)) + X[3] + 0x8F1BBCDC;
	D = ((D << 14) | (D >> (32 - 14))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep & Ap) | (~Ep & Bp)) + X[12] + 0x7A6D76E9;
	Dp = ((Dp << 9) | (Dp >> (32 - 9))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D & A) | (E & ~A)) + X[7] + 0x8F1BBCDC;
	C = ((C << 5) | (C >> (32 - 5))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp & Ep) | (~Dp & Ap)) + X[2] + 0x7A6D76E9;
	Cp = ((Cp << 12) | (Cp >> (32 - 12))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += ((C & E) | (D & ~E)) + X[15] + 0x8F1BBCDC;
	B = ((B << 6) | (B >> (32 - 6))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += ((Cp & Dp) | (~Cp & Ep)) + X[13] + 0x7A6D76E9;
	Bp = ((Bp << 9) | (Bp >> (32 - 9))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += ((B & D) | (C & ~D)) + X[14] + 0x8F1BBCDC;
	A = ((A << 8) | (A >> (32 - 8))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += ((Bp & Cp) | (~Bp & Dp)) + X[9] + 0x7A6D76E9;
	Ap = ((Ap << 12) | (Ap >> (32 - 12))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += ((A & C) | (B & ~C)) + X[5] + 0x8F1BBCDC;
	E = ((E << 6) | (E >> (32 - 6))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += ((Ap & Bp) | (~Ap & Cp)) + X[7] + 0x7A6D76E9;
	Ep = ((Ep << 5) | (Ep >> (32 - 5))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += ((E & B) | (A & ~B)) + X[6] + 0x8F1BBCDC;
	D = ((D << 5) | (D >> (32 - 5))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += ((Ep & Ap) | (~Ep & Bp)) + X[10] + 0x7A6D76E9;
	Dp = ((Dp << 15) | (Dp >> (32 - 15))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += ((D & A) | (E & ~A)) + X[2] + 0x8F1BBCDC;
	C = ((C << 12) | (C >> (32 - 12))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += ((Dp & Ep) | (~Dp & Ap)) + X[14] + 0x7A6D76E9;
	Cp = ((Cp << 8) | (Cp >> (32 - 8))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += (C ^ (D | ~E)) + X[4] + 0xA953FD4E;
	B = ((B << 9) | (B >> (32 - 9))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += (Cp ^ Dp ^ Ep) + X[12] + 0x00000000;
	Bp = ((Bp << 8) | (Bp >> (32 - 8))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += (B ^ (C | ~D)) + X[0] + 0xA953FD4E;
	A = ((A << 15) | (A >> (32 - 15))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += (Bp ^ Cp ^ Dp) + X[15] + 0x00000000;
	Ap = ((Ap << 5) | (Ap >> (32 - 5))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += (A ^ (B | ~C)) + X[5] + 0xA953FD4E;
	E = ((E << 5) | (E >> (32 - 5))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += (Ap ^ Bp ^ Cp) + X[10] + 0x00000000;
	Ep = ((Ep << 12) | (Ep >> (32 - 12))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += (E ^ (A | ~B)) + X[9] + 0xA953FD4E;
	D = ((D << 11) | (D >> (32 - 11))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += (Ep ^ Ap ^ Bp) + X[4] + 0x00000000;
	Dp = ((Dp << 9) | (Dp >> (32 - 9))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += (D ^ (E | ~A)) + X[7] + 0xA953FD4E;
	C = ((C << 6) | (C >> (32 - 6))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += (Dp ^ Ep ^ Ap) + X[1] + 0x00000000;
	Cp = ((Cp << 12) | (Cp >> (32 - 12))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += (C ^ (D | ~E)) + X[12] + 0xA953FD4E;
	B = ((B << 8) | (B >> (32 - 8))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += (Cp ^ Dp ^ Ep) + X[5] + 0x00000000;
	Bp = ((Bp << 5) | (Bp >> (32 - 5))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += (B ^ (C | ~D)) + X[2] + 0xA953FD4E;
	A = ((A << 13) | (A >> (32 - 13))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += (Bp ^ Cp ^ Dp) + X[8] + 0x00000000;
	Ap = ((Ap << 14) | (Ap >> (32 - 14))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += (A ^ (B | ~C)) + X[10] + 0xA953FD4E;
	E = ((E << 12) | (E >> (32 - 12))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += (Ap ^ Bp ^ Cp) + X[7] + 0x00000000;
	Ep = ((Ep << 6) | (Ep >> (32 - 6))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += (E ^ (A | ~B)) + X[14] + 0xA953FD4E;
	D = ((D << 5) | (D >> (32 - 5))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += (Ep ^ Ap ^ Bp) + X[6] + 0x00000000;
	Dp = ((Dp << 8) | (Dp >> (32 - 8))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += (D ^ (E | ~A)) + X[1] + 0xA953FD4E;
	C = ((C << 12) | (C >> (32 - 12))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += (Dp ^ Ep ^ Ap) + X[2] + 0x00000000;
	Cp = ((Cp << 13) | (Cp >> (32 - 13))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += (C ^ (D | ~E)) + X[3] + 0xA953FD4E;
	B = ((B << 13) | (B >> (32 - 13))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += (Cp ^ Dp ^ Ep) + X[13] + 0x00000000;
	Bp = ((Bp << 6) | (Bp >> (32 - 6))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	A += (B ^ (C | ~D)) + X[8] + 0xA953FD4E;
	A = ((A << 14) | (A >> (32 - 14))) + E;
	C = ((C << 10) | (C >> (32 - 10)));
	;
	Ap += (Bp ^ Cp ^ Dp) + X[14] + 0x00000000;
	Ap = ((Ap << 5) | (Ap >> (32 - 5))) + Ep;
	Cp = ((Cp << 10) | (Cp >> (32 - 10)));
	;
	;
	E += (A ^ (B | ~C)) + X[11] + 0xA953FD4E;
	E = ((E << 11) | (E >> (32 - 11))) + D;
	B = ((B << 10) | (B >> (32 - 10)));
	;
	Ep += (Ap ^ Bp ^ Cp) + X[0] + 0x00000000;
	Ep = ((Ep << 15) | (Ep >> (32 - 15))) + Dp;
	Bp = ((Bp << 10) | (Bp >> (32 - 10)));
	;
	;
	D += (E ^ (A | ~B)) + X[6] + 0xA953FD4E;
	D = ((D << 8) | (D >> (32 - 8))) + C;
	A = ((A << 10) | (A >> (32 - 10)));
	;
	Dp += (Ep ^ Ap ^ Bp) + X[3] + 0x00000000;
	Dp = ((Dp << 13) | (Dp >> (32 - 13))) + Cp;
	Ap = ((Ap << 10) | (Ap >> (32 - 10)));
	;
	;
	C += (D ^ (E | ~A)) + X[15] + 0xA953FD4E;
	C = ((C << 5) | (C >> (32 - 5))) + B;
	E = ((E << 10) | (E >> (32 - 10)));
	;
	Cp += (Dp ^ Ep ^ Ap) + X[9] + 0x00000000;
	Cp = ((Cp << 11) | (Cp >> (32 - 11))) + Bp;
	Ep = ((Ep << 10) | (Ep >> (32 - 10)));
	;
	;
	B += (C ^ (D | ~E)) + X[13] + 0xA953FD4E;
	B = ((B << 6) | (B >> (32 - 6))) + A;
	D = ((D << 10) | (D >> (32 - 10)));
	;
	Bp += (Cp ^ Dp ^ Ep) + X[11] + 0x00000000;
	Bp = ((Bp << 11) | (Bp >> (32 - 11))) + Ap;
	Dp = ((Dp << 10) | (Dp >> (32 - 10)));
	;
	;
	C = ctx.state[1] + C + Dp;
	ctx.state[1] = ctx.state[2] + D + Ep;
	ctx.state[2] = ctx.state[3] + E + Ap;
	ctx.state[3] = ctx.state[4] + A + Bp;
	ctx.state[4] = ctx.state[0] + B + Cp;
	ctx.state[0] = C;
}

pub fn mbedtls_ripemd160_update(mbedtls_ripemd160_context * ctx, const u8 * input, usize ilen)
{
	usize fill;
	u32 left;
	if ilen == 0
	{
		return;
	}
	left = ctx.total[0] & 0x3F;
	fill = 64 - left;
	ctx.total[0] += (u32) ilen;
	ctx.total[0] &= 0xFFFFFFFF;
	if ctx.total[0] < (u32) ilen
	{
		ctx.total[1]++;
	}
	if left && ilen >= fill
	{
		memcpy((void *) (ctx.buffer + left), input, fill);
		mbedtls_ripemd160_process(ctx, ctx.buffer);
		input += fill;
		ilen -= fill;
		left = 0;
	}
	while (ilen >= 64)
	{
		mbedtls_ripemd160_process(ctx, input);
		input += 64;
		ilen -= 64;
	}
	if ilen > 0
	{
		memcpy((void *) (ctx.buffer + left), input, ilen);
	}
}

static const u8 ripemd160_padding[64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
pub fn mbedtls_ripemd160_finish(mbedtls_ripemd160_context * ctx, u8 output[20])
{
	u32 last, padn;
	u32 high, low;
	u8 msglen[8];
	high = (ctx.total[0] >> 29) | (ctx.total[1] << 3);
	low = (ctx.total[0] << 3);
	PUT_UINT32_LE(low, msglen, 0);
	PUT_UINT32_LE(high, msglen, 4);
	last = ctx.total[0] & 0x3F;
	padn = (last < 56) ? (56 - last) : (120 - last);
	mbedtls_ripemd160_update(ctx, ripemd160_padding, padn);
	mbedtls_ripemd160_update(ctx, msglen, 8);
	PUT_UINT32_LE(ctx.state[0], output, 0);
	PUT_UINT32_LE(ctx.state[1], output, 4);
	PUT_UINT32_LE(ctx.state[2], output, 8);
	PUT_UINT32_LE(ctx.state[3], output, 12);
	PUT_UINT32_LE(ctx.state[4], output, 16);
}

pub fn mbedtls_ripemd160(const u8 * input, usize ilen, u8 output[20])
{
	mbedtls_ripemd160_context ctx;
	mbedtls_ripemd160_init(&ctx);
	mbedtls_ripemd160_starts(&ctx);
	mbedtls_ripemd160_update(&ctx, input, ilen);
	mbedtls_ripemd160_finish(&ctx, output);
	mbedtls_ripemd160_free(&ctx);
}

static const i8 * ripemd160_test_input[8] =
{
	"", "a", "abc", "message digest", "abcdefghijklmnopqrstuvwxyz", "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "1234567890123456789012345678901234567890"
	"1234567890123456789012345678901234567890",
};
static const u8 ripemd160_test_md[8][20] =
{
	{0x9c, 0x11, 0x85, 0xa5, 0xc5, 0xe9, 0xfc, 0x54, 0x61, 0x28, 0x08, 0x97, 0x7e, 0xe8, 0xf5, 0x48, 0xb2, 0x25, 0x8d, 0x31}, {0x0b, 0xdc, 0x9d, 0x2d, 0x25, 0x6b, 0x3e, 0xe9, 0xda, 0xae, 0x34, 0x7b, 0xe6, 0xf4, 0xdc, 0x83, 0x5a, 0x46, 0x7f, 0xfe}, {0x8e, 0xb2, 0x08, 0xf7, 0xe0, 0x5d, 0x98, 0x7a, 0x9b, 0x04, 0x4a, 0x8e, 0x98, 0xc6, 0xb0, 0x87, 0xf1, 0x5a, 0x0b, 0xfc}, {0x5d, 0x06, 0x89, 0xef, 0x49, 0xd2, 0xfa, 0xe5, 0x72, 0xb8, 0x81, 0xb1, 0x23, 0xa8, 0x5f, 0xfa, 0x21, 0x59, 0x5f, 0x36}, {0xf7, 0x1c, 0x27, 0x10, 0x9c, 0x69, 0x2c, 0x1b, 0x56, 0xbb, 0xdc, 0xeb, 0x5b, 0x9d, 0x28, 0x65, 0xb3, 0x70, 0x8d, 0xbc}, {0x12, 0xa0, 0x53, 0x38, 0x4a, 0x9c, 0x0c, 0x88, 0xe4, 0x05, 0xa0, 0x6c, 0x27, 0xdc, 0xf4, 0x9a, 0xda, 0x62, 0xeb, 0x2b}, {0xb0, 0xe2, 0x0b, 0x6e, 0x31, 0x16, 0x64, 0x02, 0x86, 0xed, 0x3a, 0x87, 0xa5, 0x71, 0x30, 0x79, 0xb2, 0x1f, 0x51, 0x89}, {0x9b, 0x75, 0x2e, 0x45, 0x57, 0x3d, 0x4b, 0x39, 0xf4, 0xdb, 0xd3, 0x32, 0x3c, 0xab, 0x82, 0xbf, 0x63, 0x32, 0x6b, 0xfb},
};
pub fn mbedtls_ripemd160_self_test(i32 verbose) -> i32
{
	i32 i;
	u8 output[20];
	memset(output, 0, sizeof output);
	for (i = 0; i < 8; i++)
	{
		if verbose != 0
		{
			printf("  RIPEMD-160 test #%d: ", i + 1);
		}
		mbedtls_ripemd160((const u8 *) ripemd160_test_input[i], strlen(ripemd160_test_input[i]), output);
		if memcmp(output, ripemd160_test_md[i], 20) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			return 1;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	return 0;
}

pub fn mbedtls_rsa_init(mbedtls_rsa_context * ctx, i32 padding, i32 hash_id)
{
	memset(ctx, 0, sizeof(mbedtls_rsa_context));
	mbedtls_rsa_set_padding(ctx, padding, hash_id);
	mbedtls_mutex_init(&ctx.mutex);
}

pub fn mbedtls_rsa_set_padding(mbedtls_rsa_context * ctx, i32 padding, i32 hash_id)
{
	ctx.padding = padding;
	ctx.hash_id = hash_id;
}

pub fn mbedtls_rsa_gen_key(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, u32 nbits, i32 exponent) -> i32
{
	i32 ret;
	mbedtls_mpi P1, Q1, H, G;
	if f_rng == NULL || nbits < 128 || exponent < 3
	{
		return -0x4080;
	}
	mbedtls_mpi_init(&P1);
	mbedtls_mpi_init(&Q1);
	mbedtls_mpi_init(&H);
	mbedtls_mpi_init(&G);
	do
	{
		if (ret = mbedtls_mpi_lset(&ctx.E, exponent)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		do
		{
			if (ret = mbedtls_mpi_gen_prime(&ctx.P, nbits >> 1, 0, f_rng, p_rng)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if nbits % 2
		{
			do
			{
				if (ret = mbedtls_mpi_gen_prime(&ctx.Q, (nbits >> 1) + 1, 0, f_rng, p_rng)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		else
		{
			do
			{
				if (ret = mbedtls_mpi_gen_prime(&ctx.Q, nbits >> 1, 0, f_rng, p_rng)) != 0
				{
					goto cleanup;
				}
			}
			while (0);
		}
		if mbedtls_mpi_cmp_mpi(&ctx.P, &ctx.Q) == 0
		{
			continue;
		}
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&ctx.N, &ctx.P, &ctx.Q)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		if mbedtls_mpi_bitlen(&ctx.N) != nbits
		{
			continue;
		}
		do
		{
			if (ret = mbedtls_mpi_sub_int(&P1, &ctx.P, 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_sub_int(&Q1, &ctx.Q, 1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&H, &P1, &Q1)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_gcd(&G, &ctx.E, &H)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	while (mbedtls_mpi_cmp_int(&G, 1) != 0);
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&ctx.D, &ctx.E, &H)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&ctx.DP, &ctx.D, &P1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&ctx.DQ, &ctx.D, &Q1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&ctx.QP, &ctx.Q, &ctx.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	ctx.len = (mbedtls_mpi_bitlen(&ctx.N) + 7) >> 3;
cleanup:
	mbedtls_mpi_free(&P1);
	mbedtls_mpi_free(&Q1);
	mbedtls_mpi_free(&H);
	mbedtls_mpi_free(&G);
	if ret != 0
	{
		mbedtls_rsa_free(ctx);
		return -0x4180 + ret;
	}
	return 0;
}

pub fn mbedtls_rsa_check_pubkey(const mbedtls_rsa_context * ctx) -> i32
{
	if !ctx.N.p || !ctx.E.p
	{
		return -0x4200;
	}
	if (ctx.N.p[0] & 1) == 0 || (ctx.E.p[0] & 1) == 0
	{
		return -0x4200;
	}
	if mbedtls_mpi_bitlen(&ctx.N) < 128 || mbedtls_mpi_bitlen(&ctx.N) > (8 * 1024)
	{
		return -0x4200;
	}
	if mbedtls_mpi_bitlen(&ctx.E) < 2 || mbedtls_mpi_cmp_mpi(&ctx.E, &ctx.N) >= 0
	{
		return -0x4200;
	}
	return 0;
}

pub fn mbedtls_rsa_check_privkey(const mbedtls_rsa_context * ctx) -> i32
{
	i32 ret;
	mbedtls_mpi PQ, DE, P1, Q1, H, I, G, G2, L1, L2, DP, DQ, QP;
	if (ret = mbedtls_rsa_check_pubkey(ctx)) != 0
	{
		return ret;
	}
	if !ctx.P.p || !ctx.Q.p || !ctx.D.p
	{
		return -0x4200;
	}
	mbedtls_mpi_init(&PQ);
	mbedtls_mpi_init(&DE);
	mbedtls_mpi_init(&P1);
	mbedtls_mpi_init(&Q1);
	mbedtls_mpi_init(&H);
	mbedtls_mpi_init(&I);
	mbedtls_mpi_init(&G);
	mbedtls_mpi_init(&G2);
	mbedtls_mpi_init(&L1);
	mbedtls_mpi_init(&L2);
	mbedtls_mpi_init(&DP);
	mbedtls_mpi_init(&DQ);
	mbedtls_mpi_init(&QP);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&PQ, &ctx.P, &ctx.Q)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&DE, &ctx.D, &ctx.E)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_int(&P1, &ctx.P, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_int(&Q1, &ctx.Q, 1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&H, &P1, &Q1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_gcd(&G, &ctx.E, &H)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_gcd(&G2, &P1, &Q1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_div_mpi(&L1, &L2, &H, &G2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&I, &DE, &L1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&DP, &ctx.D, &P1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&DQ, &ctx.D, &Q1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&QP, &ctx.Q, &ctx.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_mpi(&PQ, &ctx.N) != 0 || mbedtls_mpi_cmp_mpi(&DP, &ctx.DP) != 0 || mbedtls_mpi_cmp_mpi(&DQ, &ctx.DQ) != 0 || mbedtls_mpi_cmp_mpi(&QP, &ctx.QP) != 0 || mbedtls_mpi_cmp_int(&L2, 0) != 0 || mbedtls_mpi_cmp_int(&I, 1) != 0 || mbedtls_mpi_cmp_int(&G, 1) != 0
	{
		ret = -0x4200;
	}
cleanup:
	mbedtls_mpi_free(&PQ);
	mbedtls_mpi_free(&DE);
	mbedtls_mpi_free(&P1);
	mbedtls_mpi_free(&Q1);
	mbedtls_mpi_free(&H);
	mbedtls_mpi_free(&I);
	mbedtls_mpi_free(&G);
	mbedtls_mpi_free(&G2);
	mbedtls_mpi_free(&L1);
	mbedtls_mpi_free(&L2);
	mbedtls_mpi_free(&DP);
	mbedtls_mpi_free(&DQ);
	mbedtls_mpi_free(&QP);
	if ret == -0x4200
	{
		return ret;
	}
	if ret != 0
	{
		return -0x4200 + ret;
	}
	return 0;
}

pub fn mbedtls_rsa_check_pub_priv(const mbedtls_rsa_context * pub, const mbedtls_rsa_context * prv) -> i32
{
	if mbedtls_rsa_check_pubkey(pub) != 0 || mbedtls_rsa_check_privkey(prv) != 0
	{
		return -0x4200;
	}
	if mbedtls_mpi_cmp_mpi(&pub.N, &prv.N) != 0 || mbedtls_mpi_cmp_mpi(&pub.E, &prv.E) != 0
	{
		return -0x4200;
	}
	return 0;
}

pub fn mbedtls_rsa_public(mbedtls_rsa_context * ctx, const u8 * input, u8 * output) -> i32
{
	i32 ret;
	usize olen;
	mbedtls_mpi T;
	mbedtls_mpi_init(&T);
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	do
	{
		if (ret = mbedtls_mpi_read_binary(&T, input, ctx.len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_mpi(&T, &ctx.N) >= 0
	{
		ret = -0x0004;
		goto cleanup;
	}
	olen = ctx.len;
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&T, &T, &ctx.E, &ctx.N, &ctx.RN)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_write_binary(&T, output, olen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	mbedtls_mpi_free(&T);
	if ret != 0
	{
		return -0x4280 + ret;
	}
	return 0;
}

fn rsa_prepare_blinding(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret, count = 0;
	if ctx.Vf.p != NULL
	{
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&ctx.Vi, &ctx.Vi, &ctx.Vi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&ctx.Vi, &ctx.Vi, &ctx.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&ctx.Vf, &ctx.Vf, &ctx.Vf)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&ctx.Vf, &ctx.Vf, &ctx.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		goto cleanup;
	}
	do
	{
		if count++ > 10
		{
			return -0x4480;
		}
		do
		{
			if (ret = mbedtls_mpi_fill_random(&ctx.Vf, ctx.len - 1, f_rng, p_rng)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_gcd(&ctx.Vi, &ctx.Vf, &ctx.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	while (mbedtls_mpi_cmp_int(&ctx.Vi, 1) != 0);
	do
	{
		if (ret = mbedtls_mpi_inv_mod(&ctx.Vi, &ctx.Vf, &ctx.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&ctx.Vi, &ctx.Vi, &ctx.E, &ctx.N, &ctx.RN)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	return ret;
}

pub fn mbedtls_rsa_private(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, const u8 * input, u8 * output) -> i32
{
	i32 ret;
	usize olen;
	mbedtls_mpi T, T1, T2;
	if ctx.P.p == NULL || ctx.Q.p == NULL || ctx.D.p == NULL
	{
		return -0x4080;
	}
	mbedtls_mpi_init(&T);
	mbedtls_mpi_init(&T1);
	mbedtls_mpi_init(&T2);
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	do
	{
		if (ret = mbedtls_mpi_read_binary(&T, input, ctx.len)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if mbedtls_mpi_cmp_mpi(&T, &ctx.N) >= 0
	{
		ret = -0x0004;
		goto cleanup;
	}
	if f_rng != NULL
	{
		do
		{
			if (ret = rsa_prepare_blinding(ctx, f_rng, p_rng)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&T, &T, &ctx.Vi)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&T, &T, &ctx.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&T1, &T, &ctx.DP, &ctx.P, &ctx.RP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_exp_mod(&T2, &T, &ctx.DQ, &ctx.Q, &ctx.RQ)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_sub_mpi(&T, &T1, &T2)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T1, &T, &ctx.QP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mod_mpi(&T, &T1, &ctx.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_mul_mpi(&T1, &T, &ctx.Q)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_add_mpi(&T, &T2, &T1)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	if f_rng != NULL
	{
		do
		{
			if (ret = mbedtls_mpi_mul_mpi(&T, &T, &ctx.Vf)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_mpi_mod_mpi(&T, &T, &ctx.N)) != 0
			{
				goto cleanup;
			}
		}
		while (0);
	}
	olen = ctx.len;
	do
	{
		if (ret = mbedtls_mpi_write_binary(&T, output, olen)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
cleanup:
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	mbedtls_mpi_free(&T);
	mbedtls_mpi_free(&T1);
	mbedtls_mpi_free(&T2);
	if ret != 0
	{
		return -0x4300 + ret;
	}
	return 0;
}

fn mgf_mask(u8 * dst, usize dlen, u8 * src, usize slen, mbedtls_md_context_t * md_ctx)
{
	u8 mask[64];
	u8 counter[4];
	u8 * p;
	u32 hlen;
	usize i, use_len;
	memset(mask, 0, 64);
	memset(counter, 0, 4);
	hlen = mbedtls_md_get_size(md_ctx.md_info);
	p = dst;
	while (dlen > 0)
	{
		use_len = hlen;
		if dlen < hlen
		{
			use_len = dlen;
		}
		mbedtls_md_starts(md_ctx);
		mbedtls_md_update(md_ctx, src, slen);
		mbedtls_md_update(md_ctx, counter, 4);
		mbedtls_md_finish(md_ctx, mask);
		for (i = 0; i < use_len; ++i)
		{
			*p++ ^= mask[i];
		}
		counter[3]++;
		dlen -= use_len;
	}
}

pub fn mbedtls_rsa_rsaes_oaep_encrypt(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, const u8 * label, usize label_len, usize ilen, const u8 * input, u8 * output) -> i32
{
	usize olen;
	i32 ret;
	u8 * p = output;
	u32 hlen;
	const mbedtls_md_info_t * md_info;
	mbedtls_md_context_t md_ctx;
	if mode == 1 && ctx.padding != 1
	{
		return -0x4080;
	}
	if f_rng == NULL
	{
		return -0x4080;
	}
	md_info = mbedtls_md_info_from_type((mbedtls_md_type_t) ctx.hash_id);
	if md_info == NULL
	{
		return -0x4080;
	}
	olen = ctx.len;
	hlen = mbedtls_md_get_size(md_info);
	if ilen + 2 * hlen + 2 < ilen || olen < ilen + 2 * hlen + 2
	{
		return -0x4080;
	}
	memset(output, 0, olen);
	*p++ = 0;
	if (ret = f_rng(p_rng, p, hlen)) != 0
	{
		return -0x4480 + ret;
	}
	p += hlen;
	mbedtls_md(md_info, label, label_len, p);
	p += hlen;
	p += olen - 2 * hlen - 2 - ilen;
	*p++ = 1;
	memcpy(p, input, ilen);
	mbedtls_md_init(&md_ctx);
	if (ret = mbedtls_md_setup(&md_ctx, md_info, 0)) != 0
	{
		mbedtls_md_free(&md_ctx);
		return ret;
	}
	mgf_mask(output + hlen + 1, olen - hlen - 1, output + 1, hlen, &md_ctx);
	mgf_mask(output + 1, hlen, output + hlen + 1, olen - hlen - 1, &md_ctx);
	mbedtls_md_free(&md_ctx);
	return (mode == 0) ? mbedtls_rsa_public(ctx, output, output) : mbedtls_rsa_private(ctx, f_rng, p_rng, output, output);
}

pub fn mbedtls_rsa_rsaes_pkcs1_v15_encrypt(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, usize ilen, const u8 * input, u8 * output) -> i32
{
	usize nb_pad, olen;
	i32 ret;
	u8 * p = output;
	if mode == 1 && ctx.padding != 0
	{
		return -0x4080;
	}
	if f_rng == NULL || input == NULL || output == NULL
	{
		return -0x4080;
	}
	olen = ctx.len;
	if ilen + 11 < ilen || olen < ilen + 11
	{
		return -0x4080;
	}
	nb_pad = olen - 3 - ilen;
	*p++ = 0;
	if mode == 0
	{
		*p++ = 2;
		while (nb_pad-- > 0)
		{
			i32 rng_dl = 100;
			do
			{
				ret = f_rng(p_rng, p, 1);
			}
			while (*p == 0 && --rng_dl && ret == 0);
			if rng_dl == 0 || ret != 0
			{
				return -0x4480 + ret;
			}
			p++;
		}
	}
	else
	{
		*p++ = 1;
		while (nb_pad-- > 0)
		{
			*p++ = 0xFF;
		}
	}
	*p++ = 0;
	memcpy(p, input, ilen);
	return (mode == 0) ? mbedtls_rsa_public(ctx, output, output) : mbedtls_rsa_private(ctx, f_rng, p_rng, output, output);
}

pub fn mbedtls_rsa_pkcs1_encrypt(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, usize ilen, const u8 * input, u8 * output) -> i32
{
	switch (ctx.padding)
	{
		case 0:
		return mbedtls_rsa_rsaes_pkcs1_v15_encrypt(ctx, f_rng, p_rng, mode, ilen, input, output);
		case 1:
		return mbedtls_rsa_rsaes_oaep_encrypt(ctx, f_rng, p_rng, mode, NULL, 0, ilen, input, output);
	default:
		return -0x4100;
	}
}

pub fn mbedtls_rsa_rsaes_oaep_decrypt(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, const u8 * label, usize label_len, usize * olen, const u8 * input, u8 * output, usize output_max_len) -> i32
{
	i32 ret;
	usize ilen, i, pad_len;
	u8 *p, bad, pad_done;
	u8 buf[1024];
	u8 lhash[64];
	u32 hlen;
	const mbedtls_md_info_t * md_info;
	mbedtls_md_context_t md_ctx;
	if mode == 1 && ctx.padding != 1
	{
		return -0x4080;
	}
	ilen = ctx.len;
	if ilen < 16 || ilen > sizeof(buf)
	{
		return -0x4080;
	}
	md_info = mbedtls_md_info_from_type((mbedtls_md_type_t) ctx.hash_id);
	if md_info == NULL
	{
		return -0x4080;
	}
	hlen = mbedtls_md_get_size(md_info);
	if 2 * hlen + 2 > ilen
	{
		return -0x4080;
	}
	ret = (mode == 0) ? mbedtls_rsa_public(ctx, input, buf) : mbedtls_rsa_private(ctx, f_rng, p_rng, input, buf);
	if ret != 0
	{
		return ret;
	}
	mbedtls_md_init(&md_ctx);
	if (ret = mbedtls_md_setup(&md_ctx, md_info, 0)) != 0
	{
		mbedtls_md_free(&md_ctx);
		return ret;
	}
	mbedtls_md(md_info, label, label_len, lhash);
	mgf_mask(buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1, &md_ctx);
	mgf_mask(buf + hlen + 1, ilen - hlen - 1, buf + 1, hlen, &md_ctx);
	mbedtls_md_free(&md_ctx);
	p = buf;
	bad = 0;
	bad |= *p++;
	p += hlen;
	for (i = 0; i < hlen; i++)
	{
		bad |= lhash[i] ^ *p++;
	}
	pad_len = 0;
	pad_done = 0;
	for (i = 0; i < ilen - 2 * hlen - 2; i++)
	{
		pad_done |= p[i];
		pad_len += ((pad_done | (i8) -pad_done) >> 7) ^ 1;
	}
	p += pad_len;
	bad |= *p++ ^ 0x01;
	if bad != 0
	{
		return -0x4100;
	}
	if ilen - (p - buf) > output_max_len
	{
		return -0x4400;
	}
	*olen = ilen - (p - buf);
	memcpy(output, p, *olen);
	return 0;
}

pub fn mbedtls_rsa_rsaes_pkcs1_v15_decrypt(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, usize * olen, const u8 * input, u8 * output, usize output_max_len) -> i32
{
	i32 ret;
	usize ilen, pad_count = 0, i;
	u8 *p, bad, pad_done = 0;
	u8 buf[1024];
	if mode == 1 && ctx.padding != 0
	{
		return -0x4080;
	}
	ilen = ctx.len;
	if ilen < 16 || ilen > sizeof(buf)
	{
		return -0x4080;
	}
	ret = (mode == 0) ? mbedtls_rsa_public(ctx, input, buf) : mbedtls_rsa_private(ctx, f_rng, p_rng, input, buf);
	if ret != 0
	{
		return ret;
	}
	p = buf;
	bad = 0;
	bad |= *p++;
	if mode == 1
	{
		bad |= *p++ ^ 2;
		for (i = 0; i < ilen - 3; i++)
		{
			pad_done |= ((p[i] | (i8) -p[i]) >> 7) ^ 1;
			pad_count += ((pad_done | (i8) -pad_done) >> 7) ^ 1;
		}
		p += pad_count;
		bad |= *p++;
	}
	else
	{
		bad |= *p++ ^ 1;
		for (i = 0; i < ilen - 3; i++)
		{
			pad_done |= (p[i] != 0xFF);
			pad_count += (pad_done == 0);
		}
		p += pad_count;
		bad |= *p++;
	}
	bad |= (pad_count < 8);
	if bad
	{
		return -0x4100;
	}
	if ilen - (p - buf) > output_max_len
	{
		return -0x4400;
	}
	*olen = ilen - (p - buf);
	memcpy(output, p, *olen);
	return 0;
}

pub fn mbedtls_rsa_pkcs1_decrypt(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, usize * olen, const u8 * input, u8 * output, usize output_max_len) -> i32
{
	switch (ctx.padding)
	{
		case 0:
		return mbedtls_rsa_rsaes_pkcs1_v15_decrypt(ctx, f_rng, p_rng, mode, olen, input, output, output_max_len);
		case 1:
		return mbedtls_rsa_rsaes_oaep_decrypt(ctx, f_rng, p_rng, mode, NULL, 0, olen, input, output, output_max_len);
	default:
		return -0x4100;
	}
}

pub fn mbedtls_rsa_rsassa_pss_sign(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, mbedtls_md_type_t md_alg, u32 hashlen, const u8 * hash, u8 * sig) -> i32
{
	usize olen;
	u8 * p = sig;
	u8 salt[64];
	u32 slen, hlen, offset = 0;
	i32 ret;
	usize msb;
	const mbedtls_md_info_t * md_info;
	mbedtls_md_context_t md_ctx;
	if mode == 1 && ctx.padding != 1
	{
		return -0x4080;
	}
	if f_rng == NULL
	{
		return -0x4080;
	}
	olen = ctx.len;
	if md_alg != MBEDTLS_MD_NONE
	{
		md_info = mbedtls_md_info_from_type(md_alg);
		if md_info == NULL
		{
			return -0x4080;
		}
		hashlen = mbedtls_md_get_size(md_info);
	}
	md_info = mbedtls_md_info_from_type((mbedtls_md_type_t) ctx.hash_id);
	if md_info == NULL
	{
		return -0x4080;
	}
	hlen = mbedtls_md_get_size(md_info);
	slen = hlen;
	if olen < hlen + slen + 2
	{
		return -0x4080;
	}
	memset(sig, 0, olen);
	if (ret = f_rng(p_rng, salt, slen)) != 0
	{
		return -0x4480 + ret;
	}
	msb = mbedtls_mpi_bitlen(&ctx.N) - 1;
	p += olen - hlen * 2 - 2;
	*p++ = 0x01;
	memcpy(p, salt, slen);
	p += slen;
	mbedtls_md_init(&md_ctx);
	if (ret = mbedtls_md_setup(&md_ctx, md_info, 0)) != 0
	{
		mbedtls_md_free(&md_ctx);
		return ret;
	}
	mbedtls_md_starts(&md_ctx);
	mbedtls_md_update(&md_ctx, p, 8);
	mbedtls_md_update(&md_ctx, hash, hashlen);
	mbedtls_md_update(&md_ctx, salt, slen);
	mbedtls_md_finish(&md_ctx, p);
	if msb % 8 == 0
	{
		offset = 1;
	}
	mgf_mask(sig + offset, olen - hlen - 1 - offset, p, hlen, &md_ctx);
	mbedtls_md_free(&md_ctx);
	msb = mbedtls_mpi_bitlen(&ctx.N) - 1;
	sig[0] &= 0xFF >> (olen * 8 - msb);
	p += hlen;
	*p++ = 0xBC;
	return (mode == 0) ? mbedtls_rsa_public(ctx, sig, sig) : mbedtls_rsa_private(ctx, f_rng, p_rng, sig, sig);
}

pub fn mbedtls_rsa_rsassa_pkcs1_v15_sign(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, mbedtls_md_type_t md_alg, u32 hashlen, const u8 * hash, u8 * sig) -> i32
{
	usize nb_pad, olen, oid_size = 0;
	u8 * p = sig;
	const i8 * oid = NULL;
	u8 *sig_try = NULL, *verif = NULL;
	usize i;
	u8 diff;
	volatile u8 diff_no_optimize;
	i32 ret;
	if mode == 1 && ctx.padding != 0
	{
		return -0x4080;
	}
	olen = ctx.len;
	nb_pad = olen - 3;
	if md_alg != MBEDTLS_MD_NONE
	{
		const mbedtls_md_info_t * md_info = mbedtls_md_info_from_type(md_alg);
		if md_info == NULL
		{
			return -0x4080;
		}
		if mbedtls_oid_get_oid_by_md(md_alg, &oid, &oid_size) != 0
		{
			return -0x4080;
		}
		nb_pad -= 10 + oid_size;
		hashlen = mbedtls_md_get_size(md_info);
	}
	nb_pad -= hashlen;
	if (nb_pad < 8) || (nb_pad > olen)
	{
		return -0x4080;
	}
	*p++ = 0;
	*p++ = 1;
	memset(p, 0xFF, nb_pad);
	p += nb_pad;
	*p++ = 0;
	if md_alg == MBEDTLS_MD_NONE
	{
		memcpy(p, hash, hashlen);
	}
	else
	{
		*p++ = 0x10 | 0x20;
		*p++ = (i8) (0x08 + oid_size + hashlen);
		*p++ = 0x10 | 0x20;
		*p++ = (i8) (0x04 + oid_size);
		*p++ = 0x06;
		*p++ = oid_size & 0xFF;
		memcpy(p, oid, oid_size);
		p += oid_size;
		*p++ = 0x05;
		*p++ = 0x00;
		*p++ = 0x04;
		*p++ = hashlen;
		memcpy(p, hash, hashlen);
	}
	if mode == 0
	{
		return mbedtls_rsa_public(ctx, sig, sig);
	}
	sig_try = mbedtls_calloc(1, ctx.len);
	if sig_try == NULL
	{
		return -0x0010;
	}
	verif = mbedtls_calloc(1, ctx.len);
	if verif == NULL
	{
		mbedtls_free(sig_try);
		return -0x0010;
	}
	do
	{
		if (ret = mbedtls_rsa_private(ctx, f_rng, p_rng, sig, sig_try)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_rsa_public(ctx, sig_try, verif)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	for (diff = 0, i = 0; i < ctx.len; i++)
	{
		diff |= verif[i] ^ sig[i];
	}
	diff_no_optimize = diff;
	if diff_no_optimize != 0
	{
		ret = -0x4300;
		goto cleanup;
	}
	memcpy(sig, sig_try, ctx.len);
cleanup:
	mbedtls_free(sig_try);
	mbedtls_free(verif);
	return ret;
}

pub fn mbedtls_rsa_pkcs1_sign(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, mbedtls_md_type_t md_alg, u32 hashlen, const u8 * hash, u8 * sig) -> i32
{
	switch (ctx.padding)
	{
		case 0:
		return mbedtls_rsa_rsassa_pkcs1_v15_sign(ctx, f_rng, p_rng, mode, md_alg, hashlen, hash, sig);
		case 1:
		return mbedtls_rsa_rsassa_pss_sign(ctx, f_rng, p_rng, mode, md_alg, hashlen, hash, sig);
	default:
		return -0x4100;
	}
}

pub fn mbedtls_rsa_rsassa_pss_verify_ext(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, mbedtls_md_type_t md_alg, u32 hashlen, const u8 * hash, mbedtls_md_type_t mgf1_hash_id, i32 expected_salt_len, const u8 * sig) -> i32
{
	i32 ret;
	usize siglen;
	u8 * p;
	u8 result[64];
	u8 zeros[8];
	u32 hlen;
	usize slen, msb;
	const mbedtls_md_info_t * md_info;
	mbedtls_md_context_t md_ctx;
	u8 buf[1024];
	if mode == 1 && ctx.padding != 1
	{
		return -0x4080;
	}
	siglen = ctx.len;
	if siglen < 16 || siglen > sizeof(buf)
	{
		return -0x4080;
	}
	ret = (mode == 0) ? mbedtls_rsa_public(ctx, sig, buf) : mbedtls_rsa_private(ctx, f_rng, p_rng, sig, buf);
	if ret != 0
	{
		return ret;
	}
	p = buf;
	if buf[siglen - 1] != 0xBC
	{
		return -0x4100;
	}
	if md_alg != MBEDTLS_MD_NONE
	{
		md_info = mbedtls_md_info_from_type(md_alg);
		if md_info == NULL
		{
			return -0x4080;
		}
		hashlen = mbedtls_md_get_size(md_info);
	}
	md_info = mbedtls_md_info_from_type(mgf1_hash_id);
	if md_info == NULL
	{
		return -0x4080;
	}
	hlen = mbedtls_md_get_size(md_info);
	slen = siglen - hlen - 1;
	memset(zeros, 0, 8);
	msb = mbedtls_mpi_bitlen(&ctx.N) - 1;
	if msb % 8 == 0
	{
		p++;
		siglen -= 1;
	}
	if buf[0] >> (8 - siglen * 8 + msb)
	{
		return -0x4080;
	}
	mbedtls_md_init(&md_ctx);
	if (ret = mbedtls_md_setup(&md_ctx, md_info, 0)) != 0
	{
		mbedtls_md_free(&md_ctx);
		return ret;
	}
	mgf_mask(p, siglen - hlen - 1, p + siglen - hlen - 1, hlen, &md_ctx);
	buf[0] &= 0xFF >> (siglen * 8 - msb);
	while (p < buf + siglen && *p == 0)
	{
		p++;
	}
	if p == buf + siglen || *p++ != 0x01
	{
		mbedtls_md_free(&md_ctx);
		return -0x4100;
	}
	slen -= p - buf;
	if expected_salt_len != -1 && slen != (usize) expected_salt_len
	{
		mbedtls_md_free(&md_ctx);
		return -0x4100;
	}
	mbedtls_md_starts(&md_ctx);
	mbedtls_md_update(&md_ctx, zeros, 8);
	mbedtls_md_update(&md_ctx, hash, hashlen);
	mbedtls_md_update(&md_ctx, p, slen);
	mbedtls_md_finish(&md_ctx, result);
	mbedtls_md_free(&md_ctx);
	if memcmp(p + slen, result, hlen) == 0
	{
		return 0;
	}
	else
	{
		return -0x4380;
	}
}

pub fn mbedtls_rsa_rsassa_pss_verify(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, mbedtls_md_type_t md_alg, u32 hashlen, const u8 * hash, const u8 * sig) -> i32
{
	mbedtls_md_type_t mgf1_hash_id = (ctx.hash_id != MBEDTLS_MD_NONE) ? (mbedtls_md_type_t) ctx.hash_id : md_alg;
	return mbedtls_rsa_rsassa_pss_verify_ext(ctx, f_rng, p_rng, mode, md_alg, hashlen, hash, mgf1_hash_id, -1, sig);
}

pub fn mbedtls_rsa_rsassa_pkcs1_v15_verify(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, mbedtls_md_type_t md_alg, u32 hashlen, const u8 * hash, const u8 * sig) -> i32
{
	i32 ret;
	usize len, siglen, asn1_len;
	u8 *p, *end;
	mbedtls_md_type_t msg_md_alg;
	const mbedtls_md_info_t * md_info;
	mbedtls_asn1_buf oid;
	u8 buf[1024];
	if mode == 1 && ctx.padding != 0
	{
		return -0x4080;
	}
	siglen = ctx.len;
	if siglen < 16 || siglen > sizeof(buf)
	{
		return -0x4080;
	}
	ret = (mode == 0) ? mbedtls_rsa_public(ctx, sig, buf) : mbedtls_rsa_private(ctx, f_rng, p_rng, sig, buf);
	if ret != 0
	{
		return ret;
	}
	p = buf;
	if *p++ != 0 || *p++ != 1
	{
		return -0x4100;
	}
	while (*p != 0)
	{
		if p >= buf + siglen - 1 || *p != 0xFF
		{
			return -0x4100;
		}
		p++;
	}
	p++;
	len = siglen - (p - buf);
	if len == hashlen && md_alg == MBEDTLS_MD_NONE
	{
		if memcmp(p, hash, hashlen) == 0
		{
			return 0;
		}
		else
		{
			return -0x4380;
		}
	}
	md_info = mbedtls_md_info_from_type(md_alg);
	if md_info == NULL
	{
		return -0x4080;
	}
	hashlen = mbedtls_md_get_size(md_info);
	end = p + len;
	if (ret = mbedtls_asn1_get_tag(&p, end, &asn1_len, 0x20 | 0x10)) != 0
	{
		return -0x4380;
	}
	if asn1_len + 2 != len
	{
		return -0x4380;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &asn1_len, 0x20 | 0x10)) != 0
	{
		return -0x4380;
	}
	if asn1_len + 6 + hashlen != len
	{
		return -0x4380;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &oid.len, 0x06)) != 0
	{
		return -0x4380;
	}
	oid.p = p;
	p += oid.len;
	if mbedtls_oid_get_md_alg(&oid, &msg_md_alg) != 0
	{
		return -0x4380;
	}
	if md_alg != msg_md_alg
	{
		return -0x4380;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &asn1_len, 0x05)) != 0
	{
		return -0x4380;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &asn1_len, 0x04)) != 0
	{
		return -0x4380;
	}
	if asn1_len != hashlen
	{
		return -0x4380;
	}
	if memcmp(p, hash, hashlen) != 0
	{
		return -0x4380;
	}
	p += hashlen;
	if p != end
	{
		return -0x4380;
	}
	return 0;
}

pub fn mbedtls_rsa_pkcs1_verify(mbedtls_rsa_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, i32 mode, mbedtls_md_type_t md_alg, u32 hashlen, const u8 * hash, const u8 * sig) -> i32
{
	switch (ctx.padding)
	{
		case 0:
		return mbedtls_rsa_rsassa_pkcs1_v15_verify(ctx, f_rng, p_rng, mode, md_alg, hashlen, hash, sig);
		case 1:
		return mbedtls_rsa_rsassa_pss_verify(ctx, f_rng, p_rng, mode, md_alg, hashlen, hash, sig);
	default:
		return -0x4100;
	}
}

pub fn mbedtls_rsa_copy(mbedtls_rsa_context * dst, const mbedtls_rsa_context * src) -> i32
{
	i32 ret;
	dst.ver = src.ver;
	dst.len = src.len;
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.N, &src.N)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.E, &src.E)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.D, &src.D)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.P, &src.P)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.Q, &src.Q)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.DP, &src.DP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.DQ, &src.DQ)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.QP, &src.QP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.RN, &src.RN)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.RP, &src.RP)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.RQ, &src.RQ)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.Vi, &src.Vi)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_copy(&dst.Vf, &src.Vf)) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	dst.padding = src.padding;
	dst.hash_id = src.hash_id;
cleanup:
	if ret != 0
	{
		mbedtls_rsa_free(dst);
	}
	return ret;
}

pub fn mbedtls_rsa_free(mbedtls_rsa_context * ctx)
{
	mbedtls_mpi_free(&ctx.Vi);
	mbedtls_mpi_free(&ctx.Vf);
	mbedtls_mpi_free(&ctx.RQ);
	mbedtls_mpi_free(&ctx.RP);
	mbedtls_mpi_free(&ctx.RN);
	mbedtls_mpi_free(&ctx.QP);
	mbedtls_mpi_free(&ctx.DQ);
	mbedtls_mpi_free(&ctx.DP);
	mbedtls_mpi_free(&ctx.Q);
	mbedtls_mpi_free(&ctx.P);
	mbedtls_mpi_free(&ctx.D);
	mbedtls_mpi_free(&ctx.E);
	mbedtls_mpi_free(&ctx.N);
	mbedtls_mutex_free(&ctx.mutex);
}

fn myrand(void * rng_state, u8 * output, usize len) -> i32
{
	usize i;
	if rng_state != NULL
	{
		rng_state = NULL;
	}
	for (i = 0; i < len; ++i)
	{
		output[i] = rand();
	}
	return 0;
}

pub fn mbedtls_rsa_self_test(i32 verbose) -> i32
{
	i32 ret = 0;
	usize len;
	mbedtls_rsa_context rsa;
	u8 rsa_plaintext[24];
	u8 rsa_decrypted[24];
	u8 rsa_ciphertext[128];
	u8 sha1sum[20];
	mbedtls_rsa_init(&rsa, 0, 0);
	rsa.len = 128;
	do
	{
		if ((ret = mbedtls_mpi_read_string(&rsa.N, 16, "9292758453063D803DD603D5E777D788"
										   "8ED1D5BF35786190FA2F23EBC0848AEA"
										   "DDA92CA6C3D80B32C4D109BE0F36D6AE"
										   "7130B9CED7ACDF54CFC7555AC14EEBAB"
										   "93A89813FBF3C4F8066D2D800F7C38A8"
										   "1AE31942917403FF4946B0A83D3D3E05"
										   "EE57C6F5F5606FB5D4BC6CD34EE0801A"
										   "5E94BB77B07507233A0BC7BAC8F90F79")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_mpi_read_string(&rsa.E, 16, "10001")) != 0
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&rsa.D, 16, "24BF6185468786FDD303083D25E64EFC"
										   "66CA472BC44D253102F8B4A9D3BFA750"
										   "91386C0077937FE33FA3252D28855837"
										   "AE1B484A8A9A45F7EE8C0C634F99E8CD"
										   "DF79C5CE07EE72C7F123142198164234"
										   "CABB724CF78B8173B9F880FC86322407"
										   "AF1FEDFDDE2BEB674CA15F3E81A1521E"
										   "071513A1E85B5DFA031F21ECAE91A34D")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&rsa.P, 16, "C36D0EB7FCD285223CFB5AABA5BDA3D8"
										   "2C01CAD19EA484A87EA4377637E75500"
										   "FCB2005C5C7DD6EC4AC023CDA285D796"
										   "C3D9E75E1EFC42488BB4F1D13AC30A57")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&rsa.Q, 16, "C000DF51A7C77AE8D7C7370C1FF55B69"
										   "E211C2B9E5DB1ED0BF61D0D9899620F4"
										   "910E4168387E3C30AA1E00C339A79508"
										   "8452DD96A9A5EA5D9DCA68DA636032AF")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&rsa.DP, 16, "C1ACF567564274FB07A0BBAD5D26E298"
										   "3C94D22288ACD763FD8E5600ED4A702D"
										   "F84198A5F06C2E72236AE490C93F07F8"
										   "3CC559CD27BC2D1CA488811730BB5725")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&rsa.DQ, 16, "4959CBF6F8FEF750AEE6977C155579C7"
										   "D8AAEA56749EA28623272E4F7D0592AF"
										   "7C1F1313CAC9471B5C523BFE592F517B"
										   "407A1BD76C164B93DA2D32A383E58357")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	do
	{
		if ((ret = mbedtls_mpi_read_string(&rsa.QP, 16, "9AE7FBC99546432DF71896FC239EADAE"
										   "F38D18D2B2F0E2DD275AA977E2BF4411"
										   "F5A3B2A5D33605AEBBCCBA7FEB9F2D2F"
										   "A74206CEC169D74BF5A8C50D6F48EA08")) != 0)
		{
			goto cleanup;
		}
	}
	while (0);
	if verbose != 0
	{
		printf("  RSA key validation: ");
	}
	if mbedtls_rsa_check_pubkey(&rsa) != 0 || mbedtls_rsa_check_privkey(&rsa) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if verbose != 0
	{
		printf("passed\n  PKCS#1 encryption : ");
	}
	memcpy(rsa_plaintext, "\xAA\xBB\xCC\x03\x02\x01\x00\xFF\xFF\xFF\xFF\xFF"
		   "\x11\x22\x33\x0A\x0B\x0C\xCC\xDD\xDD\xDD\xDD\xDD",
		   24);
	if mbedtls_rsa_pkcs1_encrypt(&rsa, myrand, NULL, 0, 24, rsa_plaintext, rsa_ciphertext) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if verbose != 0
	{
		printf("passed\n  PKCS#1 decryption : ");
	}
	if mbedtls_rsa_pkcs1_decrypt(&rsa, myrand, NULL, 1, &len, rsa_ciphertext, rsa_decrypted, sizeof(rsa_decrypted)) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if memcmp(rsa_decrypted, rsa_plaintext, len) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  PKCS#1 data sign  : ");
	}
	mbedtls_sha1(rsa_plaintext, 24, sha1sum);
	if mbedtls_rsa_pkcs1_sign(&rsa, myrand, NULL, 1, MBEDTLS_MD_SHA1, 0, sha1sum, rsa_ciphertext) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if verbose != 0
	{
		printf("passed\n  PKCS#1 sig. verify: ");
	}
	if mbedtls_rsa_pkcs1_verify(&rsa, NULL, NULL, 0, MBEDTLS_MD_SHA1, 0, sha1sum, rsa_ciphertext) != 0
	{
		if verbose != 0
		{
			printf("failed\n");
		}
		return 1;
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("\n");
	}
cleanup:
	mbedtls_rsa_free(&rsa);
	return ret;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = (u8 *) v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_sha1_init(mbedtls_sha1_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_sha1_context));
}

pub fn mbedtls_sha1_free(mbedtls_sha1_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_sha1_context));
}

pub fn mbedtls_sha1_clone(mbedtls_sha1_context * dst, const mbedtls_sha1_context * src)
{
	*dst = *src;
}

pub fn mbedtls_sha1_starts(mbedtls_sha1_context * ctx)
{
	ctx.total[0] = 0;
	ctx.total[1] = 0;
	ctx.state[0] = 0x67452301;
	ctx.state[1] = 0xEFCDAB89;
	ctx.state[2] = 0x98BADCFE;
	ctx.state[3] = 0x10325476;
	ctx.state[4] = 0xC3D2E1F0;
}

pub fn mbedtls_sha1_process(mbedtls_sha1_context * ctx, const u8 data[64])
{
	u32 temp, W[16], A, B, C, D, E;
	{
		(W[0]) = ((u32)(data)[(0)] << 24) | ((u32)(data)[(0) + 1] << 16) | ((u32)(data)[(0) + 2] << 8) | ((u32)(data)[(0) + 3]);
	};
	{
		(W[1]) = ((u32)(data)[(4)] << 24) | ((u32)(data)[(4) + 1] << 16) | ((u32)(data)[(4) + 2] << 8) | ((u32)(data)[(4) + 3]);
	};
	{
		(W[2]) = ((u32)(data)[(8)] << 24) | ((u32)(data)[(8) + 1] << 16) | ((u32)(data)[(8) + 2] << 8) | ((u32)(data)[(8) + 3]);
	};
	{
		(W[3]) = ((u32)(data)[(12)] << 24) | ((u32)(data)[(12) + 1] << 16) | ((u32)(data)[(12) + 2] << 8) | ((u32)(data)[(12) + 3]);
	};
	{
		(W[4]) = ((u32)(data)[(16)] << 24) | ((u32)(data)[(16) + 1] << 16) | ((u32)(data)[(16) + 2] << 8) | ((u32)(data)[(16) + 3]);
	};
	{
		(W[5]) = ((u32)(data)[(20)] << 24) | ((u32)(data)[(20) + 1] << 16) | ((u32)(data)[(20) + 2] << 8) | ((u32)(data)[(20) + 3]);
	};
	{
		(W[6]) = ((u32)(data)[(24)] << 24) | ((u32)(data)[(24) + 1] << 16) | ((u32)(data)[(24) + 2] << 8) | ((u32)(data)[(24) + 3]);
	};
	{
		(W[7]) = ((u32)(data)[(28)] << 24) | ((u32)(data)[(28) + 1] << 16) | ((u32)(data)[(28) + 2] << 8) | ((u32)(data)[(28) + 3]);
	};
	{
		(W[8]) = ((u32)(data)[(32)] << 24) | ((u32)(data)[(32) + 1] << 16) | ((u32)(data)[(32) + 2] << 8) | ((u32)(data)[(32) + 3]);
	};
	{
		(W[9]) = ((u32)(data)[(36)] << 24) | ((u32)(data)[(36) + 1] << 16) | ((u32)(data)[(36) + 2] << 8) | ((u32)(data)[(36) + 3]);
	};
	{
		(W[10]) = ((u32)(data)[(40)] << 24) | ((u32)(data)[(40) + 1] << 16) | ((u32)(data)[(40) + 2] << 8) | ((u32)(data)[(40) + 3]);
	};
	{
		(W[11]) = ((u32)(data)[(44)] << 24) | ((u32)(data)[(44) + 1] << 16) | ((u32)(data)[(44) + 2] << 8) | ((u32)(data)[(44) + 3]);
	};
	{
		(W[12]) = ((u32)(data)[(48)] << 24) | ((u32)(data)[(48) + 1] << 16) | ((u32)(data)[(48) + 2] << 8) | ((u32)(data)[(48) + 3]);
	};
	{
		(W[13]) = ((u32)(data)[(52)] << 24) | ((u32)(data)[(52) + 1] << 16) | ((u32)(data)[(52) + 2] << 8) | ((u32)(data)[(52) + 3]);
	};
	{
		(W[14]) = ((u32)(data)[(56)] << 24) | ((u32)(data)[(56) + 1] << 16) | ((u32)(data)[(56) + 2] << 8) | ((u32)(data)[(56) + 3]);
	};
	{
		(W[15]) = ((u32)(data)[(60)] << 24) | ((u32)(data)[(60) + 1] << 16) | ((u32)(data)[(60) + 2] << 8) | ((u32)(data)[(60) + 3]);
	};
	A = ctx.state[0];
	B = ctx.state[1];
	C = ctx.state[2];
	D = ctx.state[3];
	E = ctx.state[4];
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (D ^ (B & (C ^ D))) + 0x5A827999 + W[0];
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (C ^ (A & (B ^ C))) + 0x5A827999 + W[1];
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (B ^ (E & (A ^ B))) + 0x5A827999 + W[2];
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (A ^ (D & (E ^ A))) + 0x5A827999 + W[3];
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (E ^ (C & (D ^ E))) + 0x5A827999 + W[4];
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (D ^ (B & (C ^ D))) + 0x5A827999 + W[5];
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (C ^ (A & (B ^ C))) + 0x5A827999 + W[6];
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (B ^ (E & (A ^ B))) + 0x5A827999 + W[7];
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (A ^ (D & (E ^ A))) + 0x5A827999 + W[8];
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (E ^ (C & (D ^ E))) + 0x5A827999 + W[9];
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (D ^ (B & (C ^ D))) + 0x5A827999 + W[10];
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (C ^ (A & (B ^ C))) + 0x5A827999 + W[11];
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (B ^ (E & (A ^ B))) + 0x5A827999 + W[12];
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (A ^ (D & (E ^ A))) + 0x5A827999 + W[13];
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (E ^ (C & (D ^ E))) + 0x5A827999 + W[14];
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (D ^ (B & (C ^ D))) + 0x5A827999 + W[15];
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (C ^ (A & (B ^ C))) + 0x5A827999 + (temp = W[(16 - 3) & 0x0F] ^ W[(16 - 8) & 0x0F] ^ W[(16 - 14) & 0x0F] ^ W[16 & 0x0F], (W[16 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (B ^ (E & (A ^ B))) + 0x5A827999 + (temp = W[(17 - 3) & 0x0F] ^ W[(17 - 8) & 0x0F] ^ W[(17 - 14) & 0x0F] ^ W[17 & 0x0F], (W[17 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (A ^ (D & (E ^ A))) + 0x5A827999 + (temp = W[(18 - 3) & 0x0F] ^ W[(18 - 8) & 0x0F] ^ W[(18 - 14) & 0x0F] ^ W[18 & 0x0F], (W[18 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (E ^ (C & (D ^ E))) + 0x5A827999 + (temp = W[(19 - 3) & 0x0F] ^ W[(19 - 8) & 0x0F] ^ W[(19 - 14) & 0x0F] ^ W[19 & 0x0F], (W[19 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0x6ED9EBA1 + (temp = W[(20 - 3) & 0x0F] ^ W[(20 - 8) & 0x0F] ^ W[(20 - 14) & 0x0F] ^ W[20 & 0x0F], (W[20 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0x6ED9EBA1 + (temp = W[(21 - 3) & 0x0F] ^ W[(21 - 8) & 0x0F] ^ W[(21 - 14) & 0x0F] ^ W[21 & 0x0F], (W[21 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0x6ED9EBA1 + (temp = W[(22 - 3) & 0x0F] ^ W[(22 - 8) & 0x0F] ^ W[(22 - 14) & 0x0F] ^ W[22 & 0x0F], (W[22 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0x6ED9EBA1 + (temp = W[(23 - 3) & 0x0F] ^ W[(23 - 8) & 0x0F] ^ W[(23 - 14) & 0x0F] ^ W[23 & 0x0F], (W[23 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0x6ED9EBA1 + (temp = W[(24 - 3) & 0x0F] ^ W[(24 - 8) & 0x0F] ^ W[(24 - 14) & 0x0F] ^ W[24 & 0x0F], (W[24 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0x6ED9EBA1 + (temp = W[(25 - 3) & 0x0F] ^ W[(25 - 8) & 0x0F] ^ W[(25 - 14) & 0x0F] ^ W[25 & 0x0F], (W[25 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0x6ED9EBA1 + (temp = W[(26 - 3) & 0x0F] ^ W[(26 - 8) & 0x0F] ^ W[(26 - 14) & 0x0F] ^ W[26 & 0x0F], (W[26 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0x6ED9EBA1 + (temp = W[(27 - 3) & 0x0F] ^ W[(27 - 8) & 0x0F] ^ W[(27 - 14) & 0x0F] ^ W[27 & 0x0F], (W[27 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0x6ED9EBA1 + (temp = W[(28 - 3) & 0x0F] ^ W[(28 - 8) & 0x0F] ^ W[(28 - 14) & 0x0F] ^ W[28 & 0x0F], (W[28 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0x6ED9EBA1 + (temp = W[(29 - 3) & 0x0F] ^ W[(29 - 8) & 0x0F] ^ W[(29 - 14) & 0x0F] ^ W[29 & 0x0F], (W[29 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0x6ED9EBA1 + (temp = W[(30 - 3) & 0x0F] ^ W[(30 - 8) & 0x0F] ^ W[(30 - 14) & 0x0F] ^ W[30 & 0x0F], (W[30 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0x6ED9EBA1 + (temp = W[(31 - 3) & 0x0F] ^ W[(31 - 8) & 0x0F] ^ W[(31 - 14) & 0x0F] ^ W[31 & 0x0F], (W[31 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0x6ED9EBA1 + (temp = W[(32 - 3) & 0x0F] ^ W[(32 - 8) & 0x0F] ^ W[(32 - 14) & 0x0F] ^ W[32 & 0x0F], (W[32 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0x6ED9EBA1 + (temp = W[(33 - 3) & 0x0F] ^ W[(33 - 8) & 0x0F] ^ W[(33 - 14) & 0x0F] ^ W[33 & 0x0F], (W[33 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0x6ED9EBA1 + (temp = W[(34 - 3) & 0x0F] ^ W[(34 - 8) & 0x0F] ^ W[(34 - 14) & 0x0F] ^ W[34 & 0x0F], (W[34 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0x6ED9EBA1 + (temp = W[(35 - 3) & 0x0F] ^ W[(35 - 8) & 0x0F] ^ W[(35 - 14) & 0x0F] ^ W[35 & 0x0F], (W[35 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0x6ED9EBA1 + (temp = W[(36 - 3) & 0x0F] ^ W[(36 - 8) & 0x0F] ^ W[(36 - 14) & 0x0F] ^ W[36 & 0x0F], (W[36 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0x6ED9EBA1 + (temp = W[(37 - 3) & 0x0F] ^ W[(37 - 8) & 0x0F] ^ W[(37 - 14) & 0x0F] ^ W[37 & 0x0F], (W[37 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0x6ED9EBA1 + (temp = W[(38 - 3) & 0x0F] ^ W[(38 - 8) & 0x0F] ^ W[(38 - 14) & 0x0F] ^ W[38 & 0x0F], (W[38 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0x6ED9EBA1 + (temp = W[(39 - 3) & 0x0F] ^ W[(39 - 8) & 0x0F] ^ W[(39 - 14) & 0x0F] ^ W[39 & 0x0F], (W[39 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + ((B & C) | (D & (B | C))) + 0x8F1BBCDC + (temp = W[(40 - 3) & 0x0F] ^ W[(40 - 8) & 0x0F] ^ W[(40 - 14) & 0x0F] ^ W[40 & 0x0F], (W[40 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + ((A & B) | (C & (A | B))) + 0x8F1BBCDC + (temp = W[(41 - 3) & 0x0F] ^ W[(41 - 8) & 0x0F] ^ W[(41 - 14) & 0x0F] ^ W[41 & 0x0F], (W[41 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + ((E & A) | (B & (E | A))) + 0x8F1BBCDC + (temp = W[(42 - 3) & 0x0F] ^ W[(42 - 8) & 0x0F] ^ W[(42 - 14) & 0x0F] ^ W[42 & 0x0F], (W[42 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + ((D & E) | (A & (D | E))) + 0x8F1BBCDC + (temp = W[(43 - 3) & 0x0F] ^ W[(43 - 8) & 0x0F] ^ W[(43 - 14) & 0x0F] ^ W[43 & 0x0F], (W[43 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + ((C & D) | (E & (C | D))) + 0x8F1BBCDC + (temp = W[(44 - 3) & 0x0F] ^ W[(44 - 8) & 0x0F] ^ W[(44 - 14) & 0x0F] ^ W[44 & 0x0F], (W[44 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + ((B & C) | (D & (B | C))) + 0x8F1BBCDC + (temp = W[(45 - 3) & 0x0F] ^ W[(45 - 8) & 0x0F] ^ W[(45 - 14) & 0x0F] ^ W[45 & 0x0F], (W[45 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + ((A & B) | (C & (A | B))) + 0x8F1BBCDC + (temp = W[(46 - 3) & 0x0F] ^ W[(46 - 8) & 0x0F] ^ W[(46 - 14) & 0x0F] ^ W[46 & 0x0F], (W[46 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + ((E & A) | (B & (E | A))) + 0x8F1BBCDC + (temp = W[(47 - 3) & 0x0F] ^ W[(47 - 8) & 0x0F] ^ W[(47 - 14) & 0x0F] ^ W[47 & 0x0F], (W[47 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + ((D & E) | (A & (D | E))) + 0x8F1BBCDC + (temp = W[(48 - 3) & 0x0F] ^ W[(48 - 8) & 0x0F] ^ W[(48 - 14) & 0x0F] ^ W[48 & 0x0F], (W[48 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + ((C & D) | (E & (C | D))) + 0x8F1BBCDC + (temp = W[(49 - 3) & 0x0F] ^ W[(49 - 8) & 0x0F] ^ W[(49 - 14) & 0x0F] ^ W[49 & 0x0F], (W[49 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + ((B & C) | (D & (B | C))) + 0x8F1BBCDC + (temp = W[(50 - 3) & 0x0F] ^ W[(50 - 8) & 0x0F] ^ W[(50 - 14) & 0x0F] ^ W[50 & 0x0F], (W[50 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + ((A & B) | (C & (A | B))) + 0x8F1BBCDC + (temp = W[(51 - 3) & 0x0F] ^ W[(51 - 8) & 0x0F] ^ W[(51 - 14) & 0x0F] ^ W[51 & 0x0F], (W[51 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + ((E & A) | (B & (E | A))) + 0x8F1BBCDC + (temp = W[(52 - 3) & 0x0F] ^ W[(52 - 8) & 0x0F] ^ W[(52 - 14) & 0x0F] ^ W[52 & 0x0F], (W[52 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + ((D & E) | (A & (D | E))) + 0x8F1BBCDC + (temp = W[(53 - 3) & 0x0F] ^ W[(53 - 8) & 0x0F] ^ W[(53 - 14) & 0x0F] ^ W[53 & 0x0F], (W[53 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + ((C & D) | (E & (C | D))) + 0x8F1BBCDC + (temp = W[(54 - 3) & 0x0F] ^ W[(54 - 8) & 0x0F] ^ W[(54 - 14) & 0x0F] ^ W[54 & 0x0F], (W[54 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + ((B & C) | (D & (B | C))) + 0x8F1BBCDC + (temp = W[(55 - 3) & 0x0F] ^ W[(55 - 8) & 0x0F] ^ W[(55 - 14) & 0x0F] ^ W[55 & 0x0F], (W[55 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + ((A & B) | (C & (A | B))) + 0x8F1BBCDC + (temp = W[(56 - 3) & 0x0F] ^ W[(56 - 8) & 0x0F] ^ W[(56 - 14) & 0x0F] ^ W[56 & 0x0F], (W[56 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + ((E & A) | (B & (E | A))) + 0x8F1BBCDC + (temp = W[(57 - 3) & 0x0F] ^ W[(57 - 8) & 0x0F] ^ W[(57 - 14) & 0x0F] ^ W[57 & 0x0F], (W[57 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + ((D & E) | (A & (D | E))) + 0x8F1BBCDC + (temp = W[(58 - 3) & 0x0F] ^ W[(58 - 8) & 0x0F] ^ W[(58 - 14) & 0x0F] ^ W[58 & 0x0F], (W[58 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + ((C & D) | (E & (C | D))) + 0x8F1BBCDC + (temp = W[(59 - 3) & 0x0F] ^ W[(59 - 8) & 0x0F] ^ W[(59 - 14) & 0x0F] ^ W[59 & 0x0F], (W[59 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0xCA62C1D6 + (temp = W[(60 - 3) & 0x0F] ^ W[(60 - 8) & 0x0F] ^ W[(60 - 14) & 0x0F] ^ W[60 & 0x0F], (W[60 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0xCA62C1D6 + (temp = W[(61 - 3) & 0x0F] ^ W[(61 - 8) & 0x0F] ^ W[(61 - 14) & 0x0F] ^ W[61 & 0x0F], (W[61 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0xCA62C1D6 + (temp = W[(62 - 3) & 0x0F] ^ W[(62 - 8) & 0x0F] ^ W[(62 - 14) & 0x0F] ^ W[62 & 0x0F], (W[62 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0xCA62C1D6 + (temp = W[(63 - 3) & 0x0F] ^ W[(63 - 8) & 0x0F] ^ W[(63 - 14) & 0x0F] ^ W[63 & 0x0F], (W[63 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0xCA62C1D6 + (temp = W[(64 - 3) & 0x0F] ^ W[(64 - 8) & 0x0F] ^ W[(64 - 14) & 0x0F] ^ W[64 & 0x0F], (W[64 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0xCA62C1D6 + (temp = W[(65 - 3) & 0x0F] ^ W[(65 - 8) & 0x0F] ^ W[(65 - 14) & 0x0F] ^ W[65 & 0x0F], (W[65 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0xCA62C1D6 + (temp = W[(66 - 3) & 0x0F] ^ W[(66 - 8) & 0x0F] ^ W[(66 - 14) & 0x0F] ^ W[66 & 0x0F], (W[66 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0xCA62C1D6 + (temp = W[(67 - 3) & 0x0F] ^ W[(67 - 8) & 0x0F] ^ W[(67 - 14) & 0x0F] ^ W[67 & 0x0F], (W[67 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0xCA62C1D6 + (temp = W[(68 - 3) & 0x0F] ^ W[(68 - 8) & 0x0F] ^ W[(68 - 14) & 0x0F] ^ W[68 & 0x0F], (W[68 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0xCA62C1D6 + (temp = W[(69 - 3) & 0x0F] ^ W[(69 - 8) & 0x0F] ^ W[(69 - 14) & 0x0F] ^ W[69 & 0x0F], (W[69 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0xCA62C1D6 + (temp = W[(70 - 3) & 0x0F] ^ W[(70 - 8) & 0x0F] ^ W[(70 - 14) & 0x0F] ^ W[70 & 0x0F], (W[70 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0xCA62C1D6 + (temp = W[(71 - 3) & 0x0F] ^ W[(71 - 8) & 0x0F] ^ W[(71 - 14) & 0x0F] ^ W[71 & 0x0F], (W[71 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0xCA62C1D6 + (temp = W[(72 - 3) & 0x0F] ^ W[(72 - 8) & 0x0F] ^ W[(72 - 14) & 0x0F] ^ W[72 & 0x0F], (W[72 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0xCA62C1D6 + (temp = W[(73 - 3) & 0x0F] ^ W[(73 - 8) & 0x0F] ^ W[(73 - 14) & 0x0F] ^ W[73 & 0x0F], (W[73 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0xCA62C1D6 + (temp = W[(74 - 3) & 0x0F] ^ W[(74 - 8) & 0x0F] ^ W[(74 - 14) & 0x0F] ^ W[74 & 0x0F], (W[74 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		E += ((A << 5) | ((A & 0xFFFFFFFF) >> (32 - 5))) + (B ^ C ^ D) + 0xCA62C1D6 + (temp = W[(75 - 3) & 0x0F] ^ W[(75 - 8) & 0x0F] ^ W[(75 - 14) & 0x0F] ^ W[75 & 0x0F], (W[75 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		B = ((B << 30) | ((B & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		D += ((E << 5) | ((E & 0xFFFFFFFF) >> (32 - 5))) + (A ^ B ^ C) + 0xCA62C1D6 + (temp = W[(76 - 3) & 0x0F] ^ W[(76 - 8) & 0x0F] ^ W[(76 - 14) & 0x0F] ^ W[76 & 0x0F], (W[76 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		A = ((A << 30) | ((A & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		C += ((D << 5) | ((D & 0xFFFFFFFF) >> (32 - 5))) + (E ^ A ^ B) + 0xCA62C1D6 + (temp = W[(77 - 3) & 0x0F] ^ W[(77 - 8) & 0x0F] ^ W[(77 - 14) & 0x0F] ^ W[77 & 0x0F], (W[77 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		E = ((E << 30) | ((E & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		B += ((C << 5) | ((C & 0xFFFFFFFF) >> (32 - 5))) + (D ^ E ^ A) + 0xCA62C1D6 + (temp = W[(78 - 3) & 0x0F] ^ W[(78 - 8) & 0x0F] ^ W[(78 - 14) & 0x0F] ^ W[78 & 0x0F], (W[78 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		D = ((D << 30) | ((D & 0xFFFFFFFF) >> (32 - 30)));
	};
	{
		A += ((B << 5) | ((B & 0xFFFFFFFF) >> (32 - 5))) + (C ^ D ^ E) + 0xCA62C1D6 + (temp = W[(79 - 3) & 0x0F] ^ W[(79 - 8) & 0x0F] ^ W[(79 - 14) & 0x0F] ^ W[79 & 0x0F], (W[79 & 0x0F] = ((temp << 1) | ((temp & 0xFFFFFFFF) >> (32 - 1)))));
		C = ((C << 30) | ((C & 0xFFFFFFFF) >> (32 - 30)));
	};
	ctx.state[0] += A;
	ctx.state[1] += B;
	ctx.state[2] += C;
	ctx.state[3] += D;
	ctx.state[4] += E;
}

pub fn mbedtls_sha1_update(mbedtls_sha1_context * ctx, const u8 * input, usize ilen)
{
	usize fill;
	u32 left;
	if ilen == 0
	{
		return;
	}
	left = ctx.total[0] & 0x3F;
	fill = 64 - left;
	ctx.total[0] += (u32) ilen;
	ctx.total[0] &= 0xFFFFFFFF;
	if ctx.total[0] < (u32) ilen
	{
		ctx.total[1]++;
	}
	if left && ilen >= fill
	{
		memcpy((void *) (ctx.buffer + left), input, fill);
		mbedtls_sha1_process(ctx, ctx.buffer);
		input += fill;
		ilen -= fill;
		left = 0;
	}
	while (ilen >= 64)
	{
		mbedtls_sha1_process(ctx, input);
		input += 64;
		ilen -= 64;
	}
	if ilen > 0
	{
		memcpy((void *) (ctx.buffer + left), input, ilen);
	}
}

static const u8 sha1_padding[64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
pub fn mbedtls_sha1_finish(mbedtls_sha1_context * ctx, u8 output[20])
{
	u32 last, padn;
	u32 high, low;
	u8 msglen[8];
	high = (ctx.total[0] >> 29) | (ctx.total[1] << 3);
	low = (ctx.total[0] << 3);
	{
		(msglen)[(0)] = (i8) ((high) >> 24);
		(msglen)[(0) + 1] = (i8) ((high) >> 16);
		(msglen)[(0) + 2] = (i8) ((high) >> 8);
		(msglen)[(0) + 3] = (i8) ((high));
	};
	{
		(msglen)[(4)] = (i8) ((low) >> 24);
		(msglen)[(4) + 1] = (i8) ((low) >> 16);
		(msglen)[(4) + 2] = (i8) ((low) >> 8);
		(msglen)[(4) + 3] = (i8) ((low));
	};
	last = ctx.total[0] & 0x3F;
	padn = (last < 56) ? (56 - last) : (120 - last);
	mbedtls_sha1_update(ctx, sha1_padding, padn);
	mbedtls_sha1_update(ctx, msglen, 8);
	{
		(output)[(0)] = (i8) ((ctx.state[0]) >> 24);
		(output)[(0) + 1] = (i8) ((ctx.state[0]) >> 16);
		(output)[(0) + 2] = (i8) ((ctx.state[0]) >> 8);
		(output)[(0) + 3] = (i8) ((ctx.state[0]));
	};
	{
		(output)[(4)] = (i8) ((ctx.state[1]) >> 24);
		(output)[(4) + 1] = (i8) ((ctx.state[1]) >> 16);
		(output)[(4) + 2] = (i8) ((ctx.state[1]) >> 8);
		(output)[(4) + 3] = (i8) ((ctx.state[1]));
	};
	{
		(output)[(8)] = (i8) ((ctx.state[2]) >> 24);
		(output)[(8) + 1] = (i8) ((ctx.state[2]) >> 16);
		(output)[(8) + 2] = (i8) ((ctx.state[2]) >> 8);
		(output)[(8) + 3] = (i8) ((ctx.state[2]));
	};
	{
		(output)[(12)] = (i8) ((ctx.state[3]) >> 24);
		(output)[(12) + 1] = (i8) ((ctx.state[3]) >> 16);
		(output)[(12) + 2] = (i8) ((ctx.state[3]) >> 8);
		(output)[(12) + 3] = (i8) ((ctx.state[3]));
	};
	{
		(output)[(16)] = (i8) ((ctx.state[4]) >> 24);
		(output)[(16) + 1] = (i8) ((ctx.state[4]) >> 16);
		(output)[(16) + 2] = (i8) ((ctx.state[4]) >> 8);
		(output)[(16) + 3] = (i8) ((ctx.state[4]));
	};
}

pub fn mbedtls_sha1(const u8 * input, usize ilen, u8 output[20])
{
	mbedtls_sha1_context ctx;
	mbedtls_sha1_init(&ctx);
	mbedtls_sha1_starts(&ctx);
	mbedtls_sha1_update(&ctx, input, ilen);
	mbedtls_sha1_finish(&ctx, output);
	mbedtls_sha1_free(&ctx);
}

static const u8 sha1_test_buf[3][57] = {{"abc"}, {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"}, {""}};
static const i32 sha1_test_buflen[3] = {3, 56, 1000};
static const u8 sha1_test_sum[3][20] = {{0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E, 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D}, {0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE, 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1}, {0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E, 0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F}};
pub fn mbedtls_sha1_self_test(i32 verbose) -> i32
{
	i32 i, j, buflen, ret = 0;
	u8 buf[1024];
	u8 sha1sum[20];
	mbedtls_sha1_context ctx;
	mbedtls_sha1_init(&ctx);
	for (i = 0; i < 3; i++)
	{
		if verbose != 0
		{
			printf("  SHA-1 test #%d: ", i + 1);
		}
		mbedtls_sha1_starts(&ctx);
		if i == 2
		{
			memset(buf, 'a', buflen = 1000);
			for (j = 0; j < 1000; j++)
			{
				mbedtls_sha1_update(&ctx, buf, buflen);
			}
		}
		else
		{
			mbedtls_sha1_update(&ctx, sha1_test_buf[i], sha1_test_buflen[i]);
		}
		mbedtls_sha1_finish(&ctx, sha1sum);
		if memcmp(sha1sum, sha1_test_sum[i], 20) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			ret = 1;
			goto exit;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
exit:
	mbedtls_sha1_free(&ctx);
	return ret;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_sha256_init(mbedtls_sha256_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_sha256_context));
}

pub fn mbedtls_sha256_free(mbedtls_sha256_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_sha256_context));
}

pub fn mbedtls_sha256_clone(mbedtls_sha256_context * dst, const mbedtls_sha256_context * src)
{
	*dst = *src;
}

pub fn mbedtls_sha256_starts(mbedtls_sha256_context * ctx, i32 is224)
{
	ctx.total[0] = 0;
	ctx.total[1] = 0;
	if is224 == 0
	{
		ctx.state[0] = 0x6A09E667;
		ctx.state[1] = 0xBB67AE85;
		ctx.state[2] = 0x3C6EF372;
		ctx.state[3] = 0xA54FF53A;
		ctx.state[4] = 0x510E527F;
		ctx.state[5] = 0x9B05688C;
		ctx.state[6] = 0x1F83D9AB;
		ctx.state[7] = 0x5BE0CD19;
	}
	else
	{
		ctx.state[0] = 0xC1059ED8;
		ctx.state[1] = 0x367CD507;
		ctx.state[2] = 0x3070DD17;
		ctx.state[3] = 0xF70E5939;
		ctx.state[4] = 0xFFC00B31;
		ctx.state[5] = 0x68581511;
		ctx.state[6] = 0x64F98FA7;
		ctx.state[7] = 0xBEFA4FA4;
	}
	ctx.is224 = is224;
}

static const u32 K[] =
{
	0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2,
};
pub fn mbedtls_sha256_process(mbedtls_sha256_context * ctx, const u8 data[64])
{
	u32 temp1, temp2, W[64];
	u32 A[8];
	u32 i;
	for (i = 0; i < 8; i++)
	{
		A[i] = ctx.state[i];
	}
	for (i = 0; i < 16; i++)
	{
		(W[i]) = ((u32)(data)[(4 * i)] << 24) | ((u32)(data)[(4 * i) + 1] << 16) | ((u32)(data)[(4 * i) + 2] << 8) | ((u32)(data)[(4 * i) + 3]);
	};
	for (i = 0; i < 16; i += 8)
	{
		{
			temp1 = A[7] + ((((A[4] & 0xFFFFFFFF) >> 6) | (A[4] << (32 - 6))) ^ (((A[4] & 0xFFFFFFFF) >> 11) | (A[4] << (32 - 11))) ^ (((A[4] & 0xFFFFFFFF) >> 25) | (A[4] << (32 - 25)))) + (A[6] ^ (A[4] & (A[5] ^ A[6]))) + K[i + 0] + W[i + 0];
			temp2 = ((((A[0] & 0xFFFFFFFF) >> 2) | (A[0] << (32 - 2))) ^ (((A[0] & 0xFFFFFFFF) >> 13) | (A[0] << (32 - 13))) ^ (((A[0] & 0xFFFFFFFF) >> 22) | (A[0] << (32 - 22)))) + ((A[0] & A[1]) | (A[2] & (A[0] | A[1])));
			A[3] += temp1;
			A[7] = temp1 + temp2;
		};
		{
			temp1 = A[6] + ((((A[3] & 0xFFFFFFFF) >> 6) | (A[3] << (32 - 6))) ^ (((A[3] & 0xFFFFFFFF) >> 11) | (A[3] << (32 - 11))) ^ (((A[3] & 0xFFFFFFFF) >> 25) | (A[3] << (32 - 25)))) + (A[5] ^ (A[3] & (A[4] ^ A[5]))) + K[i + 1] + W[i + 1];
			temp2 = ((((A[7] & 0xFFFFFFFF) >> 2) | (A[7] << (32 - 2))) ^ (((A[7] & 0xFFFFFFFF) >> 13) | (A[7] << (32 - 13))) ^ (((A[7] & 0xFFFFFFFF) >> 22) | (A[7] << (32 - 22)))) + ((A[7] & A[0]) | (A[1] & (A[7] | A[0])));
			A[2] += temp1;
			A[6] = temp1 + temp2;
		};
		{
			temp1 = A[5] + ((((A[2] & 0xFFFFFFFF) >> 6) | (A[2] << (32 - 6))) ^ (((A[2] & 0xFFFFFFFF) >> 11) | (A[2] << (32 - 11))) ^ (((A[2] & 0xFFFFFFFF) >> 25) | (A[2] << (32 - 25)))) + (A[4] ^ (A[2] & (A[3] ^ A[4]))) + K[i + 2] + W[i + 2];
			temp2 = ((((A[6] & 0xFFFFFFFF) >> 2) | (A[6] << (32 - 2))) ^ (((A[6] & 0xFFFFFFFF) >> 13) | (A[6] << (32 - 13))) ^ (((A[6] & 0xFFFFFFFF) >> 22) | (A[6] << (32 - 22)))) + ((A[6] & A[7]) | (A[0] & (A[6] | A[7])));
			A[1] += temp1;
			A[5] = temp1 + temp2;
		};
		{
			temp1 = A[4] + ((((A[1] & 0xFFFFFFFF) >> 6) | (A[1] << (32 - 6))) ^ (((A[1] & 0xFFFFFFFF) >> 11) | (A[1] << (32 - 11))) ^ (((A[1] & 0xFFFFFFFF) >> 25) | (A[1] << (32 - 25)))) + (A[3] ^ (A[1] & (A[2] ^ A[3]))) + K[i + 3] + W[i + 3];
			temp2 = ((((A[5] & 0xFFFFFFFF) >> 2) | (A[5] << (32 - 2))) ^ (((A[5] & 0xFFFFFFFF) >> 13) | (A[5] << (32 - 13))) ^ (((A[5] & 0xFFFFFFFF) >> 22) | (A[5] << (32 - 22)))) + ((A[5] & A[6]) | (A[7] & (A[5] | A[6])));
			A[0] += temp1;
			A[4] = temp1 + temp2;
		};
		{
			temp1 = A[3] + ((((A[0] & 0xFFFFFFFF) >> 6) | (A[0] << (32 - 6))) ^ (((A[0] & 0xFFFFFFFF) >> 11) | (A[0] << (32 - 11))) ^ (((A[0] & 0xFFFFFFFF) >> 25) | (A[0] << (32 - 25)))) + (A[2] ^ (A[0] & (A[1] ^ A[2]))) + K[i + 4] + W[i + 4];
			temp2 = ((((A[4] & 0xFFFFFFFF) >> 2) | (A[4] << (32 - 2))) ^ (((A[4] & 0xFFFFFFFF) >> 13) | (A[4] << (32 - 13))) ^ (((A[4] & 0xFFFFFFFF) >> 22) | (A[4] << (32 - 22)))) + ((A[4] & A[5]) | (A[6] & (A[4] | A[5])));
			A[7] += temp1;
			A[3] = temp1 + temp2;
		};
		{
			temp1 = A[2] + ((((A[7] & 0xFFFFFFFF) >> 6) | (A[7] << (32 - 6))) ^ (((A[7] & 0xFFFFFFFF) >> 11) | (A[7] << (32 - 11))) ^ (((A[7] & 0xFFFFFFFF) >> 25) | (A[7] << (32 - 25)))) + (A[1] ^ (A[7] & (A[0] ^ A[1]))) + K[i + 5] + W[i + 5];
			temp2 = ((((A[3] & 0xFFFFFFFF) >> 2) | (A[3] << (32 - 2))) ^ (((A[3] & 0xFFFFFFFF) >> 13) | (A[3] << (32 - 13))) ^ (((A[3] & 0xFFFFFFFF) >> 22) | (A[3] << (32 - 22)))) + ((A[3] & A[4]) | (A[5] & (A[3] | A[4])));
			A[6] += temp1;
			A[2] = temp1 + temp2;
		};
		{
			temp1 = A[1] + ((((A[6] & 0xFFFFFFFF) >> 6) | (A[6] << (32 - 6))) ^ (((A[6] & 0xFFFFFFFF) >> 11) | (A[6] << (32 - 11))) ^ (((A[6] & 0xFFFFFFFF) >> 25) | (A[6] << (32 - 25)))) + (A[0] ^ (A[6] & (A[7] ^ A[0]))) + K[i + 6] + W[i + 6];
			temp2 = ((((A[2] & 0xFFFFFFFF) >> 2) | (A[2] << (32 - 2))) ^ (((A[2] & 0xFFFFFFFF) >> 13) | (A[2] << (32 - 13))) ^ (((A[2] & 0xFFFFFFFF) >> 22) | (A[2] << (32 - 22)))) + ((A[2] & A[3]) | (A[4] & (A[2] | A[3])));
			A[5] += temp1;
			A[1] = temp1 + temp2;
		};
		{
			temp1 = A[0] + ((((A[5] & 0xFFFFFFFF) >> 6) | (A[5] << (32 - 6))) ^ (((A[5] & 0xFFFFFFFF) >> 11) | (A[5] << (32 - 11))) ^ (((A[5] & 0xFFFFFFFF) >> 25) | (A[5] << (32 - 25)))) + (A[7] ^ (A[5] & (A[6] ^ A[7]))) + K[i + 7] + W[i + 7];
			temp2 = ((((A[1] & 0xFFFFFFFF) >> 2) | (A[1] << (32 - 2))) ^ (((A[1] & 0xFFFFFFFF) >> 13) | (A[1] << (32 - 13))) ^ (((A[1] & 0xFFFFFFFF) >> 22) | (A[1] << (32 - 22)))) + ((A[1] & A[2]) | (A[3] & (A[1] | A[2])));
			A[4] += temp1;
			A[0] = temp1 + temp2;
		};
	}
	for (i = 16; i < 64; i += 8)
	{
		{
			temp1 = A[7] + ((((A[4] & 0xFFFFFFFF) >> 6) | (A[4] << (32 - 6))) ^ (((A[4] & 0xFFFFFFFF) >> 11) | (A[4] << (32 - 11))) ^ (((A[4] & 0xFFFFFFFF) >> 25) | (A[4] << (32 - 25)))) + (A[6] ^ (A[4] & (A[5] ^ A[6]))) + K[i + 0] + (W[i + 0] = ((((W[i + 0 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 0 - 2] << (32 - 17))) ^ (((W[i + 0 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 0 - 2] << (32 - 19))) ^ ((W[i + 0 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 0 - 7] + ((((W[i + 0 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 0 - 15] << (32 - 7))) ^ (((W[i + 0 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 0 - 15] << (32 - 18))) ^ ((W[i + 0 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 0 - 16]);
			temp2 = ((((A[0] & 0xFFFFFFFF) >> 2) | (A[0] << (32 - 2))) ^ (((A[0] & 0xFFFFFFFF) >> 13) | (A[0] << (32 - 13))) ^ (((A[0] & 0xFFFFFFFF) >> 22) | (A[0] << (32 - 22)))) + ((A[0] & A[1]) | (A[2] & (A[0] | A[1])));
			A[3] += temp1;
			A[7] = temp1 + temp2;
		};
		{
			temp1 = A[6] + ((((A[3] & 0xFFFFFFFF) >> 6) | (A[3] << (32 - 6))) ^ (((A[3] & 0xFFFFFFFF) >> 11) | (A[3] << (32 - 11))) ^ (((A[3] & 0xFFFFFFFF) >> 25) | (A[3] << (32 - 25)))) + (A[5] ^ (A[3] & (A[4] ^ A[5]))) + K[i + 1] + (W[i + 1] = ((((W[i + 1 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 1 - 2] << (32 - 17))) ^ (((W[i + 1 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 1 - 2] << (32 - 19))) ^ ((W[i + 1 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 1 - 7] + ((((W[i + 1 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 1 - 15] << (32 - 7))) ^ (((W[i + 1 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 1 - 15] << (32 - 18))) ^ ((W[i + 1 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 1 - 16]);
			temp2 = ((((A[7] & 0xFFFFFFFF) >> 2) | (A[7] << (32 - 2))) ^ (((A[7] & 0xFFFFFFFF) >> 13) | (A[7] << (32 - 13))) ^ (((A[7] & 0xFFFFFFFF) >> 22) | (A[7] << (32 - 22)))) + ((A[7] & A[0]) | (A[1] & (A[7] | A[0])));
			A[2] += temp1;
			A[6] = temp1 + temp2;
		};
		{
			temp1 = A[5] + ((((A[2] & 0xFFFFFFFF) >> 6) | (A[2] << (32 - 6))) ^ (((A[2] & 0xFFFFFFFF) >> 11) | (A[2] << (32 - 11))) ^ (((A[2] & 0xFFFFFFFF) >> 25) | (A[2] << (32 - 25)))) + (A[4] ^ (A[2] & (A[3] ^ A[4]))) + K[i + 2] + (W[i + 2] = ((((W[i + 2 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 2 - 2] << (32 - 17))) ^ (((W[i + 2 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 2 - 2] << (32 - 19))) ^ ((W[i + 2 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 2 - 7] + ((((W[i + 2 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 2 - 15] << (32 - 7))) ^ (((W[i + 2 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 2 - 15] << (32 - 18))) ^ ((W[i + 2 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 2 - 16]);
			temp2 = ((((A[6] & 0xFFFFFFFF) >> 2) | (A[6] << (32 - 2))) ^ (((A[6] & 0xFFFFFFFF) >> 13) | (A[6] << (32 - 13))) ^ (((A[6] & 0xFFFFFFFF) >> 22) | (A[6] << (32 - 22)))) + ((A[6] & A[7]) | (A[0] & (A[6] | A[7])));
			A[1] += temp1;
			A[5] = temp1 + temp2;
		};
		{
			temp1 = A[4] + ((((A[1] & 0xFFFFFFFF) >> 6) | (A[1] << (32 - 6))) ^ (((A[1] & 0xFFFFFFFF) >> 11) | (A[1] << (32 - 11))) ^ (((A[1] & 0xFFFFFFFF) >> 25) | (A[1] << (32 - 25)))) + (A[3] ^ (A[1] & (A[2] ^ A[3]))) + K[i + 3] + (W[i + 3] = ((((W[i + 3 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 3 - 2] << (32 - 17))) ^ (((W[i + 3 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 3 - 2] << (32 - 19))) ^ ((W[i + 3 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 3 - 7] + ((((W[i + 3 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 3 - 15] << (32 - 7))) ^ (((W[i + 3 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 3 - 15] << (32 - 18))) ^ ((W[i + 3 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 3 - 16]);
			temp2 = ((((A[5] & 0xFFFFFFFF) >> 2) | (A[5] << (32 - 2))) ^ (((A[5] & 0xFFFFFFFF) >> 13) | (A[5] << (32 - 13))) ^ (((A[5] & 0xFFFFFFFF) >> 22) | (A[5] << (32 - 22)))) + ((A[5] & A[6]) | (A[7] & (A[5] | A[6])));
			A[0] += temp1;
			A[4] = temp1 + temp2;
		};
		{
			temp1 = A[3] + ((((A[0] & 0xFFFFFFFF) >> 6) | (A[0] << (32 - 6))) ^ (((A[0] & 0xFFFFFFFF) >> 11) | (A[0] << (32 - 11))) ^ (((A[0] & 0xFFFFFFFF) >> 25) | (A[0] << (32 - 25)))) + (A[2] ^ (A[0] & (A[1] ^ A[2]))) + K[i + 4] + (W[i + 4] = ((((W[i + 4 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 4 - 2] << (32 - 17))) ^ (((W[i + 4 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 4 - 2] << (32 - 19))) ^ ((W[i + 4 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 4 - 7] + ((((W[i + 4 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 4 - 15] << (32 - 7))) ^ (((W[i + 4 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 4 - 15] << (32 - 18))) ^ ((W[i + 4 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 4 - 16]);
			temp2 = ((((A[4] & 0xFFFFFFFF) >> 2) | (A[4] << (32 - 2))) ^ (((A[4] & 0xFFFFFFFF) >> 13) | (A[4] << (32 - 13))) ^ (((A[4] & 0xFFFFFFFF) >> 22) | (A[4] << (32 - 22)))) + ((A[4] & A[5]) | (A[6] & (A[4] | A[5])));
			A[7] += temp1;
			A[3] = temp1 + temp2;
		};
		{
			temp1 = A[2] + ((((A[7] & 0xFFFFFFFF) >> 6) | (A[7] << (32 - 6))) ^ (((A[7] & 0xFFFFFFFF) >> 11) | (A[7] << (32 - 11))) ^ (((A[7] & 0xFFFFFFFF) >> 25) | (A[7] << (32 - 25)))) + (A[1] ^ (A[7] & (A[0] ^ A[1]))) + K[i + 5] + (W[i + 5] = ((((W[i + 5 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 5 - 2] << (32 - 17))) ^ (((W[i + 5 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 5 - 2] << (32 - 19))) ^ ((W[i + 5 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 5 - 7] + ((((W[i + 5 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 5 - 15] << (32 - 7))) ^ (((W[i + 5 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 5 - 15] << (32 - 18))) ^ ((W[i + 5 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 5 - 16]);
			temp2 = ((((A[3] & 0xFFFFFFFF) >> 2) | (A[3] << (32 - 2))) ^ (((A[3] & 0xFFFFFFFF) >> 13) | (A[3] << (32 - 13))) ^ (((A[3] & 0xFFFFFFFF) >> 22) | (A[3] << (32 - 22)))) + ((A[3] & A[4]) | (A[5] & (A[3] | A[4])));
			A[6] += temp1;
			A[2] = temp1 + temp2;
		};
		{
			temp1 = A[1] + ((((A[6] & 0xFFFFFFFF) >> 6) | (A[6] << (32 - 6))) ^ (((A[6] & 0xFFFFFFFF) >> 11) | (A[6] << (32 - 11))) ^ (((A[6] & 0xFFFFFFFF) >> 25) | (A[6] << (32 - 25)))) + (A[0] ^ (A[6] & (A[7] ^ A[0]))) + K[i + 6] + (W[i + 6] = ((((W[i + 6 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 6 - 2] << (32 - 17))) ^ (((W[i + 6 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 6 - 2] << (32 - 19))) ^ ((W[i + 6 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 6 - 7] + ((((W[i + 6 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 6 - 15] << (32 - 7))) ^ (((W[i + 6 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 6 - 15] << (32 - 18))) ^ ((W[i + 6 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 6 - 16]);
			temp2 = ((((A[2] & 0xFFFFFFFF) >> 2) | (A[2] << (32 - 2))) ^ (((A[2] & 0xFFFFFFFF) >> 13) | (A[2] << (32 - 13))) ^ (((A[2] & 0xFFFFFFFF) >> 22) | (A[2] << (32 - 22)))) + ((A[2] & A[3]) | (A[4] & (A[2] | A[3])));
			A[5] += temp1;
			A[1] = temp1 + temp2;
		};
		{
			temp1 = A[0] + ((((A[5] & 0xFFFFFFFF) >> 6) | (A[5] << (32 - 6))) ^ (((A[5] & 0xFFFFFFFF) >> 11) | (A[5] << (32 - 11))) ^ (((A[5] & 0xFFFFFFFF) >> 25) | (A[5] << (32 - 25)))) + (A[7] ^ (A[5] & (A[6] ^ A[7]))) + K[i + 7] + (W[i + 7] = ((((W[i + 7 - 2] & 0xFFFFFFFF) >> 17) | (W[i + 7 - 2] << (32 - 17))) ^ (((W[i + 7 - 2] & 0xFFFFFFFF) >> 19) | (W[i + 7 - 2] << (32 - 19))) ^ ((W[i + 7 - 2] & 0xFFFFFFFF) >> 10)) + W[i + 7 - 7] + ((((W[i + 7 - 15] & 0xFFFFFFFF) >> 7) | (W[i + 7 - 15] << (32 - 7))) ^ (((W[i + 7 - 15] & 0xFFFFFFFF) >> 18) | (W[i + 7 - 15] << (32 - 18))) ^ ((W[i + 7 - 15] & 0xFFFFFFFF) >> 3)) + W[i + 7 - 16]);
			temp2 = ((((A[1] & 0xFFFFFFFF) >> 2) | (A[1] << (32 - 2))) ^ (((A[1] & 0xFFFFFFFF) >> 13) | (A[1] << (32 - 13))) ^ (((A[1] & 0xFFFFFFFF) >> 22) | (A[1] << (32 - 22)))) + ((A[1] & A[2]) | (A[3] & (A[1] | A[2])));
			A[4] += temp1;
			A[0] = temp1 + temp2;
		};
	}
	for (i = 0; i < 8; i++)
	{
		ctx.state[i] += A[i];
	}
}

pub fn mbedtls_sha256_update(mbedtls_sha256_context * ctx, const u8 * input, usize ilen)
{
	usize fill;
	u32 left;
	if ilen == 0
	{
		return;
	}
	left = ctx.total[0] & 0x3F;
	fill = 64 - left;
	ctx.total[0] += (u32) ilen;
	ctx.total[0] &= 0xFFFFFFFF;
	if ctx.total[0] < (u32) ilen
	{
		ctx.total[1]++;
	}
	if left && ilen >= fill
	{
		memcpy((void *) (ctx.buffer + left), input, fill);
		mbedtls_sha256_process(ctx, ctx.buffer);
		input += fill;
		ilen -= fill;
		left = 0;
	}
	while (ilen >= 64)
	{
		mbedtls_sha256_process(ctx, input);
		input += 64;
		ilen -= 64;
	}
	if ilen > 0
	{
		memcpy((void *) (ctx.buffer + left), input, ilen);
	}
}

static const u8 sha256_padding[64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
pub fn mbedtls_sha256_finish(mbedtls_sha256_context * ctx, u8 output[32])
{
	u32 last, padn;
	u32 high, low;
	u8 msglen[8];
	high = (ctx.total[0] >> 29) | (ctx.total[1] << 3);
	low = (ctx.total[0] << 3);
	{
		(msglen)[(0)] = (i8) ((high) >> 24);
		(msglen)[(0) + 1] = (i8) ((high) >> 16);
		(msglen)[(0) + 2] = (i8) ((high) >> 8);
		(msglen)[(0) + 3] = (i8) ((high));
	};
	{
		(msglen)[(4)] = (i8) ((low) >> 24);
		(msglen)[(4) + 1] = (i8) ((low) >> 16);
		(msglen)[(4) + 2] = (i8) ((low) >> 8);
		(msglen)[(4) + 3] = (i8) ((low));
	};
	last = ctx.total[0] & 0x3F;
	padn = (last < 56) ? (56 - last) : (120 - last);
	mbedtls_sha256_update(ctx, sha256_padding, padn);
	mbedtls_sha256_update(ctx, msglen, 8);
	{
		(output)[(0)] = (i8) ((ctx.state[0]) >> 24);
		(output)[(0) + 1] = (i8) ((ctx.state[0]) >> 16);
		(output)[(0) + 2] = (i8) ((ctx.state[0]) >> 8);
		(output)[(0) + 3] = (i8) ((ctx.state[0]));
	};
	{
		(output)[(4)] = (i8) ((ctx.state[1]) >> 24);
		(output)[(4) + 1] = (i8) ((ctx.state[1]) >> 16);
		(output)[(4) + 2] = (i8) ((ctx.state[1]) >> 8);
		(output)[(4) + 3] = (i8) ((ctx.state[1]));
	};
	{
		(output)[(8)] = (i8) ((ctx.state[2]) >> 24);
		(output)[(8) + 1] = (i8) ((ctx.state[2]) >> 16);
		(output)[(8) + 2] = (i8) ((ctx.state[2]) >> 8);
		(output)[(8) + 3] = (i8) ((ctx.state[2]));
	};
	{
		(output)[(12)] = (i8) ((ctx.state[3]) >> 24);
		(output)[(12) + 1] = (i8) ((ctx.state[3]) >> 16);
		(output)[(12) + 2] = (i8) ((ctx.state[3]) >> 8);
		(output)[(12) + 3] = (i8) ((ctx.state[3]));
	};
	{
		(output)[(16)] = (i8) ((ctx.state[4]) >> 24);
		(output)[(16) + 1] = (i8) ((ctx.state[4]) >> 16);
		(output)[(16) + 2] = (i8) ((ctx.state[4]) >> 8);
		(output)[(16) + 3] = (i8) ((ctx.state[4]));
	};
	{
		(output)[(20)] = (i8) ((ctx.state[5]) >> 24);
		(output)[(20) + 1] = (i8) ((ctx.state[5]) >> 16);
		(output)[(20) + 2] = (i8) ((ctx.state[5]) >> 8);
		(output)[(20) + 3] = (i8) ((ctx.state[5]));
	};
	{
		(output)[(24)] = (i8) ((ctx.state[6]) >> 24);
		(output)[(24) + 1] = (i8) ((ctx.state[6]) >> 16);
		(output)[(24) + 2] = (i8) ((ctx.state[6]) >> 8);
		(output)[(24) + 3] = (i8) ((ctx.state[6]));
	};
	if ctx.is224 == 0
	{
		(output)[(28)] = (i8) ((ctx.state[7]) >> 24);
		(output)[(28) + 1] = (i8) ((ctx.state[7]) >> 16);
		(output)[(28) + 2] = (i8) ((ctx.state[7]) >> 8);
		(output)[(28) + 3] = (i8) ((ctx.state[7]));
	};
}

pub fn mbedtls_sha256(const u8 * input, usize ilen, u8 output[32], i32 is224)
{
	mbedtls_sha256_context ctx;
	mbedtls_sha256_init(&ctx);
	mbedtls_sha256_starts(&ctx, is224);
	mbedtls_sha256_update(&ctx, input, ilen);
	mbedtls_sha256_finish(&ctx, output);
	mbedtls_sha256_free(&ctx);
}

static const u8 sha256_test_buf[3][57] = {{"abc"}, {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"}, {""}};
static const i32 sha256_test_buflen[3] = {3, 56, 1000};
static const u8 sha256_test_sum[6][32] = {{0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22, 0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3, 0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7, 0xE3, 0x6C, 0x9D, 0xA7}, {0x75, 0x38, 0x8B, 0x16, 0x51, 0x27, 0x76, 0xCC, 0x5D, 0xBA, 0x5D, 0xA1, 0xFD, 0x89, 0x01, 0x50, 0xB0, 0xC6, 0x45, 0x5C, 0xB4, 0xF5, 0x8B, 0x19, 0x52, 0x52, 0x25, 0x25}, {0x20, 0x79, 0x46, 0x55, 0x98, 0x0C, 0x91, 0xD8, 0xBB, 0xB4, 0xC1, 0xEA, 0x97, 0x61, 0x8A, 0x4B, 0xF0, 0x3F, 0x42, 0x58, 0x19, 0x48, 0xB2, 0xEE, 0x4E, 0xE7, 0xAD, 0x67}, {0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA, 0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23, 0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C, 0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD}, {0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8, 0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39, 0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67, 0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1}, {0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92, 0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67, 0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E, 0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0}};
pub fn mbedtls_sha256_self_test(i32 verbose) -> i32
{
	i32 i, j, k, buflen, ret = 0;
	u8 buf[1024];
	u8 sha256sum[32];
	mbedtls_sha256_context ctx;
	mbedtls_sha256_init(&ctx);
	for (i = 0; i < 6; i++)
	{
		j = i % 3;
		k = i < 3;
		if verbose != 0
		{
			printf("  SHA-%d test #%d: ", 256 - k * 32, j + 1);
		}
		mbedtls_sha256_starts(&ctx, k);
		if j == 2
		{
			memset(buf, 'a', buflen = 1000);
			for (j = 0; j < 1000; j++)
			{
				mbedtls_sha256_update(&ctx, buf, buflen);
			}
		}
		else
		{
			mbedtls_sha256_update(&ctx, sha256_test_buf[j], sha256_test_buflen[j]);
		}
		mbedtls_sha256_finish(&ctx, sha256sum);
		if memcmp(sha256sum, sha256_test_sum[i], 32 - k * 4) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			ret = 1;
			goto exit;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
exit:
	mbedtls_sha256_free(&ctx);
	return ret;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_sha512_init(mbedtls_sha512_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_sha512_context));
}

pub fn mbedtls_sha512_free(mbedtls_sha512_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_sha512_context));
}

pub fn mbedtls_sha512_clone(mbedtls_sha512_context * dst, const mbedtls_sha512_context * src)
{
	*dst = *src;
}

pub fn mbedtls_sha512_starts(mbedtls_sha512_context * ctx, i32 is384)
{
	ctx.total[0] = 0;
	ctx.total[1] = 0;
	if is384 == 0
	{
		ctx.state[0] = 0x6A09E667F3BCC908ULL;
		ctx.state[1] = 0xBB67AE8584CAA73BULL;
		ctx.state[2] = 0x3C6EF372FE94F82BULL;
		ctx.state[3] = 0xA54FF53A5F1D36F1ULL;
		ctx.state[4] = 0x510E527FADE682D1ULL;
		ctx.state[5] = 0x9B05688C2B3E6C1FULL;
		ctx.state[6] = 0x1F83D9ABFB41BD6BULL;
		ctx.state[7] = 0x5BE0CD19137E2179ULL;
	}
	else
	{
		ctx.state[0] = 0xCBBB9D5DC1059ED8ULL;
		ctx.state[1] = 0x629A292A367CD507ULL;
		ctx.state[2] = 0x9159015A3070DD17ULL;
		ctx.state[3] = 0x152FECD8F70E5939ULL;
		ctx.state[4] = 0x67332667FFC00B31ULL;
		ctx.state[5] = 0x8EB44A8768581511ULL;
		ctx.state[6] = 0xDB0C2E0D64F98FA7ULL;
		ctx.state[7] = 0x47B5481DBEFA4FA4ULL;
	}
	ctx.is384 = is384;
}

static const u64 K[80] = {0x428A2F98D728AE22ULL, 0x7137449123EF65CDULL, 0xB5C0FBCFEC4D3B2FULL, 0xE9B5DBA58189DBBCULL, 0x3956C25BF348B538ULL, 0x59F111F1B605D019ULL, 0x923F82A4AF194F9BULL, 0xAB1C5ED5DA6D8118ULL, 0xD807AA98A3030242ULL, 0x12835B0145706FBEULL, 0x243185BE4EE4B28CULL, 0x550C7DC3D5FFB4E2ULL, 0x72BE5D74F27B896FULL, 0x80DEB1FE3B1696B1ULL, 0x9BDC06A725C71235ULL, 0xC19BF174CF692694ULL, 0xE49B69C19EF14AD2ULL, 0xEFBE4786384F25E3ULL, 0x0FC19DC68B8CD5B5ULL, 0x240CA1CC77AC9C65ULL, 0x2DE92C6F592B0275ULL, 0x4A7484AA6EA6E483ULL, 0x5CB0A9DCBD41FBD4ULL, 0x76F988DA831153B5ULL, 0x983E5152EE66DFABULL, 0xA831C66D2DB43210ULL, 0xB00327C898FB213FULL, 0xBF597FC7BEEF0EE4ULL, 0xC6E00BF33DA88FC2ULL, 0xD5A79147930AA725ULL, 0x06CA6351E003826FULL, 0x142929670A0E6E70ULL, 0x27B70A8546D22FFCULL, 0x2E1B21385C26C926ULL, 0x4D2C6DFC5AC42AEDULL, 0x53380D139D95B3DFULL, 0x650A73548BAF63DEULL, 0x766A0ABB3C77B2A8ULL, 0x81C2C92E47EDAEE6ULL, 0x92722C851482353BULL, 0xA2BFE8A14CF10364ULL, 0xA81A664BBC423001ULL, 0xC24B8B70D0F89791ULL, 0xC76C51A30654BE30ULL, 0xD192E819D6EF5218ULL, 0xD69906245565A910ULL, 0xF40E35855771202AULL, 0x106AA07032BBD1B8ULL, 0x19A4C116B8D2D0C8ULL, 0x1E376C085141AB53ULL, 0x2748774CDF8EEB99ULL, 0x34B0BCB5E19B48A8ULL, 0x391C0CB3C5C95A63ULL, 0x4ED8AA4AE3418ACBULL, 0x5B9CCA4F7763E373ULL, 0x682E6FF3D6B2B8A3ULL, 0x748F82EE5DEFB2FCULL, 0x78A5636F43172F60ULL, 0x84C87814A1F0AB72ULL, 0x8CC702081A6439ECULL, 0x90BEFFFA23631E28ULL, 0xA4506CEBDE82BDE9ULL, 0xBEF9A3F7B2C67915ULL, 0xC67178F2E372532BULL, 0xCA273ECEEA26619CULL, 0xD186B8C721C0C207ULL, 0xEADA7DD6CDE0EB1EULL, 0xF57D4F7FEE6ED178ULL, 0x06F067AA72176FBAULL, 0x0A637DC5A2C898A6ULL, 0x113F9804BEF90DAEULL, 0x1B710B35131C471BULL, 0x28DB77F523047D84ULL, 0x32CAAB7B40C72493ULL, 0x3C9EBE0A15C9BEBCULL, 0x431D67C49C100D4CULL, 0x4CC5D4BECB3E42B6ULL, 0x597F299CFC657E2AULL, 0x5FCB6FAB3AD6FAECULL, 0x6C44198C4A475817ULL};
pub fn mbedtls_sha512_process(mbedtls_sha512_context * ctx, const u8 data[128])
{
	i32 i;
	u64 temp1, temp2, W[80];
	u64 A, B, C, D, E, F, G, H;
	for (i = 0; i < 16; i++)
	{
		{
			(W[i]) = ((u64)(data)[(i << 3)] << 56) | ((u64)(data)[(i << 3) + 1] << 48) | ((u64)(data)[(i << 3) + 2] << 40) | ((u64)(data)[(i << 3) + 3] << 32) | ((u64)(data)[(i << 3) + 4] << 24) | ((u64)(data)[(i << 3) + 5] << 16) | ((u64)(data)[(i << 3) + 6] << 8) | ((u64)(data)[(i << 3) + 7]);
		};
	}
	for (; i < 80; i++)
	{
		W[i] = (((W[i - 2] >> 19) | (W[i - 2] << (64 - 19))) ^ ((W[i - 2] >> 61) | (W[i - 2] << (64 - 61))) ^ (W[i - 2] >> 6)) + W[i - 7] + (((W[i - 15] >> 1) | (W[i - 15] << (64 - 1))) ^ ((W[i - 15] >> 8) | (W[i - 15] << (64 - 8))) ^ (W[i - 15] >> 7)) + W[i - 16];
	}
	A = ctx.state[0];
	B = ctx.state[1];
	C = ctx.state[2];
	D = ctx.state[3];
	E = ctx.state[4];
	F = ctx.state[5];
	G = ctx.state[6];
	H = ctx.state[7];
	i = 0;
	do
	{
		{
			temp1 = H + (((E >> 14) | (E << (64 - 14))) ^ ((E >> 18) | (E << (64 - 18))) ^ ((E >> 41) | (E << (64 - 41)))) + (G ^ (E & (F ^ G))) + K[i] + W[i];
			temp2 = (((A >> 28) | (A << (64 - 28))) ^ ((A >> 34) | (A << (64 - 34))) ^ ((A >> 39) | (A << (64 - 39)))) + ((A & B) | (C & (A | B)));
			D += temp1;
			H = temp1 + temp2;
		};
		i++;
		{
			temp1 = G + (((D >> 14) | (D << (64 - 14))) ^ ((D >> 18) | (D << (64 - 18))) ^ ((D >> 41) | (D << (64 - 41)))) + (F ^ (D & (E ^ F))) + K[i] + W[i];
			temp2 = (((H >> 28) | (H << (64 - 28))) ^ ((H >> 34) | (H << (64 - 34))) ^ ((H >> 39) | (H << (64 - 39)))) + ((H & A) | (B & (H | A)));
			C += temp1;
			G = temp1 + temp2;
		};
		i++;
		{
			temp1 = F + (((C >> 14) | (C << (64 - 14))) ^ ((C >> 18) | (C << (64 - 18))) ^ ((C >> 41) | (C << (64 - 41)))) + (E ^ (C & (D ^ E))) + K[i] + W[i];
			temp2 = (((G >> 28) | (G << (64 - 28))) ^ ((G >> 34) | (G << (64 - 34))) ^ ((G >> 39) | (G << (64 - 39)))) + ((G & H) | (A & (G | H)));
			B += temp1;
			F = temp1 + temp2;
		};
		i++;
		{
			temp1 = E + (((B >> 14) | (B << (64 - 14))) ^ ((B >> 18) | (B << (64 - 18))) ^ ((B >> 41) | (B << (64 - 41)))) + (D ^ (B & (C ^ D))) + K[i] + W[i];
			temp2 = (((F >> 28) | (F << (64 - 28))) ^ ((F >> 34) | (F << (64 - 34))) ^ ((F >> 39) | (F << (64 - 39)))) + ((F & G) | (H & (F | G)));
			A += temp1;
			E = temp1 + temp2;
		};
		i++;
		{
			temp1 = D + (((A >> 14) | (A << (64 - 14))) ^ ((A >> 18) | (A << (64 - 18))) ^ ((A >> 41) | (A << (64 - 41)))) + (C ^ (A & (B ^ C))) + K[i] + W[i];
			temp2 = (((E >> 28) | (E << (64 - 28))) ^ ((E >> 34) | (E << (64 - 34))) ^ ((E >> 39) | (E << (64 - 39)))) + ((E & F) | (G & (E | F)));
			H += temp1;
			D = temp1 + temp2;
		};
		i++;
		{
			temp1 = C + (((H >> 14) | (H << (64 - 14))) ^ ((H >> 18) | (H << (64 - 18))) ^ ((H >> 41) | (H << (64 - 41)))) + (B ^ (H & (A ^ B))) + K[i] + W[i];
			temp2 = (((D >> 28) | (D << (64 - 28))) ^ ((D >> 34) | (D << (64 - 34))) ^ ((D >> 39) | (D << (64 - 39)))) + ((D & E) | (F & (D | E)));
			G += temp1;
			C = temp1 + temp2;
		};
		i++;
		{
			temp1 = B + (((G >> 14) | (G << (64 - 14))) ^ ((G >> 18) | (G << (64 - 18))) ^ ((G >> 41) | (G << (64 - 41)))) + (A ^ (G & (H ^ A))) + K[i] + W[i];
			temp2 = (((C >> 28) | (C << (64 - 28))) ^ ((C >> 34) | (C << (64 - 34))) ^ ((C >> 39) | (C << (64 - 39)))) + ((C & D) | (E & (C | D)));
			F += temp1;
			B = temp1 + temp2;
		};
		i++;
		{
			temp1 = A + (((F >> 14) | (F << (64 - 14))) ^ ((F >> 18) | (F << (64 - 18))) ^ ((F >> 41) | (F << (64 - 41)))) + (H ^ (F & (G ^ H))) + K[i] + W[i];
			temp2 = (((B >> 28) | (B << (64 - 28))) ^ ((B >> 34) | (B << (64 - 34))) ^ ((B >> 39) | (B << (64 - 39)))) + ((B & C) | (D & (B | C)));
			E += temp1;
			A = temp1 + temp2;
		};
		i++;
	}
	while (i < 80);
	ctx.state[0] += A;
	ctx.state[1] += B;
	ctx.state[2] += C;
	ctx.state[3] += D;
	ctx.state[4] += E;
	ctx.state[5] += F;
	ctx.state[6] += G;
	ctx.state[7] += H;
}

pub fn mbedtls_sha512_update(mbedtls_sha512_context * ctx, const u8 * input, usize ilen)
{
	usize fill;
	u32 left;
	if ilen == 0
	{
		return;
	}
	left = (i32 int) (ctx.total[0] & 0x7F);
	fill = 128 - left;
	ctx.total[0] += (u64) ilen;
	if ctx.total[0] < (u64) ilen
	{
		ctx.total[1]++;
	}
	if left && ilen >= fill
	{
		memcpy((void *) (ctx.buffer + left), input, fill);
		mbedtls_sha512_process(ctx, ctx.buffer);
		input += fill;
		ilen -= fill;
		left = 0;
	}
	while (ilen >= 128)
	{
		mbedtls_sha512_process(ctx, input);
		input += 128;
		ilen -= 128;
	}
	if ilen > 0
	{
		memcpy((void *) (ctx.buffer + left), input, ilen);
	}
}

static const u8 sha512_padding[128] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
pub fn mbedtls_sha512_finish(mbedtls_sha512_context * ctx, u8 output[64])
{
	usize last, padn;
	u64 high, low;
	u8 msglen[16];
	high = (ctx.total[0] >> 61) | (ctx.total[1] << 3);
	low = (ctx.total[0] << 3);
	{
		(msglen)[(0)] = (i8) ((high) >> 56);
		(msglen)[(0) + 1] = (i8) ((high) >> 48);
		(msglen)[(0) + 2] = (i8) ((high) >> 40);
		(msglen)[(0) + 3] = (i8) ((high) >> 32);
		(msglen)[(0) + 4] = (i8) ((high) >> 24);
		(msglen)[(0) + 5] = (i8) ((high) >> 16);
		(msglen)[(0) + 6] = (i8) ((high) >> 8);
		(msglen)[(0) + 7] = (i8) ((high));
	};
	{
		(msglen)[(8)] = (i8) ((low) >> 56);
		(msglen)[(8) + 1] = (i8) ((low) >> 48);
		(msglen)[(8) + 2] = (i8) ((low) >> 40);
		(msglen)[(8) + 3] = (i8) ((low) >> 32);
		(msglen)[(8) + 4] = (i8) ((low) >> 24);
		(msglen)[(8) + 5] = (i8) ((low) >> 16);
		(msglen)[(8) + 6] = (i8) ((low) >> 8);
		(msglen)[(8) + 7] = (i8) ((low));
	};
	last = (usize)(ctx.total[0] & 0x7F);
	padn = (last < 112) ? (112 - last) : (240 - last);
	mbedtls_sha512_update(ctx, sha512_padding, padn);
	mbedtls_sha512_update(ctx, msglen, 16);
	{
		(output)[(0)] = (i8) ((ctx.state[0]) >> 56);
		(output)[(0) + 1] = (i8) ((ctx.state[0]) >> 48);
		(output)[(0) + 2] = (i8) ((ctx.state[0]) >> 40);
		(output)[(0) + 3] = (i8) ((ctx.state[0]) >> 32);
		(output)[(0) + 4] = (i8) ((ctx.state[0]) >> 24);
		(output)[(0) + 5] = (i8) ((ctx.state[0]) >> 16);
		(output)[(0) + 6] = (i8) ((ctx.state[0]) >> 8);
		(output)[(0) + 7] = (i8) ((ctx.state[0]));
	};
	{
		(output)[(8)] = (i8) ((ctx.state[1]) >> 56);
		(output)[(8) + 1] = (i8) ((ctx.state[1]) >> 48);
		(output)[(8) + 2] = (i8) ((ctx.state[1]) >> 40);
		(output)[(8) + 3] = (i8) ((ctx.state[1]) >> 32);
		(output)[(8) + 4] = (i8) ((ctx.state[1]) >> 24);
		(output)[(8) + 5] = (i8) ((ctx.state[1]) >> 16);
		(output)[(8) + 6] = (i8) ((ctx.state[1]) >> 8);
		(output)[(8) + 7] = (i8) ((ctx.state[1]));
	};
	{
		(output)[(16)] = (i8) ((ctx.state[2]) >> 56);
		(output)[(16) + 1] = (i8) ((ctx.state[2]) >> 48);
		(output)[(16) + 2] = (i8) ((ctx.state[2]) >> 40);
		(output)[(16) + 3] = (i8) ((ctx.state[2]) >> 32);
		(output)[(16) + 4] = (i8) ((ctx.state[2]) >> 24);
		(output)[(16) + 5] = (i8) ((ctx.state[2]) >> 16);
		(output)[(16) + 6] = (i8) ((ctx.state[2]) >> 8);
		(output)[(16) + 7] = (i8) ((ctx.state[2]));
	};
	{
		(output)[(24)] = (i8) ((ctx.state[3]) >> 56);
		(output)[(24) + 1] = (i8) ((ctx.state[3]) >> 48);
		(output)[(24) + 2] = (i8) ((ctx.state[3]) >> 40);
		(output)[(24) + 3] = (i8) ((ctx.state[3]) >> 32);
		(output)[(24) + 4] = (i8) ((ctx.state[3]) >> 24);
		(output)[(24) + 5] = (i8) ((ctx.state[3]) >> 16);
		(output)[(24) + 6] = (i8) ((ctx.state[3]) >> 8);
		(output)[(24) + 7] = (i8) ((ctx.state[3]));
	};
	{
		(output)[(32)] = (i8) ((ctx.state[4]) >> 56);
		(output)[(32) + 1] = (i8) ((ctx.state[4]) >> 48);
		(output)[(32) + 2] = (i8) ((ctx.state[4]) >> 40);
		(output)[(32) + 3] = (i8) ((ctx.state[4]) >> 32);
		(output)[(32) + 4] = (i8) ((ctx.state[4]) >> 24);
		(output)[(32) + 5] = (i8) ((ctx.state[4]) >> 16);
		(output)[(32) + 6] = (i8) ((ctx.state[4]) >> 8);
		(output)[(32) + 7] = (i8) ((ctx.state[4]));
	};
	{
		(output)[(40)] = (i8) ((ctx.state[5]) >> 56);
		(output)[(40) + 1] = (i8) ((ctx.state[5]) >> 48);
		(output)[(40) + 2] = (i8) ((ctx.state[5]) >> 40);
		(output)[(40) + 3] = (i8) ((ctx.state[5]) >> 32);
		(output)[(40) + 4] = (i8) ((ctx.state[5]) >> 24);
		(output)[(40) + 5] = (i8) ((ctx.state[5]) >> 16);
		(output)[(40) + 6] = (i8) ((ctx.state[5]) >> 8);
		(output)[(40) + 7] = (i8) ((ctx.state[5]));
	};
	if ctx.is384 == 0
	{
		{
			(output)[(48)] = (i8) ((ctx.state[6]) >> 56);
			(output)[(48) + 1] = (i8) ((ctx.state[6]) >> 48);
			(output)[(48) + 2] = (i8) ((ctx.state[6]) >> 40);
			(output)[(48) + 3] = (i8) ((ctx.state[6]) >> 32);
			(output)[(48) + 4] = (i8) ((ctx.state[6]) >> 24);
			(output)[(48) + 5] = (i8) ((ctx.state[6]) >> 16);
			(output)[(48) + 6] = (i8) ((ctx.state[6]) >> 8);
			(output)[(48) + 7] = (i8) ((ctx.state[6]));
		};
		{
			(output)[(56)] = (i8) ((ctx.state[7]) >> 56);
			(output)[(56) + 1] = (i8) ((ctx.state[7]) >> 48);
			(output)[(56) + 2] = (i8) ((ctx.state[7]) >> 40);
			(output)[(56) + 3] = (i8) ((ctx.state[7]) >> 32);
			(output)[(56) + 4] = (i8) ((ctx.state[7]) >> 24);
			(output)[(56) + 5] = (i8) ((ctx.state[7]) >> 16);
			(output)[(56) + 6] = (i8) ((ctx.state[7]) >> 8);
			(output)[(56) + 7] = (i8) ((ctx.state[7]));
		};
	}
}

pub fn mbedtls_sha512(const u8 * input, usize ilen, u8 output[64], i32 is384)
{
	mbedtls_sha512_context ctx;
	mbedtls_sha512_init(&ctx);
	mbedtls_sha512_starts(&ctx, is384);
	mbedtls_sha512_update(&ctx, input, ilen);
	mbedtls_sha512_finish(&ctx, output);
	mbedtls_sha512_free(&ctx);
}

static const u8 sha512_test_buf[3][113] = {{"abc"}, {"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
		"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"
	},
	{""}
};
static const i32 sha512_test_buflen[3] = {3, 112, 1000};
static const u8 sha512_test_sum[6][64] = {{0xCB, 0x00, 0x75, 0x3F, 0x45, 0xA3, 0x5E, 0x8B, 0xB5, 0xA0, 0x3D, 0x69, 0x9A, 0xC6, 0x50, 0x07, 0x27, 0x2C, 0x32, 0xAB, 0x0E, 0xDE, 0xD1, 0x63, 0x1A, 0x8B, 0x60, 0x5A, 0x43, 0xFF, 0x5B, 0xED, 0x80, 0x86, 0x07, 0x2B, 0xA1, 0xE7, 0xCC, 0x23, 0x58, 0xBA, 0xEC, 0xA1, 0x34, 0xC8, 0x25, 0xA7}, {0x09, 0x33, 0x0C, 0x33, 0xF7, 0x11, 0x47, 0xE8, 0x3D, 0x19, 0x2F, 0xC7, 0x82, 0xCD, 0x1B, 0x47, 0x53, 0x11, 0x1B, 0x17, 0x3B, 0x3B, 0x05, 0xD2, 0x2F, 0xA0, 0x80, 0x86, 0xE3, 0xB0, 0xF7, 0x12, 0xFC, 0xC7, 0xC7, 0x1A, 0x55, 0x7E, 0x2D, 0xB9, 0x66, 0xC3, 0xE9, 0xFA, 0x91, 0x74, 0x60, 0x39}, {0x9D, 0x0E, 0x18, 0x09, 0x71, 0x64, 0x74, 0xCB, 0x08, 0x6E, 0x83, 0x4E, 0x31, 0x0A, 0x4A, 0x1C, 0xED, 0x14, 0x9E, 0x9C, 0x00, 0xF2, 0x48, 0x52, 0x79, 0x72, 0xCE, 0xC5, 0x70, 0x4C, 0x2A, 0x5B, 0x07, 0xB8, 0xB3, 0xDC, 0x38, 0xEC, 0xC4, 0xEB, 0xAE, 0x97, 0xDD, 0xD8, 0x7F, 0x3D, 0x89, 0x85}, {0xDD, 0xAF, 0x35, 0xA1, 0x93, 0x61, 0x7A, 0xBA, 0xCC, 0x41, 0x73, 0x49, 0xAE, 0x20, 0x41, 0x31, 0x12, 0xE6, 0xFA, 0x4E, 0x89, 0xA9, 0x7E, 0xA2, 0x0A, 0x9E, 0xEE, 0xE6, 0x4B, 0x55, 0xD3, 0x9A, 0x21, 0x92, 0x99, 0x2A, 0x27, 0x4F, 0xC1, 0xA8, 0x36, 0xBA, 0x3C, 0x23, 0xA3, 0xFE, 0xEB, 0xBD, 0x45, 0x4D, 0x44, 0x23, 0x64, 0x3C, 0xE8, 0x0E, 0x2A, 0x9A, 0xC9, 0x4F, 0xA5, 0x4C, 0xA4, 0x9F}, {0x8E, 0x95, 0x9B, 0x75, 0xDA, 0xE3, 0x13, 0xDA, 0x8C, 0xF4, 0xF7, 0x28, 0x14, 0xFC, 0x14, 0x3F, 0x8F, 0x77, 0x79, 0xC6, 0xEB, 0x9F, 0x7F, 0xA1, 0x72, 0x99, 0xAE, 0xAD, 0xB6, 0x88, 0x90, 0x18, 0x50, 0x1D, 0x28, 0x9E, 0x49, 0x00, 0xF7, 0xE4, 0x33, 0x1B, 0x99, 0xDE, 0xC4, 0xB5, 0x43, 0x3A, 0xC7, 0xD3, 0x29, 0xEE, 0xB6, 0xDD, 0x26, 0x54, 0x5E, 0x96, 0xE5, 0x5B, 0x87, 0x4B, 0xE9, 0x09}, {0xE7, 0x18, 0x48, 0x3D, 0x0C, 0xE7, 0x69, 0x64, 0x4E, 0x2E, 0x42, 0xC7, 0xBC, 0x15, 0xB4, 0x63, 0x8E, 0x1F, 0x98, 0xB1, 0x3B, 0x20, 0x44, 0x28, 0x56, 0x32, 0xA8, 0x03, 0xAF, 0xA9, 0x73, 0xEB, 0xDE, 0x0F, 0xF2, 0x44, 0x87, 0x7E, 0xA6, 0x0A, 0x4C, 0xB0, 0x43, 0x2C, 0xE5, 0x77, 0xC3, 0x1B, 0xEB, 0x00, 0x9C, 0x5C, 0x2C, 0x49, 0xAA, 0x2E, 0x4E, 0xAD, 0xB2, 0x17, 0xAD, 0x8C, 0xC0, 0x9B}};
pub fn mbedtls_sha512_self_test(i32 verbose) -> i32
{
	i32 i, j, k, buflen, ret = 0;
	u8 buf[1024];
	u8 sha512sum[64];
	mbedtls_sha512_context ctx;
	mbedtls_sha512_init(&ctx);
	for (i = 0; i < 6; i++)
	{
		j = i % 3;
		k = i < 3;
		if verbose != 0
		{
			printf("  SHA-%d test #%d: ", 512 - k * 128, j + 1);
		}
		mbedtls_sha512_starts(&ctx, k);
		if j == 2
		{
			memset(buf, 'a', buflen = 1000);
			for (j = 0; j < 1000; j++)
			{
				mbedtls_sha512_update(&ctx, buf, buflen);
			}
		}
		else
		{
			mbedtls_sha512_update(&ctx, sha512_test_buf[j], sha512_test_buflen[j]);
		}
		mbedtls_sha512_finish(&ctx, sha512sum);
		if memcmp(sha512sum, sha512_test_sum[i], 64 - k * 16) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			ret = 1;
			goto exit;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
exit:
	mbedtls_sha512_free(&ctx);
	return ret;
}

typedef struct mbedtls_ssl_cache_context mbedtls_ssl_cache_context;
typedef struct mbedtls_ssl_cache_entry mbedtls_ssl_cache_entry;
struct mbedtls_ssl_cache_entry
{
	time_t timestamp;
	mbedtls_ssl_session session;
	mbedtls_x509_buf peer_cert;
	mbedtls_ssl_cache_entry * next;
};
struct mbedtls_ssl_cache_context
{
	mbedtls_ssl_cache_entry * chain;
	i32 timeout;
	i32 max_entries;
	mbedtls_threading_mutex_t mutex;
};

pub fn mbedtls_ssl_cache_init(mbedtls_ssl_cache_context * cache)
{
	memset(cache, 0, sizeof(mbedtls_ssl_cache_context));
	cache.timeout = 86400;
	cache.max_entries = 50;
	mbedtls_mutex_init(&cache.mutex);
}

pub fn mbedtls_ssl_cache_get(void * data, mbedtls_ssl_session * session) -> i32
{
	i32 ret = 1;
	time_t t = time(NULL);
	mbedtls_ssl_cache_context * cache = (mbedtls_ssl_cache_context *) data;
	mbedtls_ssl_cache_entry *cur, *entry;
	if mbedtls_mutex_lock(&cache.mutex) != 0
	{
		return 1;
	}
	cur = cache.chain;
	entry = NULL;
	while (cur != NULL)
	{
		entry = cur;
		cur = cur.next;
		if cache.timeout != 0 && (int) (t - entry.timestamp) > cache.timeout
		{
			continue;
		}
		if session.ciphersuite != entry.session.ciphersuite || session.compression != entry.session.compression || session.id_len != entry.session.id_len
		{
			continue;
		}
		if memcmp(session.id, entry.session.id, entry.session.id_len) != 0
		{
			continue;
		}
		memcpy(session.master, entry.session.master, 48);
		session.verify_result = entry.session.verify_result;
		if entry.peer_cert.p != NULL
		{
			if (session.peer_cert = mbedtls_calloc(1, sizeof(mbedtls_x509_crt))) == NULL
			{
				ret = 1;
				goto exit;
			}
			mbedtls_x509_crt_init(session.peer_cert);
			if mbedtls_x509_crt_parse(session.peer_cert, entry.peer_cert.p, entry.peer_cert.len) != 0
			{
				mbedtls_free(session.peer_cert);
				session.peer_cert = NULL;
				ret = 1;
				goto exit;
			}
		}
		ret = 0;
		goto exit;
	}
exit:
	if mbedtls_mutex_unlock(&cache.mutex) != 0
	{
		ret = 1;
	}
	return ret;
}

pub fn mbedtls_ssl_cache_set(void * data, const mbedtls_ssl_session * session) -> i32
{
	i32 ret = 1;
	time_t t = time(NULL), oldest = 0;
	mbedtls_ssl_cache_entry * old = NULL;
	mbedtls_ssl_cache_context * cache = (mbedtls_ssl_cache_context *) data;
	mbedtls_ssl_cache_entry *cur, *prv;
	i32 count = 0;
	if (ret = mbedtls_mutex_lock(&cache.mutex)) != 0
	{
		return ret;
	}
	cur = cache.chain;
	prv = NULL;
	while (cur != NULL)
	{
		count++;
		if cache.timeout != 0 && (int) (t - cur.timestamp) > cache.timeout
		{
			cur.timestamp = t;
			break;

		}
		if memcmp(session.id, cur.session.id, cur.session.id_len) == 0
		{
			break;

		}
		if oldest == 0 || cur.timestamp < oldest
		{
			oldest = cur.timestamp;
			old = cur;
		}
		prv = cur;
		cur = cur.next;
	}
	if cur == NULL
	{
		if count >= cache.max_entries
		{
			if old == NULL
			{
				ret = 1;
				goto exit;
			}
			cur = old;
		}
		else
		{
			cur = mbedtls_calloc(1, sizeof(mbedtls_ssl_cache_entry));
			if cur == NULL
			{
				ret = 1;
				goto exit;
			}
			if prv == NULL
			{
				cache.chain = cur;
			}
			else
			{
				prv.next = cur;
			}
		}
		cur.timestamp = t;
	}
	memcpy(&cur.session, session, sizeof(mbedtls_ssl_session));
	if cur.peer_cert.p != NULL
	{
		mbedtls_free(cur.peer_cert.p);
		memset(&cur.peer_cert, 0, sizeof(mbedtls_x509_buf));
	}
	if session.peer_cert != NULL
	{
		cur.peer_cert.p = mbedtls_calloc(1, session.peer_cert.raw.len);
		if cur.peer_cert.p == NULL
		{
			ret = 1;
			goto exit;
		}
		memcpy(cur.peer_cert.p, session.peer_cert.raw.p, session.peer_cert.raw.len);
		cur.peer_cert.len = session.peer_cert.raw.len;
		cur.session.peer_cert = NULL;
	}
	ret = 0;
exit:
	if mbedtls_mutex_unlock(&cache.mutex) != 0
	{
		ret = 1;
	}
	return ret;
}

pub fn mbedtls_ssl_cache_set_timeout(mbedtls_ssl_cache_context * cache, i32 timeout)
{
	if timeout < 0
	{
		timeout = 0;
	}
	cache.timeout = timeout;
}

pub fn mbedtls_ssl_cache_set_max_entries(mbedtls_ssl_cache_context * cache, i32 max)
{
	if max < 0
	{
		max = 0;
	}
	cache.max_entries = max;
}

pub fn mbedtls_ssl_cache_free(mbedtls_ssl_cache_context * cache)
{
	mbedtls_ssl_cache_entry *cur, *prv;
	cur = cache.chain;
	while (cur != NULL)
	{
		prv = cur;
		cur = cur.next;
		mbedtls_ssl_session_free(&prv.session);
		mbedtls_free(prv.peer_cert.p);
		mbedtls_free(prv);
	}
	mbedtls_mutex_free(&cache.mutex);
}

static const i32 ciphersuite_preference[] = {0xC02C, 0xC02B, 0};
static const mbedtls_ssl_ciphersuite_t ciphersuite_definitions[] = {{0xC009, "TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 1, 3, 3, 0}, {0xC00A, "TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 1, 3, 3, 0}, {0xC023, "TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC02B, "TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC024, "TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC02C, "TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC0AD, "TLS-ECDHE-ECDSA-WITH-AES-256-CCM", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC0AF, "TLS-ECDHE-ECDSA-WITH-AES-256-CCM-8", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0x02}, {0xC0AC, "TLS-ECDHE-ECDSA-WITH-AES-128-CCM", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC0AE, "TLS-ECDHE-ECDSA-WITH-AES-128-CCM-8", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0x02}, {0xC072, "TLS-ECDHE-ECDSA-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 1, 3, 3, 0}, {0xC073, "TLS-ECDHE-ECDSA-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 1, 3, 3, 0}, {0xC086, "TLS-ECDHE-ECDSA-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC087, "TLS-ECDHE-ECDSA-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 3, 3, 3, 0}, {0xC008, "TLS-ECDHE-ECDSA-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, 3, 1, 3, 3, 0}, {0xC013, "TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 1, 3, 3, 0}, {0xC014, "TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 1, 3, 3, 0}, {0xC027, "TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 3, 3, 3, 0}, {0xC02F, "TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 3, 3, 3, 0}, {0xC028, "TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 3, 3, 3, 0}, {0xC030, "TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 3, 3, 3, 0}, {0xC076, "TLS-ECDHE-RSA-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 1, 3, 3, 0}, {0xC077, "TLS-ECDHE-RSA-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 1, 3, 3, 0}, {0xC08A, "TLS-ECDHE-RSA-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 3, 3, 3, 0}, {0xC08B, "TLS-ECDHE-RSA-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 3, 3, 3, 0}, {0xC012, "TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, 3, 1, 3, 3, 0}, {0x9F, "TLS-DHE-RSA-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0x9E, "TLS-DHE-RSA-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0x67, "TLS-DHE-RSA-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0x6B, "TLS-DHE-RSA-WITH-AES-256-CBC-SHA256", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0x33, "TLS-DHE-RSA-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 0, 3, 3, 0}, {0x39, "TLS-DHE-RSA-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 0, 3, 3, 0}, {0xC09F, "TLS-DHE-RSA-WITH-AES-256-CCM", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0xC0A3, "TLS-DHE-RSA-WITH-AES-256-CCM-8", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0x02}, {0xC09E, "TLS-DHE-RSA-WITH-AES-128-CCM", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0xC0A2, "TLS-DHE-RSA-WITH-AES-128-CCM-8", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0x02}, {0xBE, "TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0xC4, "TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0x45, "TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 0, 3, 3, 0}, {0x88, "TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 0, 3, 3, 0}, {0xC07C, "TLS-DHE-RSA-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0xC07D, "TLS-DHE-RSA-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 3, 3, 3, 0}, {0x16, "TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_RSA, 3, 0, 3, 3, 0}, {0x9D, "TLS-RSA-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0x9C, "TLS-RSA-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0x3C, "TLS-RSA-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0x3D, "TLS-RSA-WITH-AES-256-CBC-SHA256", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0x2F, "TLS-RSA-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA, 3, 0, 3, 3, 0}, {0x35, "TLS-RSA-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA, 3, 0, 3, 3, 0}, {0xC09D, "TLS-RSA-WITH-AES-256-CCM", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0xC0A1, "TLS-RSA-WITH-AES-256-CCM-8", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0x02}, {0xC09C, "TLS-RSA-WITH-AES-128-CCM", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0xC0A0, "TLS-RSA-WITH-AES-128-CCM-8", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0x02}, {0xBA, "TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0xC0, "TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0x41, "TLS-RSA-WITH-CAMELLIA-128-CBC-SHA", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA, 3, 0, 3, 3, 0}, {0x84, "TLS-RSA-WITH-CAMELLIA-256-CBC-SHA", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA, 3, 0, 3, 3, 0}, {0xC07A, "TLS-RSA-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0xC07B, "TLS-RSA-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_RSA, 3, 3, 3, 3, 0}, {0x0A, "TLS-RSA-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA, 3, 0, 3, 3, 0}, {0xC00E, "TLS-ECDH-RSA-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 1, 3, 3, 0}, {0xC00F, "TLS-ECDH-RSA-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 1, 3, 3, 0}, {0xC029, "TLS-ECDH-RSA-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 3, 3, 3, 0}, {0xC031, "TLS-ECDH-RSA-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 3, 3, 3, 0}, {0xC02A, "TLS-ECDH-RSA-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 3, 3, 3, 0}, {0xC032, "TLS-ECDH-RSA-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 3, 3, 3, 0}, {0xC078, "TLS-ECDH-RSA-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 1, 3, 3, 0}, {0xC079, "TLS-ECDH-RSA-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 1, 3, 3, 0}, {0xC08C, "TLS-ECDH-RSA-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 3, 3, 3, 0},
	{0xC08D, "TLS-ECDH-RSA-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 3, 3, 3, 0}, {0xC00D, "TLS-ECDH-RSA-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDH_RSA, 3, 1, 3, 3, 0}, {0xC004, "TLS-ECDH-ECDSA-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 1, 3, 3, 0}, {0xC005, "TLS-ECDH-ECDSA-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 1, 3, 3, 0}, {0xC025, "TLS-ECDH-ECDSA-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 3, 3, 3, 0}, {0xC02D, "TLS-ECDH-ECDSA-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 3, 3, 3, 0}, {0xC026, "TLS-ECDH-ECDSA-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 3, 3, 3, 0}, {0xC02E, "TLS-ECDH-ECDSA-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 3, 3, 3, 0}, {0xC074, "TLS-ECDH-ECDSA-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 1, 3, 3, 0}, {0xC075, "TLS-ECDH-ECDSA-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 1, 3, 3, 0}, {0xC088, "TLS-ECDH-ECDSA-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 3, 3, 3, 0}, {0xC089, "TLS-ECDH-ECDSA-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 3, 3, 3, 0}, {0xC003, "TLS-ECDH-ECDSA-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA, 3, 1, 3, 3, 0}, {0xA8, "TLS-PSK-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0}, {0xA9, "TLS-PSK-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0}, {0xAE, "TLS-PSK-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 1, 3, 3, 0}, {0xAF, "TLS-PSK-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_PSK, 3, 1, 3, 3, 0}, {0x8C, "TLS-PSK-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_PSK, 3, 0, 3, 3, 0}, {0x8D, "TLS-PSK-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_PSK, 3, 0, 3, 3, 0}, {0xC0A5, "TLS-PSK-WITH-AES-256-CCM", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0}, {0xC0A9, "TLS-PSK-WITH-AES-256-CCM-8", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0x02}, {0xC0A4, "TLS-PSK-WITH-AES-128-CCM", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0}, {0xC0A8, "TLS-PSK-WITH-AES-128-CCM-8", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0x02}, {0xC094, "TLS-PSK-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 1, 3, 3, 0}, {0xC095, "TLS-PSK-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_PSK, 3, 1, 3, 3, 0}, {0xC08E, "TLS-PSK-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0}, {0xC08F, "TLS-PSK-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_PSK, 3, 3, 3, 3, 0}, {0x8B, "TLS-PSK-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_PSK, 3, 0, 3, 3, 0}, {0xAA, "TLS-DHE-PSK-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0}, {0xAB, "TLS-DHE-PSK-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0}, {0xB2, "TLS-DHE-PSK-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 1, 3, 3, 0}, {0xB3, "TLS-DHE-PSK-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 1, 3, 3, 0}, {0x90, "TLS-DHE-PSK-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 0, 3, 3, 0}, {0x91, "TLS-DHE-PSK-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 0, 3, 3, 0}, {0xC0A7, "TLS-DHE-PSK-WITH-AES-256-CCM", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0}, {0xC0AB, "TLS-DHE-PSK-WITH-AES-256-CCM-8", MBEDTLS_CIPHER_AES_256_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0x02}, {0xC0A6, "TLS-DHE-PSK-WITH-AES-128-CCM", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0}, {0xC0AA, "TLS-DHE-PSK-WITH-AES-128-CCM-8", MBEDTLS_CIPHER_AES_128_CCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0x02}, {0xC096, "TLS-DHE-PSK-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 1, 3, 3, 0}, {0xC097, "TLS-DHE-PSK-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 1, 3, 3, 0}, {0xC090, "TLS-DHE-PSK-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0}, {0xC091, "TLS-DHE-PSK-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 3, 3, 3, 0}, {0x8F, "TLS-DHE-PSK-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_DHE_PSK, 3, 0, 3, 3, 0}, {0xC037, "TLS-ECDHE-PSK-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK, 3, 1, 3, 3, 0}, {0xC038, "TLS-ECDHE-PSK-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK, 3, 1, 3, 3, 0}, {0xC035, "TLS-ECDHE-PSK-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK, 3, 1, 3, 3, 0}, {0xC036, "TLS-ECDHE-PSK-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK, 3, 1, 3, 3, 0}, {0xC09A, "TLS-ECDHE-PSK-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK, 3, 1, 3, 3, 0}, {0xC09B, "TLS-ECDHE-PSK-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK, 3, 1, 3, 3, 0}, {0xC034, "TLS-ECDHE-PSK-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK, 3, 1, 3, 3, 0}, {0xAC, "TLS-RSA-PSK-WITH-AES-128-GCM-SHA256", MBEDTLS_CIPHER_AES_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 3, 3, 3, 0}, {0xAD, "TLS-RSA-PSK-WITH-AES-256-GCM-SHA384", MBEDTLS_CIPHER_AES_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 3, 3, 3, 0}, {0xB6, "TLS-RSA-PSK-WITH-AES-128-CBC-SHA256", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 1, 3, 3, 0}, {0xB7, "TLS-RSA-PSK-WITH-AES-256-CBC-SHA384", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 1, 3, 3, 0}, {0x94, "TLS-RSA-PSK-WITH-AES-128-CBC-SHA", MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 1, 3, 3, 0}, {0x95, "TLS-RSA-PSK-WITH-AES-256-CBC-SHA", MBEDTLS_CIPHER_AES_256_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 1, 3, 3, 0}, {0xC098, "TLS-RSA-PSK-WITH-CAMELLIA-128-CBC-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 1, 3, 3, 0}, {0xC099, "TLS-RSA-PSK-WITH-CAMELLIA-256-CBC-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_CBC, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 1, 3, 3, 0}, {0xC092, "TLS-RSA-PSK-WITH-CAMELLIA-128-GCM-SHA256", MBEDTLS_CIPHER_CAMELLIA_128_GCM, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 3, 3, 3, 0}, {0xC093, "TLS-RSA-PSK-WITH-CAMELLIA-256-GCM-SHA384", MBEDTLS_CIPHER_CAMELLIA_256_GCM, MBEDTLS_MD_SHA384, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 3, 3, 3, 0}, {0x93, "TLS-RSA-PSK-WITH-3DES-EDE-CBC-SHA", MBEDTLS_CIPHER_DES_EDE3_CBC, MBEDTLS_MD_SHA1, MBEDTLS_KEY_EXCHANGE_RSA_PSK, 3, 1, 3, 3, 0}, {0, "", MBEDTLS_CIPHER_NONE, MBEDTLS_MD_NONE, MBEDTLS_KEY_EXCHANGE_NONE, 0, 0, 0, 0, 0}
};
pub fn i32 * mbedtls_ssl_list_ciphersuites() -> const
{
	return ciphersuite_preference;
}

pub fn mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_string(const i8 * ciphersuite_name) -> const
{
	const mbedtls_ssl_ciphersuite_t * cur = ciphersuite_definitions;
	if NULL == ciphersuite_name
	{
		return NULL;
	}
	while (cur.id != 0)
	{
		if 0 == strcmp(cur.name, ciphersuite_name)
		{
			return cur;
		}
		cur++;
	}
	return NULL;
}

pub fn mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_id(i32 ciphersuite) -> const
{
	const mbedtls_ssl_ciphersuite_t * cur = ciphersuite_definitions;
	while (cur.id != 0)
	{
		if cur.id == ciphersuite
		{
			return cur;
		}
		cur++;
	}
	return NULL;
}

pub fn i8 * mbedtls_ssl_get_ciphersuite_name(const i32 ciphersuite_id) -> const
{
	const mbedtls_ssl_ciphersuite_t * cur;
	cur = mbedtls_ssl_ciphersuite_from_id(ciphersuite_id);
	if cur == NULL
	{
		return "unknown";
	}
	return cur.name;
}

pub fn mbedtls_ssl_get_ciphersuite_id(const i8 * ciphersuite_name) -> i32
{
	const mbedtls_ssl_ciphersuite_t * cur;
	cur = mbedtls_ssl_ciphersuite_from_string(ciphersuite_name);
	if cur == NULL
	{
		return 0;
	}
	return cur.id;
}

pub fn mbedtls_ssl_get_ciphersuite_sig_pk_alg(const mbedtls_ssl_ciphersuite_t * info) -> mbedtls_pk_type_t
{
	switch (info.key_exchange)
	{
		case MBEDTLS_KEY_EXCHANGE_RSA:
		case MBEDTLS_KEY_EXCHANGE_DHE_RSA:
		case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
		case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
		return MBEDTLS_PK_RSA;
		case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
		return MBEDTLS_PK_ECDSA;
		case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
		case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
		return MBEDTLS_PK_ECKEY;
	default:
		return MBEDTLS_PK_NONE;
	}
}

pub fn mbedtls_ssl_ciphersuite_uses_ec(const mbedtls_ssl_ciphersuite_t * info) -> i32
{
	switch (info.key_exchange)
	{
		case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
		case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
		case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
		case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
		case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
		return 1;
	default:
		return 0;
	}
}

pub fn mbedtls_ssl_ciphersuite_uses_psk(const mbedtls_ssl_ciphersuite_t * info) -> i32
{
	switch (info.key_exchange)
	{
		case MBEDTLS_KEY_EXCHANGE_PSK:
		case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
		case MBEDTLS_KEY_EXCHANGE_DHE_PSK:
		case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
		return 1;
	default:
		return 0;
	}
}

struct mbedtls_ssl_handshake_params
{
	i32 sig_alg;
	i32 verify_sig_alg;
	mbedtls_dhm_context dhm_ctx;
	mbedtls_ecdh_context ecdh_ctx;
	const mbedtls_ecp_curve_info ** curves;
	u8 * psk;
	usize psk_len;
	mbedtls_ssl_key_cert * key_cert;
	i32 sni_authmode;
	mbedtls_ssl_key_cert * sni_key_cert;
	mbedtls_x509_crt * sni_ca_chain;
	mbedtls_x509_crl * sni_ca_crl;
	u32 out_msg_seq;
	u32 in_msg_seq;
	u8 * verify_cookie;
	u8 verify_cookie_len;
	u8 * hs_msg;
	u32 retransmit_timeout;
	u8 retransmit_state;
	mbedtls_ssl_flight_item * flight;
	mbedtls_ssl_flight_item * cur_msg;
	u32 in_flight_start_seq;
	mbedtls_ssl_transform * alt_transform_out;
	u8 alt_out_ctr[8];
	mbedtls_sha256_context fin_sha256;
	mbedtls_sha512_context fin_sha512;
	void (*update_checksum)(mbedtls_ssl_context *, const u8 *, usize);
	void (*calc_verify)(mbedtls_ssl_context *, u8 *);
	void (*calc_finished)(mbedtls_ssl_context *, u8 *, int);
	i32 (*tls_prf)(const u8 *, usize, const i8 *, const u8 *, usize, u8 *, usize);
	usize pmslen;
	u8 randbytes[64];
	u8 premaster[sizeof(union mbedtls_ssl_premaster_secret)];
	i32 resume;
	i32 max_major_ver;
	i32 max_minor_ver;
	i32 cli_exts;
	i32 new_session_ticket;
	i32 extended_ms;
};
struct mbedtls_ssl_transform
{
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info;
	u32 keylen;
	usize minlen;
	usize ivlen;
	usize fixed_ivlen;
	usize maclen;
	u8 iv_enc[16];
	u8 iv_dec[16];
	mbedtls_md_context_t md_ctx_enc;
	mbedtls_md_context_t md_ctx_dec;
	mbedtls_cipher_context_t cipher_ctx_enc;
	mbedtls_cipher_context_t cipher_ctx_dec;
};
struct mbedtls_ssl_key_cert
{
	mbedtls_x509_crt * cert;
	mbedtls_pk_context * key;
	mbedtls_ssl_key_cert * next;
};
struct mbedtls_ssl_flight_item
{
	u8 * p;
	usize len;
	u8 type;
	mbedtls_ssl_flight_item * next;
};

fn mbedtls_pk_context * mbedtls_ssl_own_key(mbedtls_ssl_context * ssl) -> inline
{
	mbedtls_ssl_key_cert * key_cert;
	if ssl.handshake != NULL && ssl.handshake.key_cert != NULL
	{
		key_cert = ssl.handshake.key_cert;
	}
	else
	{
		key_cert = ssl.conf.key_cert;
	}
	return key_cert == NULL ? NULL : key_cert.key;
}

fn mbedtls_x509_crt * mbedtls_ssl_own_cert(mbedtls_ssl_context * ssl) -> inline
{
	mbedtls_ssl_key_cert * key_cert;
	if ssl.handshake != NULL && ssl.handshake.key_cert != NULL
	{
		key_cert = ssl.handshake.key_cert;
	}
	else
	{
		key_cert = ssl.conf.key_cert;
	}
	return key_cert == NULL ? NULL : key_cert.cert;
}

fn usize mbedtls_ssl_hdr_len(const mbedtls_ssl_context * ssl) -> inline
{
	if ssl.conf.transport == 1
	{
		return 13;
	}
	return 5;
}

fn usize mbedtls_ssl_hs_hdr_len(const mbedtls_ssl_context * ssl) -> inline
{
	if ssl.conf.transport == 1
	{
		return 12;
	}
	return 4;
}

fn i32 mbedtls_ssl_safer_memcmp(const void * a, const void * b, usize n) -> inline
{
	usize i;
	const u8 * A = (const u8 *) a;
	const u8 * B = (const u8 *) b;
	u8 diff = 0;
	for (i = 0; i < n; i++)
	{
		diff |= A[i] ^ B[i];
	}
	return diff;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

fn ssl_write_hostname_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	usize hostname_len;
	*olen = 0;
	if ssl.hostname == NULL
	{
		return;
	}
	do
	{
	}
	while (0);
	hostname_len = strlen(ssl.hostname);
	if end < p || (usize)(end - p) < hostname_len + 9
	{
		do
		{
		}
		while (0);
		return;
	}
	*p++ = (i8) ((0 >> 8) & 0xFF);
	*p++ = (i8) ((0) & 0xFF);
	*p++ = (i8) (((hostname_len + 5) >> 8) & 0xFF);
	*p++ = (i8) (((hostname_len + 5)) & 0xFF);
	*p++ = (i8) (((hostname_len + 3) >> 8) & 0xFF);
	*p++ = (i8) (((hostname_len + 3)) & 0xFF);
	*p++ = (i8) ((0) & 0xFF);
	*p++ = (i8) ((hostname_len >> 8) & 0xFF);
	*p++ = (i8) ((hostname_len) &0xFF);
	memcpy(p, ssl.hostname, hostname_len);
	*olen = hostname_len + 9;
}

fn ssl_write_signature_algorithms_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	usize sig_alg_len = 0;
	const i32 * md;
	u8 * sig_alg_list = buf + 6;
	*olen = 0;
	if ssl.conf.max_minor_ver != 3
	{
		return;
	}
	do
	{
	}
	while (0);
	for (md = ssl.conf.sig_hashes; *md != MBEDTLS_MD_NONE; md++)
	{
		sig_alg_len += 2;
		sig_alg_len += 2;
	}
	if end < p || (usize)(end - p) < sig_alg_len + 6
	{
		do
		{
		}
		while (0);
		return;
	}
	sig_alg_len = 0;
	for (md = ssl.conf.sig_hashes; *md != MBEDTLS_MD_NONE; md++)
	{
		sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg(*md);
		sig_alg_list[sig_alg_len++] = 3;
		sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg(*md);
		sig_alg_list[sig_alg_len++] = 1;
	}
	*p++ = (i8) ((13 >> 8) & 0xFF);
	*p++ = (i8) ((13) & 0xFF);
	*p++ = (i8) (((sig_alg_len + 2) >> 8) & 0xFF);
	*p++ = (i8) (((sig_alg_len + 2)) & 0xFF);
	*p++ = (i8) ((sig_alg_len >> 8) & 0xFF);
	*p++ = (i8) ((sig_alg_len) &0xFF);
	*olen = 6 + sig_alg_len;
}

fn ssl_write_supported_elliptic_curves_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	u8 * elliptic_curve_list = p + 6;
	usize elliptic_curve_len = 0;
	const mbedtls_ecp_curve_info * info;
	const mbedtls_ecp_group_id * grp_id;
	*olen = 0;
	do
	{
	}
	while (0);
	for (grp_id = ssl.conf.curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++)
	{
		info = mbedtls_ecp_curve_info_from_grp_id(*grp_id);
		if info == NULL
		{
			do
			{
			}
			while (0);
			return;
		}
		elliptic_curve_len += 2;
	}
	if end < p || (usize)(end - p) < 6 + elliptic_curve_len
	{
		do
		{
		}
		while (0);
		return;
	}
	elliptic_curve_len = 0;
	for (grp_id = ssl.conf.curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++)
	{
		info = mbedtls_ecp_curve_info_from_grp_id(*grp_id);
		elliptic_curve_list[elliptic_curve_len++] = info.tls_id >> 8;
		elliptic_curve_list[elliptic_curve_len++] = info.tls_id & 0xFF;
	}
	if elliptic_curve_len == 0
	{
		return;
	}
	*p++ = (i8) ((10 >> 8) & 0xFF);
	*p++ = (i8) ((10) & 0xFF);
	*p++ = (i8) (((elliptic_curve_len + 2) >> 8) & 0xFF);
	*p++ = (i8) (((elliptic_curve_len + 2)) & 0xFF);
	*p++ = (i8) (((elliptic_curve_len) >> 8) & 0xFF);
	*p++ = (i8) (((elliptic_curve_len)) & 0xFF);
	*olen = 6 + elliptic_curve_len;
}

fn ssl_write_supported_point_formats_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	*olen = 0;
	do
	{
	}
	while (0);
	if end < p || (usize)(end - p) < 6
	{
		do
		{
		}
		while (0);
		return;
	}
	*p++ = (i8) ((11 >> 8) & 0xFF);
	*p++ = (i8) ((11) & 0xFF);
	*p++ = 0x00;
	*p++ = 2;
	*p++ = 1;
	*p++ = 0;
	*olen = 6;
}

fn ssl_write_max_fragment_length_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	*olen = 0;
	if ssl.conf.mfl_code == 0
	{
		return;
	}
	do
	{
	}
	while (0);
	if end < p || (usize)(end - p) < 5
	{
		do
		{
		}
		while (0);
		return;
	}
	*p++ = (i8) ((1 >> 8) & 0xFF);
	*p++ = (i8) ((1) & 0xFF);
	*p++ = 0x00;
	*p++ = 1;
	*p++ = ssl.conf.mfl_code;
	*olen = 5;
}

fn ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	*olen = 0;
	if ssl.conf.encrypt_then_mac == 0 || ssl.conf.max_minor_ver == 0
	{
		return;
	}
	do
	{
	}
	while (0);
	if end < p || (usize)(end - p) < 4
	{
		do
		{
		}
		while (0);
		return;
	}
	*p++ = (i8) ((22 >> 8) & 0xFF);
	*p++ = (i8) ((22) & 0xFF);
	*p++ = 0x00;
	*p++ = 0x00;
	*olen = 4;
}

fn ssl_write_extended_ms_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	*olen = 0;
	if ssl.conf.extended_ms == 0 || ssl.conf.max_minor_ver == 0
	{
		return;
	}
	do
	{
	}
	while (0);
	if end < p || (usize)(end - p) < 4
	{
		do
		{
		}
		while (0);
		return;
	}
	*p++ = (i8) ((0x0017 >> 8) & 0xFF);
	*p++ = (i8) ((0x0017) & 0xFF);
	*p++ = 0x00;
	*p++ = 0x00;
	*olen = 4;
}

fn ssl_write_session_ticket_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	usize tlen = ssl.session_negotiate.ticket_len;
	*olen = 0;
	if ssl.conf.session_tickets == 0
	{
		return;
	}
	do
	{
	}
	while (0);
	if end < p || (usize)(end - p) < 4 + tlen
	{
		do
		{
		}
		while (0);
		return;
	}
	*p++ = (i8) ((35 >> 8) & 0xFF);
	*p++ = (i8) ((35) & 0xFF);
	*p++ = (i8) ((tlen >> 8) & 0xFF);
	*p++ = (i8) ((tlen) &0xFF);
	*olen = 4;
	if ssl.session_negotiate.ticket == NULL || tlen == 0
	{
		return;
	}
	do
	{
	}
	while (0);
	memcpy(p, ssl.session_negotiate.ticket, tlen);
	*olen += tlen;
}

fn ssl_write_alpn_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const u8 * end = ssl.out_msg + 16384;
	usize alpnlen = 0;
	const i8 ** cur;
	*olen = 0;
	if ssl.conf.alpn_list == NULL
	{
		return;
	}
	do
	{
	}
	while (0);
	for (cur = ssl.conf.alpn_list; *cur != NULL; cur++)
	{
		alpnlen += (i8) (strlen(*cur) & 0xFF) + 1;
	}
	if end < p || (usize)(end - p) < 6 + alpnlen
	{
		do
		{
		}
		while (0);
		return;
	}
	*p++ = (i8) ((16 >> 8) & 0xFF);
	*p++ = (i8) ((16) & 0xFF);
	p += 4;
	for (cur = ssl.conf.alpn_list; *cur != NULL; cur++)
	{
		*p = (i8) (strlen(*cur) & 0xFF);
		memcpy(p + 1, *cur, *p);
		p += 1 + *p;
	}
	*olen = p - buf;
	buf[4] = (i8) (((*olen - 6) >> 8) & 0xFF);
	buf[5] = (i8) (((*olen - 6)) & 0xFF);
	buf[2] = (i8) (((*olen - 4) >> 8) & 0xFF);
	buf[3] = (i8) (((*olen - 4)) & 0xFF);
}

fn ssl_generate_random(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	u8 * p = ssl.handshake.randbytes;
	time_t t;
	if ssl.conf.transport == 1 && ssl.handshake.verify_cookie != NULL
	{
		return 0;
	}
	t = time(NULL);
	*p++ = (i8) (t >> 24);
	*p++ = (i8) (t >> 16);
	*p++ = (i8) (t >> 8);
	*p++ = (i8) (t);
	do
	{
	}
	while (0);
	if (ret = ssl.conf.f_rng(ssl.conf.p_rng, p, 28)) != 0
	{
		return ret;
	}
	return 0;
}

fn ssl_write_client_hello(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	usize i, n, olen, ext_len = 0;
	u8 * buf;
	u8 *p, *q;
	u8 offer_compress;
	const i32 * ciphersuites;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info;
	do
	{
	}
	while (0);
	if ssl.conf.f_rng == NULL
	{
		do
		{
		}
		while (0);
		return -0x7400;
	}
	{
		ssl.major_ver = ssl.conf.min_major_ver;
		ssl.minor_ver = ssl.conf.min_minor_ver;
	}
	if ssl.conf.max_major_ver == 0
	{
		do
		{
		}
		while (0);
		return -0x7100;
	}
	buf = ssl.out_msg;
	p = buf + 4;
	mbedtls_ssl_write_version(ssl.conf.max_major_ver, ssl.conf.max_minor_ver, ssl.conf.transport, p);
	p += 2;
	do
	{
	}
	while (0);
	if (ret = ssl_generate_random(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	memcpy(p, ssl.handshake.randbytes, 32);
	do
	{
	}
	while (0);
	p += 32;
	n = ssl.session_negotiate.id_len;
	if n < 16 || n > 32 || ssl.handshake.resume == 0
	{
		n = 0;
	}
	{
		if ssl.session_negotiate.ticket != NULL && ssl.session_negotiate.ticket_len != 0
		{
			ret = ssl.conf.f_rng(ssl.conf.p_rng, ssl.session_negotiate.id, 32);
			if ret != 0
			{
				return ret;
			}
			ssl.session_negotiate.id_len = n = 32;
		}
	}
	*p++ = (i8) n;
	for (i = 0; i < n; i++)
	{
		*p++ = ssl.session_negotiate.id[i];
	}
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	if ssl.conf.transport == 1
	{
		if ssl.handshake.verify_cookie == NULL
		{
			do
			{
			}
			while (0);
			*p++ = 0;
		}
		else
		{
			do
			{
			}
			while (0);
			*p++ = ssl.handshake.verify_cookie_len;
			memcpy(p, ssl.handshake.verify_cookie, ssl.handshake.verify_cookie_len);
			p += ssl.handshake.verify_cookie_len;
		}
	}
	ciphersuites = ssl.conf.ciphersuite_list[ssl.minor_ver];
	n = 0;
	q = p;
	p += 2;
	for (i = 0; ciphersuites[i] != 0; i++)
	{
		ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(ciphersuites[i]);
		if ciphersuite_info == NULL
		{
			continue;
		}
		if ciphersuite_info.min_minor_ver > ssl.conf.max_minor_ver || ciphersuite_info.max_minor_ver < ssl.conf.min_minor_ver
		{
			continue;
		}
		if ssl.conf.transport == 1 && (ciphersuite_info.flags & 0x04)
		{
			continue;
		}
		do
		{
		}
		while (0);
		n++;
		*p++ = (i8) (ciphersuites[i] >> 8);
		*p++ = (i8) (ciphersuites[i]);
	}
	{
		*p++ = (i8) (0xFF >> 8);
		*p++ = (i8) (0xFF);
		n++;
	}
	*q++ = (i8) (n >> 7);
	*q++ = (i8) (n << 1);
	do
	{
	}
	while (0);
	offer_compress = 0;
	if ssl.conf.transport == 1
	{
		offer_compress = 0;
	}
	if offer_compress
	{
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		*p++ = 2;
		*p++ = 1;
		*p++ = 0;
	}
	else
	{
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		*p++ = 1;
		*p++ = 0;
	}
	ssl_write_hostname_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_signature_algorithms_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_supported_elliptic_curves_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_supported_point_formats_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_max_fragment_length_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_encrypt_then_mac_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_extended_ms_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_alpn_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_session_ticket_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	((void) olen);
	do
	{
	}
	while (0);
	if ext_len > 0
	{
		*p++ = (i8) ((ext_len >> 8) & 0xFF);
		*p++ = (i8) ((ext_len) &0xFF);
		p += ext_len;
	}
	ssl.out_msglen = p - buf;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 1;
	ssl.state++;
	if ssl.conf.transport == 1
	{
		mbedtls_ssl_send_flight_completed(ssl);
	}
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_renegotiation_info(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	i32 ret;
	{
		if len != 1 || buf[0] != 0x00
		{
			do
			{
			}
			while (0);
			if (ret = mbedtls_ssl_send_fatal_handshake_failure(ssl)) != 0
			{
				return ret;
			}
			return -0x7980;
		}
		ssl.secure_renegotiation = 1;
	}
	return 0;
}

fn ssl_parse_max_fragment_length_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	if ssl.conf.mfl_code == 0 || len != 1 || buf[0] != ssl.conf.mfl_code
	{
		return -0x7980;
	}
	return 0;
}

fn ssl_parse_encrypt_then_mac_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	if ssl.conf.encrypt_then_mac == 0 || ssl.minor_ver == 0 || len != 0
	{
		return -0x7980;
	}
	((void) buf);
	ssl.session_negotiate.encrypt_then_mac = 1;
	return 0;
}

fn ssl_parse_extended_ms_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	if ssl.conf.extended_ms == 0 || ssl.minor_ver == 0 || len != 0
	{
		return -0x7980;
	}
	((void) buf);
	ssl.handshake.extended_ms = 1;
	return 0;
}

fn ssl_parse_session_ticket_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	if ssl.conf.session_tickets == 0 || len != 0
	{
		return -0x7980;
	}
	((void) buf);
	ssl.handshake.new_session_ticket = 1;
	return 0;
}

fn ssl_parse_supported_point_formats_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	usize list_size;
	const u8 * p;
	list_size = buf[0];
	if list_size + 1 != len
	{
		do
		{
		}
		while (0);
		return -0x7980;
	}
	p = buf + 1;
	while (list_size > 0)
	{
		if p[0] == 0 || p[0] == 1
		{
			ssl.handshake.ecdh_ctx.point_format = p[0];
			do
			{
			}
			while (0);
			return 0;
		}
		list_size--;
		p++;
	}
	do
	{
	}
	while (0);
	return -0x7980;
}

fn ssl_parse_alpn_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	usize list_len, name_len;
	const i8 ** p;
	if ssl.conf.alpn_list == NULL
	{
		return -0x7980;
	}
	if len < 4
	{
		return -0x7980;
	}
	list_len = (buf[0] << 8) | buf[1];
	if list_len != len - 2
	{
		return -0x7980;
	}
	name_len = buf[2];
	if name_len != list_len - 1
	{
		return -0x7980;
	}
	for (p = ssl.conf.alpn_list; *p != NULL; p++)
	{
		if name_len == strlen(*p) && memcmp(buf + 3, *p, name_len) == 0
		{
			ssl.alpn_chosen = *p;
			return 0;
		}
	}
	return -0x7980;
}

fn ssl_parse_hello_verify_request(mbedtls_ssl_context * ssl) -> i32
{
	const u8 * p = ssl.in_msg + mbedtls_ssl_hs_hdr_len(ssl);
	i32 major_ver, minor_ver;
	u8 cookie_len;
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	mbedtls_ssl_read_version(&major_ver, &minor_ver, ssl.conf.transport, p);
	p += 2;
	if major_ver < 3 || minor_ver < 2 || major_ver > ssl.conf.max_major_ver || minor_ver > ssl.conf.max_minor_ver
	{
		do
		{
		}
		while (0);
		mbedtls_ssl_send_alert_message(ssl, 2, 70);
		return -0x6E80;
	}
	cookie_len = *p++;
	do
	{
	}
	while (0);
	mbedtls_free(ssl.handshake.verify_cookie);
	ssl.handshake.verify_cookie = mbedtls_calloc(1, cookie_len);
	if ssl.handshake.verify_cookie == NULL
	{
		do
		{
		}
		while (0);
		return -0x7F00;
	}
	memcpy(ssl.handshake.verify_cookie, p, cookie_len);
	ssl.handshake.verify_cookie_len = cookie_len;
	ssl.state = MBEDTLS_SSL_CLIENT_HELLO;
	mbedtls_ssl_reset_checksum(ssl);
	mbedtls_ssl_recv_flight_completed(ssl);
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_server_hello(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret, i;
	usize n;
	usize ext_len;
	u8 *buf, *ext;
	u8 comp;
	i32 handshake_failure = 0;
	const mbedtls_ssl_ciphersuite_t * suite_info;
	do
	{
	}
	while (0);
	buf = ssl.in_msg;
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl.in_msgtype != 22
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	if ssl.conf.transport == 1
	{
		if buf[0] == 3
		{
			do
			{
			}
			while (0);
			do
			{
			}
			while (0);
			return ssl_parse_hello_verify_request(ssl);
		}
		else
		{
			mbedtls_free(ssl.handshake.verify_cookie);
			ssl.handshake.verify_cookie = NULL;
			ssl.handshake.verify_cookie_len = 0;
		}
	}
	if ssl.in_hslen < 38 + mbedtls_ssl_hs_hdr_len(ssl) || buf[0] != 2
	{
		do
		{
		}
		while (0);
		return -0x7980;
	}
	buf += mbedtls_ssl_hs_hdr_len(ssl);
	do
	{
	}
	while (0);
	mbedtls_ssl_read_version(&ssl.major_ver, &ssl.minor_ver, ssl.conf.transport, buf + 0);
	if ssl.major_ver < ssl.conf.min_major_ver || ssl.minor_ver < ssl.conf.min_minor_ver || ssl.major_ver > ssl.conf.max_major_ver || ssl.minor_ver > ssl.conf.max_minor_ver
	{
		do
		{
		}
		while (0);
		mbedtls_ssl_send_alert_message(ssl, 2, 70);
		return -0x6E80;
	}
	memcpy(ssl.handshake.randbytes + 32, buf + 2, 32);
	n = buf[34];
	do
	{
	}
	while (0);
	if n > 32
	{
		do
		{
		}
		while (0);
		return -0x7980;
	}
	if ssl.in_hslen > mbedtls_ssl_hs_hdr_len(ssl) + 39 + n
	{
		ext_len = ((buf[38 + n] << 8) | (buf[39 + n]));
		if (ext_len > 0 && ext_len < 4) || ssl.in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 40 + n + ext_len
		{
			do
			{
			}
			while (0);
			return -0x7980;
		}
	}
	else
		if ssl.in_hslen == mbedtls_ssl_hs_hdr_len(ssl) + 38 + n
		{
			ext_len = 0;
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x7980;
		}
	i = (buf[35 + n] << 8) | buf[36 + n];
	comp = buf[37 + n];
	if comp != 0
	{
		do
		{
		}
		while (0);
		return -0x7080;
	}
	ssl.transform_negotiate.ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(i);
	if ssl.transform_negotiate.ciphersuite_info == NULL
	{
		do
		{
		}
		while (0);
		return -0x7100;
	}
	mbedtls_ssl_optimize_checksum(ssl, ssl.transform_negotiate.ciphersuite_info);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	if ssl.handshake.resume == 0 || n == 0 || ssl.session_negotiate.ciphersuite != i || ssl.session_negotiate.compression != comp || ssl.session_negotiate.id_len != n || memcmp(ssl.session_negotiate.id, buf + 35, n) != 0
	{
		ssl.state++;
		ssl.handshake.resume = 0;
		ssl.session_negotiate.start = time(NULL);
		ssl.session_negotiate.ciphersuite = i;
		ssl.session_negotiate.compression = comp;
		ssl.session_negotiate.id_len = n;
		memcpy(ssl.session_negotiate.id, buf + 35, n);
	}
	else
	{
		ssl.state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
		if (ret = mbedtls_ssl_derive_keys(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	suite_info = mbedtls_ssl_ciphersuite_from_id(ssl.session_negotiate.ciphersuite);
	if suite_info == NULL
	{
		do
		{
		}
		while (0);
		return -0x7980;
	}
	do
	{
	}
	while (0);
	i = 0;
	while (1)
	{
		if ssl.conf.ciphersuite_list[ssl.minor_ver][i] == 0
		{
			do
			{
			}
			while (0);
			return -0x7980;
		}
		if ssl.conf.ciphersuite_list[ssl.minor_ver][i++] == ssl.session_negotiate.ciphersuite
		{
			break;

		}
	}
	if comp != 0
	{
		do
		{
		}
		while (0);
		return -0x7980;
	}
	ssl.session_negotiate.compression = comp;
	ext = buf + 40 + n;
	do
	{
	}
	while (0);
	while (ext_len)
	{
		u32 ext_id = ((ext[0] << 8) | (ext[1]));
		u32 ext_size = ((ext[2] << 8) | (ext[3]));
		if ext_size + 4 > ext_len
		{
			do
			{
			}
			while (0);
			return -0x7980;
		}
		switch (ext_id)
		{
			case 0xFF01:
			do
			{
			}
			while (0);
			if (ret = ssl_parse_renegotiation_info(ssl, ext + 4, ext_size)) != 0
			{
				return ret;
			}
			break;

			case 1:
			do
			{
			}
			while (0);
			if (ret = ssl_parse_max_fragment_length_ext(ssl, ext + 4, ext_size)) != 0
			{
				return ret;
			}
			break;

			case 22:
			do
			{
			}
			while (0);
			if (ret = ssl_parse_encrypt_then_mac_ext(ssl, ext + 4, ext_size)) != 0
			{
				return ret;
			}
			break;

			case 0x0017:
			do
			{
			}
			while (0);
			if (ret = ssl_parse_extended_ms_ext(ssl, ext + 4, ext_size)) != 0
			{
				return ret;
			}
			break;

			case 35:
			do
			{
			}
			while (0);
			if (ret = ssl_parse_session_ticket_ext(ssl, ext + 4, ext_size)) != 0
			{
				return ret;
			}
			break;

			case 11:
			do
			{
			}
			while (0);
			if (ret = ssl_parse_supported_point_formats_ext(ssl, ext + 4, ext_size)) != 0
			{
				return ret;
			}
			break;

			case 16:
			do
			{
			}
			while (0);
			if (ret = ssl_parse_alpn_ext(ssl, ext + 4, ext_size)) != 0
			{
				return ret;
			}
			break;

		default:
			do
			{
			}
			while (0);
		}
		ext_len -= 4 + ext_size;
		ext += 4 + ext_size;
		if ext_len > 0 && ext_len < 4
		{
			do
			{
			}
			while (0);
			return -0x7980;
		}
	}
	if ssl.secure_renegotiation == 0 && ssl.conf.allow_legacy_renegotiation == 2
	{
		do
		{
		}
		while (0);
		handshake_failure = 1;
	}
	if handshake_failure == 1
	{
		if (ret = mbedtls_ssl_send_fatal_handshake_failure(ssl)) != 0
		{
			return ret;
		}
		return -0x7980;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_server_dh_params(mbedtls_ssl_context * ssl, u8 ** p, u8 * end) -> i32
{
	i32 ret = -0x7080;
	if (ret = mbedtls_dhm_read_params(&ssl.handshake.dhm_ctx, p, end)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl.handshake.dhm_ctx.len * 8 < ssl.conf.dhm_min_bitlen
	{
		do
		{
		}
		while (0);
		return -0x7B00;
	}
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	return ret;
}

fn ssl_check_server_ecdh_params(const mbedtls_ssl_context * ssl) -> i32
{
	const mbedtls_ecp_curve_info * curve_info;
	curve_info = mbedtls_ecp_curve_info_from_grp_id(ssl.handshake.ecdh_ctx.grp.id);
	if curve_info == NULL
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	do
	{
	}
	while (0);
	if mbedtls_ssl_check_curve(ssl, ssl.handshake.ecdh_ctx.grp.id) != 0
	{
		return -1;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_server_ecdh_params(mbedtls_ssl_context * ssl, u8 ** p, u8 * end) -> i32
{
	i32 ret = -0x7080;
	if (ret = mbedtls_ecdh_read_params(&ssl.handshake.ecdh_ctx, (const u8 **) p, end)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl_check_server_ecdh_params(ssl) != 0
	{
		do
		{
		}
		while (0);
		return -0x7B00;
	}
	return ret;
}

fn ssl_parse_server_psk_hint(mbedtls_ssl_context * ssl, u8 ** p, u8 * end) -> i32
{
	i32 ret = -0x7080;
	usize len;
	((void) ssl);
	len = (*p)[0] << 8 | (*p)[1];
	*p += 2;
	if (*p) + len > end
	{
		do
		{
		}
		while (0);
		return -0x7B00;
	}
	*p += len;
	ret = 0;
	return ret;
}

fn ssl_write_encrypted_pms(mbedtls_ssl_context * ssl, usize offset, usize * olen, usize pms_offset) -> i32
{
	i32 ret;
	usize len_bytes = ssl.minor_ver == 0 ? 0 : 2;
	u8 * p = ssl.handshake.premaster + pms_offset;
	if offset + len_bytes > 16384
	{
		do
		{
		}
		while (0);
		return -0x6A00;
	}
	mbedtls_ssl_write_version(ssl.conf.max_major_ver, ssl.conf.max_minor_ver, ssl.conf.transport, p);
	if (ret = ssl.conf.f_rng(ssl.conf.p_rng, p + 2, 46)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	ssl.handshake.pmslen = 48;
	if ssl.session_negotiate.peer_cert == NULL
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	if !mbedtls_pk_can_do(&ssl.session_negotiate.peer_cert.pk, MBEDTLS_PK_RSA)
	{
		do
		{
		}
		while (0);
		return -0x6D00;
	}
	if (ret = mbedtls_pk_encrypt(&ssl.session_negotiate.peer_cert.pk, p, ssl.handshake.pmslen, ssl.out_msg + offset + len_bytes, olen, 16384 - offset - len_bytes, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if len_bytes == 2
	{
		ssl.out_msg[offset + 0] = (i8) (*olen >> 8);
		ssl.out_msg[offset + 1] = (i8) (*olen);
		*olen += 2;
	}
	return 0;
}

fn ssl_parse_signature_algorithm(mbedtls_ssl_context * ssl, u8 ** p, u8 * end, mbedtls_md_type_t * md_alg, mbedtls_pk_type_t * pk_alg) -> i32
{
	((void) ssl);
	*md_alg = MBEDTLS_MD_NONE;
	*pk_alg = MBEDTLS_PK_NONE;
	if ssl.minor_ver != 3
	{
		return 0;
	}
	if (*p) + 2 > end
	{
		return -0x7B00;
	}
	if (*md_alg = mbedtls_ssl_md_alg_from_hash((*p)[0])) == MBEDTLS_MD_NONE
	{
		do
		{
		}
		while (0);
		return -0x7B00;
	}
	if (*pk_alg = mbedtls_ssl_pk_alg_from_sig((*p)[1])) == MBEDTLS_PK_NONE
	{
		do
		{
		}
		while (0);
		return -0x7B00;
	}
	if mbedtls_ssl_check_sig_hash(ssl, *md_alg) != 0
	{
		do
		{
		}
		while (0);
		return -0x7B00;
	}
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	*p += 2;
	return 0;
}

fn ssl_get_ecdh_params_from_cert(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	const mbedtls_ecp_keypair * peer_key;
	if ssl.session_negotiate.peer_cert == NULL
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	if !mbedtls_pk_can_do(&ssl.session_negotiate.peer_cert.pk, MBEDTLS_PK_ECKEY)
	{
		do
		{
		}
		while (0);
		return -0x6D00;
	}
	peer_key = mbedtls_pk_ec(ssl.session_negotiate.peer_cert.pk);
	if (ret = mbedtls_ecdh_get_params(&ssl.handshake.ecdh_ctx, peer_key, MBEDTLS_ECDH_THEIRS)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl_check_server_ecdh_params(ssl) != 0
	{
		do
		{
		}
		while (0);
		return -0x7A00;
	}
	return ret;
}

fn ssl_parse_server_key_exchange(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	u8 *p, *end;
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	((void) p);
	((void) end);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA
	{
		if (ret = ssl_get_ecdh_params_from_cert(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	((void) p);
	((void) end);
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl.in_msgtype != 22
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	if ssl.in_msg[0] != 12
	{
		if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK
		{
			ssl.record_read = 1;
			goto exit;
		}
		do
		{
		}
		while (0);
		return -0x7700;
	}
	p = ssl.in_msg + mbedtls_ssl_hs_hdr_len(ssl);
	end = ssl.in_msg + ssl.in_hslen;
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
	{
		if ssl_parse_server_psk_hint(ssl, &p, end) != 0
		{
			do
			{
			}
			while (0);
			return -0x7B00;
		}
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK
		;
	else
		if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK
		{
			if ssl_parse_server_dh_params(ssl, &p, end) != 0
			{
				do
				{
				}
				while (0);
				return -0x7B00;
			}
		}
		else
			if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA
			{
				if ssl_parse_server_ecdh_params(ssl, &p, end) != 0
				{
					do
					{
					}
					while (0);
					return -0x7B00;
				}
			}
			else
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA
	{
		usize sig_len, hashlen;
		u8 hash[64];
		mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
		mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
		u8 * params = ssl.in_msg + mbedtls_ssl_hs_hdr_len(ssl);
		usize params_len = p - params;
		if ssl.minor_ver == 3
		{
			if ssl_parse_signature_algorithm(ssl, &p, end, &md_alg, &pk_alg) != 0
			{
				do
				{
				}
				while (0);
				return -0x7B00;
			}
			if pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg(ciphersuite_info)
			{
				do
				{
				}
				while (0);
				return -0x7B00;
			}
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		sig_len = (p[0] << 8) | p[1];
		p += 2;
		if end != p + sig_len
		{
			do
			{
			}
			while (0);
			return -0x7B00;
		}
		do
		{
		}
		while (0);
		if md_alg != MBEDTLS_MD_NONE
		{
			mbedtls_md_context_t ctx;
			mbedtls_md_init(&ctx);
			hashlen = 0;
			if (ret = mbedtls_md_setup(&ctx, mbedtls_md_info_from_type(md_alg), 0)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			mbedtls_md_starts(&ctx);
			mbedtls_md_update(&ctx, ssl.handshake.randbytes, 64);
			mbedtls_md_update(&ctx, params, params_len);
			mbedtls_md_finish(&ctx, hash);
			mbedtls_md_free(&ctx);
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		do
		{
		}
		while (0);
		if ssl.session_negotiate.peer_cert == NULL
		{
			do
			{
			}
			while (0);
			return -0x7700;
		}
		if !mbedtls_pk_can_do(&ssl.session_negotiate.peer_cert.pk, pk_alg)
		{
			do
			{
			}
			while (0);
			return -0x6D00;
		}
		if (ret = mbedtls_pk_verify(&ssl.session_negotiate.peer_cert.pk, md_alg, hash, hashlen, p, sig_len)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
exit:
	ssl.state++;
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_certificate_request(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	u8 * buf;
	usize n = 0;
	usize cert_type_len = 0, dn_len = 0;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if ssl.record_read == 0
	{
		if (ret = mbedtls_ssl_read_record(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if ssl.in_msgtype != 22
		{
			do
			{
			}
			while (0);
			return -0x7700;
		}
		ssl.record_read = 1;
	}
	ssl.client_auth = 0;
	ssl.state++;
	if ssl.in_msg[0] == 13
	{
		ssl.client_auth++;
	}
	do
	{
	}
	while (0);
	if ssl.client_auth == 0
	{
		goto exit;
	}
	ssl.record_read = 0;
	buf = ssl.in_msg;
	cert_type_len = buf[mbedtls_ssl_hs_hdr_len(ssl)];
	n = cert_type_len;
	if ssl.in_hslen < mbedtls_ssl_hs_hdr_len(ssl) + 2 + n
	{
		do
		{
		}
		while (0);
		return -0x7A80;
	}
	if ssl.minor_ver == 3
	{
		usize sig_alg_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] << 8) | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
		n += 2 + sig_alg_len;
		if ssl.in_hslen < mbedtls_ssl_hs_hdr_len(ssl) + 2 + n
		{
			do
			{
			}
			while (0);
			return -0x7A80;
		}
	}
	dn_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] << 8) | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
	n += dn_len;
	if ssl.in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 3 + n
	{
		do
		{
		}
		while (0);
		return -0x7A80;
	}
exit:
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_server_hello_done(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	do
	{
	}
	while (0);
	if ssl.record_read == 0
	{
		if (ret = mbedtls_ssl_read_record(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if ssl.in_msgtype != 22
		{
			do
			{
			}
			while (0);
			return -0x7700;
		}
	}
	ssl.record_read = 0;
	if ssl.in_hslen != mbedtls_ssl_hs_hdr_len(ssl) || ssl.in_msg[0] != 14
	{
		do
		{
		}
		while (0);
		return -0x7B80;
	}
	ssl.state++;
	if ssl.conf.transport == 1
	{
		mbedtls_ssl_recv_flight_completed(ssl);
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_write_client_key_exchange(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	usize i, n;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA
	{
		n = ssl.handshake.dhm_ctx.len;
		ssl.out_msg[4] = (i8) (n >> 8);
		ssl.out_msg[5] = (i8) (n);
		i = 6;
		ret = mbedtls_dhm_make_public(&ssl.handshake.dhm_ctx, (int) mbedtls_mpi_size(&ssl.handshake.dhm_ctx.P), &ssl.out_msg[i], n, ssl.conf.f_rng, ssl.conf.p_rng);
		if ret != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		if (ret = mbedtls_dhm_calc_secret(&ssl.handshake.dhm_ctx, ssl.handshake.premaster, sizeof(union mbedtls_ssl_premaster_secret), &ssl.handshake.pmslen, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		do
		{
		}
		while (0);
	}
	else
		if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA
		{
			i = 4;
			ret = mbedtls_ecdh_make_public(&ssl.handshake.ecdh_ctx, &n, &ssl.out_msg[i], 1000, ssl.conf.f_rng, ssl.conf.p_rng);
			if ret != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			do
			{
			}
			while (0);
			if (ret = mbedtls_ecdh_calc_secret(&ssl.handshake.ecdh_ctx, &ssl.handshake.pmslen, ssl.handshake.premaster, 1024, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			do
			{
			}
			while (0);
		}
		else
			if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
			{
				if ssl.conf.psk == NULL || ssl.conf.psk_identity == NULL
				{
					do
					{
					}
					while (0);
					return -0x7600;
				}
				i = 4;
				n = ssl.conf.psk_identity_len;
				if i + 2 + n > 16384
				{
					do
					{
					}
					while (0);
					return -0x6A00;
				}
				ssl.out_msg[i++] = (i8) (n >> 8);
				ssl.out_msg[i++] = (i8) (n);
				memcpy(ssl.out_msg + i, ssl.conf.psk_identity, ssl.conf.psk_identity_len);
				i += ssl.conf.psk_identity_len;
				if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK
				{
					n = 0;
				}
				else
					if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK
					{
						if (ret = ssl_write_encrypted_pms(ssl, i, &n, 2)) != 0
						{
							return ret;
						}
					}
					else
						if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK
						{
							n = ssl.handshake.dhm_ctx.len;
							if i + 2 + n > 16384
							{
								do
								{
								}
								while (0);
								return -0x6A00;
							}
							ssl.out_msg[i++] = (i8) (n >> 8);
							ssl.out_msg[i++] = (i8) (n);
							ret = mbedtls_dhm_make_public(&ssl.handshake.dhm_ctx, (int) mbedtls_mpi_size(&ssl.handshake.dhm_ctx.P), &ssl.out_msg[i], n, ssl.conf.f_rng, ssl.conf.p_rng);
							if ret != 0
							{
								do
								{
								}
								while (0);
								return ret;
							}
						}
						else
							if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
							{
								ret = mbedtls_ecdh_make_public(&ssl.handshake.ecdh_ctx, &n, &ssl.out_msg[i], 16384 - i, ssl.conf.f_rng, ssl.conf.p_rng);
								if ret != 0
								{
									do
									{
									}
									while (0);
									return ret;
								}
								do
								{
								}
								while (0);
							}
							else
							{
								do
								{
								}
								while (0);
								return -0x6C00;
							}
				if (ret = mbedtls_ssl_psk_derive_premaster(ssl, ciphersuite_info.key_exchange)) != 0
				{
					do
					{
					}
					while (0);
					return ret;
				}
			}
			else
				if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA
				{
					i = 4;
					if (ret = ssl_write_encrypted_pms(ssl, i, &n, 0)) != 0
					{
						return ret;
					}
				}
				else
				{
					((void) ciphersuite_info);
					do
					{
					}
					while (0);
					return -0x6C00;
				}
	ssl.out_msglen = i + n;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 16;
	ssl.state++;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_write_certificate_verify(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = -0x7080;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	usize n = 0, offset = 0;
	u8 hash[48];
	u8 * hash_start = hash;
	mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
	u32 hashlen;
	do
	{
	}
	while (0);
	if (ret = mbedtls_ssl_derive_keys(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if ssl.client_auth == 0 || mbedtls_ssl_own_cert(ssl) == NULL
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if mbedtls_ssl_own_key(ssl) == NULL
	{
		do
		{
		}
		while (0);
		return -0x7600;
	}
	ssl.handshake.calc_verify(ssl, hash);
	if ssl.minor_ver == 3
	{
		if ssl.transform_negotiate.ciphersuite_info.mac == MBEDTLS_MD_SHA384
		{
			md_alg = MBEDTLS_MD_SHA384;
			ssl.out_msg[4] = 5;
		}
		else
		{
			md_alg = MBEDTLS_MD_SHA256;
			ssl.out_msg[4] = 4;
		}
		ssl.out_msg[5] = mbedtls_ssl_sig_from_pk(mbedtls_ssl_own_key(ssl));
		hashlen = 0;
		offset = 2;
	}
	else
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	if (ret = mbedtls_pk_sign(mbedtls_ssl_own_key(ssl), md_alg, hash_start, hashlen, ssl.out_msg + 6 + offset, &n, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	ssl.out_msg[4 + offset] = (i8) (n >> 8);
	ssl.out_msg[5 + offset] = (i8) (n);
	ssl.out_msglen = 6 + n + offset;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 15;
	ssl.state++;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return ret;
}

fn ssl_parse_new_session_ticket(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	u32 lifetime;
	usize ticket_len;
	u8 * ticket;
	const u8 * msg;
	do
	{
	}
	while (0);
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl.in_msgtype != 22
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	if ssl.in_msg[0] != 4 || ssl.in_hslen < 6 + mbedtls_ssl_hs_hdr_len(ssl)
	{
		do
		{
		}
		while (0);
		return -0x6E00;
	}
	msg = ssl.in_msg + mbedtls_ssl_hs_hdr_len(ssl);
	lifetime = (msg[0] << 24) | (msg[1] << 16) | (msg[2] << 8) | (msg[3]);
	ticket_len = (msg[4] << 8) | (msg[5]);
	if ticket_len + 6 + mbedtls_ssl_hs_hdr_len(ssl) != ssl.in_hslen
	{
		do
		{
		}
		while (0);
		return -0x6E00;
	}
	do
	{
	}
	while (0);
	ssl.handshake.new_session_ticket = 0;
	ssl.state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
	if ticket_len == 0
	{
		return 0;
	}
	zeroize(ssl.session_negotiate.ticket, ssl.session_negotiate.ticket_len);
	mbedtls_free(ssl.session_negotiate.ticket);
	ssl.session_negotiate.ticket = NULL;
	ssl.session_negotiate.ticket_len = 0;
	if (ticket = mbedtls_calloc(1, ticket_len)) == NULL
	{
		do
		{
		}
		while (0);
		return -0x7F00;
	}
	memcpy(ticket, msg + 6, ticket_len);
	ssl.session_negotiate.ticket = ticket;
	ssl.session_negotiate.ticket_len = ticket_len;
	ssl.session_negotiate.ticket_lifetime = lifetime;
	do
	{
	}
	while (0);
	ssl.session_negotiate.id_len = 0;
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_handshake_client_step(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = 0;
	if ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl.handshake == NULL
	{
		return -0x7100;
	}
	do
	{
	}
	while (0);
	if (ret = mbedtls_ssl_flush_output(ssl)) != 0
	{
		return ret;
	}
	if ssl.conf.transport == 1 && ssl.handshake.retransmit_state == 1
	{
		if (ret = mbedtls_ssl_resend(ssl)) != 0
		{
			return ret;
		}
	}
	if ssl.state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC && ssl.handshake.new_session_ticket != 0
	{
		ssl.state = MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET;
	}
	switch (ssl.state)
	{
		case MBEDTLS_SSL_HELLO_REQUEST:
		ssl.state = MBEDTLS_SSL_CLIENT_HELLO;
		break;

		case MBEDTLS_SSL_CLIENT_HELLO:
		ret = ssl_write_client_hello(ssl);
		break;

		case MBEDTLS_SSL_SERVER_HELLO:
		ret = ssl_parse_server_hello(ssl);
		break;

		case MBEDTLS_SSL_SERVER_CERTIFICATE:
		ret = mbedtls_ssl_parse_certificate(ssl);
		break;

		case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
		ret = ssl_parse_server_key_exchange(ssl);
		break;

		case MBEDTLS_SSL_CERTIFICATE_REQUEST:
		ret = ssl_parse_certificate_request(ssl);
		break;

		case MBEDTLS_SSL_SERVER_HELLO_DONE:
		ret = ssl_parse_server_hello_done(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_CERTIFICATE:
		ret = mbedtls_ssl_write_certificate(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
		ret = ssl_write_client_key_exchange(ssl);
		break;

		case MBEDTLS_SSL_CERTIFICATE_VERIFY:
		ret = ssl_write_certificate_verify(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
		ret = mbedtls_ssl_write_change_cipher_spec(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_FINISHED:
		ret = mbedtls_ssl_write_finished(ssl);
		break;

		case MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET:
		ret = ssl_parse_new_session_ticket(ssl);
		break;

		case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
		ret = mbedtls_ssl_parse_change_cipher_spec(ssl);
		break;

		case MBEDTLS_SSL_SERVER_FINISHED:
		ret = mbedtls_ssl_parse_finished(ssl);
		break;

		case MBEDTLS_SSL_FLUSH_BUFFERS:
		do
		{
		}
		while (0);
		ssl.state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
		break;

		case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
		mbedtls_ssl_handshake_wrapup(ssl);
		break;

	default:
		do
		{
		}
		while (0);
		return -0x7100;
	}
	return ret;
}

typedef struct
{
	mbedtls_md_context_t hmac_ctx;
	u32 timeout;
	mbedtls_threading_mutex_t mutex;
} mbedtls_ssl_cookie_ctx;

mbedtls_ssl_cookie_write_t mbedtls_ssl_cookie_write;
mbedtls_ssl_cookie_check_t mbedtls_ssl_cookie_check;
fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_ssl_cookie_init(mbedtls_ssl_cookie_ctx * ctx)
{
	mbedtls_md_init(&ctx.hmac_ctx);
	ctx.timeout = 60;
	mbedtls_mutex_init(&ctx.mutex);
}

pub fn mbedtls_ssl_cookie_set_timeout(mbedtls_ssl_cookie_ctx * ctx, u32 delay)
{
	ctx.timeout = delay;
}

pub fn mbedtls_ssl_cookie_free(mbedtls_ssl_cookie_ctx * ctx)
{
	mbedtls_md_free(&ctx.hmac_ctx);
	mbedtls_mutex_init(&ctx.mutex);
	zeroize(ctx, sizeof(mbedtls_ssl_cookie_ctx));
}

pub fn mbedtls_ssl_cookie_setup(mbedtls_ssl_cookie_ctx * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	u8 key[32];
	if (ret = f_rng(p_rng, key, sizeof(key))) != 0
	{
		return ret;
	}
	ret = mbedtls_md_setup(&ctx.hmac_ctx, mbedtls_md_info_from_type(MBEDTLS_MD_SHA224), 1);
	if ret != 0
	{
		return ret;
	}
	ret = mbedtls_md_hmac_starts(&ctx.hmac_ctx, key, sizeof(key));
	if ret != 0
	{
		return ret;
	}
	zeroize(key, sizeof(key));
	return 0;
}

fn ssl_cookie_hmac(mbedtls_md_context_t * hmac_ctx, const u8 time[4], u8 ** p, u8 * end, const u8 * cli_id, usize cli_id_len) -> i32
{
	u8 hmac_out[32];
	if (usize)(end - *p) < 28
	{
		return -0x6A00;
	}
	if mbedtls_md_hmac_reset(hmac_ctx) != 0 || mbedtls_md_hmac_update(hmac_ctx, time, 4) != 0 || mbedtls_md_hmac_update(hmac_ctx, cli_id, cli_id_len) != 0 || mbedtls_md_hmac_finish(hmac_ctx, hmac_out) != 0
	{
		return -0x6C00;
	}
	memcpy(*p, hmac_out, 28);
	*p += 28;
	return 0;
}

pub fn mbedtls_ssl_cookie_write(void * p_ctx, u8 ** p, u8 * end, const u8 * cli_id, usize cli_id_len) -> i32
{
	i32 ret;
	mbedtls_ssl_cookie_ctx * ctx = (mbedtls_ssl_cookie_ctx *) p_ctx;
	u32 t;
	if ctx == NULL || cli_id == NULL
	{
		return -0x7100;
	}
	if (usize)(end - *p) < (4 + 28)
	{
		return -0x6A00;
	}
	t = (i32 long) time(NULL);
	(*p)[0] = (i8) (t >> 24);
	(*p)[1] = (i8) (t >> 16);
	(*p)[2] = (i8) (t >> 8);
	(*p)[3] = (i8) (t);
	*p += 4;
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return -0x6C00 + ret;
	}
	ret = ssl_cookie_hmac(&ctx.hmac_ctx, *p - 4, p, end, cli_id, cli_id_len);
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x6C00 + -0x001E;
	}
	return ret;
}

pub fn mbedtls_ssl_cookie_check(void * p_ctx, const u8 * cookie, usize cookie_len, const u8 * cli_id, usize cli_id_len) -> i32
{
	u8 ref_hmac[28];
	i32 ret = 0;
	u8 * p = ref_hmac;
	mbedtls_ssl_cookie_ctx * ctx = (mbedtls_ssl_cookie_ctx *) p_ctx;
	u32 cur_time, cookie_time;
	if ctx == NULL || cli_id == NULL
	{
		return -0x7100;
	}
	if cookie_len != (4 + 28)
	{
		return -1;
	}
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return -0x6C00 + ret;
	}
	if ssl_cookie_hmac(&ctx.hmac_ctx, cookie, &p, p + sizeof(ref_hmac), cli_id, cli_id_len) != 0
	{
		ret = -1;
	}
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x6C00 + -0x001E;
	}
	if ret != 0
	{
		return ret;
	}
	if mbedtls_ssl_safer_memcmp(cookie + 4, ref_hmac, sizeof(ref_hmac)) != 0
	{
		return -1;
	}
	cur_time = (i32 long) time(NULL);
	cookie_time = ((i32 long) cookie[0] << 24) | ((i32 long) cookie[1] << 16) | ((i32 long) cookie[2] << 8) | ((i32 long) cookie[3]);
	if ctx.timeout != 0 && cur_time - cookie_time > ctx.timeout
	{
		return -1;
	}
	return 0;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_ssl_set_client_transport_id(mbedtls_ssl_context * ssl, const u8 * info, usize ilen) -> i32
{
	if ssl.conf.endpoi32 != 1
	{
		return -0x7100;
	}
	mbedtls_free(ssl.cli_id);
	if (ssl.cli_id = mbedtls_calloc(1, ilen)) == NULL
	{
		return -0x7F00;
	}
	memcpy(ssl.cli_id, info, ilen);
	ssl.cli_id_len = ilen;
	return 0;
}

pub fn mbedtls_ssl_conf_dtls_cookies(mbedtls_ssl_config * conf, mbedtls_ssl_cookie_write_t * f_cookie_write, mbedtls_ssl_cookie_check_t * f_cookie_check, void * p_cookie)
{
	conf.f_cookie_write = f_cookie_write;
	conf.f_cookie_check = f_cookie_check;
	conf.p_cookie = p_cookie;
}

fn ssl_parse_servername_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	i32 ret;
	usize servername_list_size, hostname_len;
	const u8 * p;
	do
	{
	}
	while (0);
	servername_list_size = ((buf[0] << 8) | (buf[1]));
	if servername_list_size + 2 != len
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	p = buf + 2;
	while (servername_list_size > 0)
	{
		hostname_len = ((p[1] << 8) | p[2]);
		if hostname_len + 3 > servername_list_size
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
		if p[0] == 0
		{
			ret = ssl.conf.f_sni(ssl.conf.p_sni, ssl, p + 3, hostname_len);
			if ret != 0
			{
				do
				{
				}
				while (0);
				mbedtls_ssl_send_alert_message(ssl, 2, 112);
				return -0x7900;
			}
			return 0;
		}
		servername_list_size -= hostname_len + 3;
		p += hostname_len + 3;
	}
	if servername_list_size != 0
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	return 0;
}

fn ssl_parse_renegotiation_info(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	i32 ret;
	{
		if len != 1 || buf[0] != 0x0
		{
			do
			{
			}
			while (0);
			if (ret = mbedtls_ssl_send_fatal_handshake_failure(ssl)) != 0
			{
				return ret;
			}
			return -0x7900;
		}
		ssl.secure_renegotiation = 1;
	}
	return 0;
}

fn ssl_parse_signature_algorithms_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	usize sig_alg_list_size;
	const u8 * p;
	const u8 * end = buf + len;
	const i32 * md_cur;
	sig_alg_list_size = ((buf[0] << 8) | (buf[1]));
	if sig_alg_list_size + 2 != len || sig_alg_list_size % 2 != 0
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	for (md_cur = ssl.conf.sig_hashes; *md_cur != MBEDTLS_MD_NONE; md_cur++)
	{
		for (p = buf + 2; p < end; p += 2)
		{
			if *md_cur == (int) mbedtls_ssl_md_alg_from_hash(p[0])
			{
				ssl.handshake.sig_alg = p[0];
				goto have_sig_alg;
			}
		}
	}
	do
	{
	}
	while (0);
	return 0;
have_sig_alg:
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_supported_elliptic_curves(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	usize list_size, our_size;
	const u8 * p;
	const mbedtls_ecp_curve_info *curve_info, **curves;
	list_size = ((buf[0] << 8) | (buf[1]));
	if list_size + 2 != len || list_size % 2 != 0
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	if ssl.handshake.curves != NULL
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	our_size = list_size / 2 + 1;
	if our_size > 12
	{
		our_size = 12;
	}
	if (curves = mbedtls_calloc(our_size, sizeof(*curves))) == NULL
	{
		return -0x7F00;
	}
	ssl.handshake.curves = curves;
	p = buf + 2;
	while (list_size > 0 && our_size > 1)
	{
		curve_info = mbedtls_ecp_curve_info_from_tls_id((p[0] << 8) | p[1]);
		if curve_info != NULL
		{
			*curves++ = curve_info;
			our_size--;
		}
		list_size -= 2;
		p += 2;
	}
	return 0;
}

fn ssl_parse_supported_point_formats(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	usize list_size;
	const u8 * p;
	list_size = buf[0];
	if list_size + 1 != len
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	p = buf + 1;
	while (list_size > 0)
	{
		if p[0] == 0 || p[0] == 1
		{
			ssl.handshake.ecdh_ctx.point_format = p[0];
			do
			{
			}
			while (0);
			return 0;
		}
		list_size--;
		p++;
	}
	return 0;
}

fn ssl_parse_max_fragment_length_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	if len != 1 || buf[0] >= 5
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	ssl.session_negotiate.mfl_code = buf[0];
	return 0;
}

fn ssl_parse_encrypt_then_mac_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	if len != 0
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	((void) buf);
	if ssl.conf.encrypt_then_mac == 1 && ssl.minor_ver != 0
	{
		ssl.session_negotiate.encrypt_then_mac = 1;
	}
	return 0;
}

fn ssl_parse_extended_ms_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	if len != 0
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	((void) buf);
	if ssl.conf.extended_ms == 1 && ssl.minor_ver != 0
	{
		ssl.handshake.extended_ms = 1;
	}
	return 0;
}

fn ssl_parse_session_ticket_ext(mbedtls_ssl_context * ssl, u8 * buf, usize len) -> i32
{
	i32 ret;
	mbedtls_ssl_session session;
	mbedtls_ssl_session_init(&session);
	if ssl.conf.f_ticket_parse == NULL || ssl.conf.f_ticket_write == NULL
	{
		return 0;
	}
	ssl.handshake.new_session_ticket = 1;
	do
	{
	}
	while (0);
	if len == 0
	{
		return 0;
	}
	if (ret = ssl.conf.f_ticket_parse(ssl.conf.p_ticket, &session, buf, len)) != 0
	{
		mbedtls_ssl_session_free(&session);
		if ret == -0x7180
			do
			{
			}
			while (0);
		else
			if ret == -0x6D80
				do
				{
				}
				while (0);
			else
				do
				{
				}
				while (0);
		return 0;
	}
	session.id_len = ssl.session_negotiate.id_len;
	memcpy(&session.id, ssl.session_negotiate.id, session.id_len);
	mbedtls_ssl_session_free(ssl.session_negotiate);
	memcpy(ssl.session_negotiate, &session, sizeof(mbedtls_ssl_session));
	zeroize(&session, sizeof(mbedtls_ssl_session));
	do
	{
	}
	while (0);
	ssl.handshake.resume = 1;
	ssl.handshake.new_session_ticket = 0;
	return 0;
}

fn ssl_parse_alpn_ext(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	usize list_len, cur_len, ours_len;
	const u8 *theirs, *start, *end;
	const i8 ** ours;
	if ssl.conf.alpn_list == NULL
	{
		return 0;
	}
	if len < 4
	{
		return -0x7900;
	}
	list_len = (buf[0] << 8) | buf[1];
	if list_len != len - 2
	{
		return -0x7900;
	}
	start = buf + 2;
	end = buf + len;
	for (ours = ssl.conf.alpn_list; *ours != NULL; ours++)
	{
		ours_len = strlen(*ours);
		for (theirs = start; theirs != end; theirs += cur_len)
		{
			if theirs > end
			{
				return -0x7900;
			}
			cur_len = *theirs++;
			if cur_len == 0
			{
				return -0x7900;
			}
			if cur_len == ours_len && memcmp(theirs, *ours, cur_len) == 0
			{
				ssl.alpn_chosen = *ours;
				return 0;
			}
		}
	}
	mbedtls_ssl_send_alert_message(ssl, 2, 120);
	return -0x7900;
}

fn ssl_check_key_curve(mbedtls_pk_context * pk, const mbedtls_ecp_curve_info ** curves) -> i32
{
	const mbedtls_ecp_curve_info ** crv = curves;
	mbedtls_ecp_group_id grp_id = mbedtls_pk_ec(*pk)->grp.id;
	while (*crv != NULL)
	{
		if (*crv)->grp_id == grp_id
		{
			return 0;
		}
		crv++;
	}
	return -1;
}

fn ssl_pick_cert(mbedtls_ssl_context * ssl, const mbedtls_ssl_ciphersuite_t * ciphersuite_info) -> i32
{
	mbedtls_ssl_key_cert *cur, *list, *fallback = NULL;
	mbedtls_pk_type_t pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg(ciphersuite_info);
	u32 flags;
	if ssl.handshake.sni_key_cert != NULL
	{
		list = ssl.handshake.sni_key_cert;
	}
	else
	{
		list = ssl.conf.key_cert;
	}
	if pk_alg == MBEDTLS_PK_NONE
	{
		return 0;
	}
	do
	{
	}
	while (0);
	if list == NULL
	{
		do
		{
		}
		while (0);
		return -1;
	}
	for (cur = list; cur != NULL; cur = cur.next)
	{
		do
		{
		}
		while (0);
		if !mbedtls_pk_can_do(cur.key, pk_alg)
		{
			do
			{
			}
			while (0);
			continue;
		}
		if mbedtls_ssl_check_cert_usage(cur.cert, ciphersuite_info, 1, &flags) != 0
		{
			do
			{
			}
			while (0);
			continue;
		}
		if pk_alg == MBEDTLS_PK_ECDSA && ssl_check_key_curve(cur.key, ssl.handshake.curves) != 0
		{
			do
			{
			}
			while (0);
			continue;
		}
		if ssl.minor_ver < 3 && cur.cert.sig_md != MBEDTLS_MD_SHA1
		{
			if fallback == NULL
			{
				fallback = cur;
			}
			{
				do
				{
				}
				while (0);
				continue;
			}
		}
		break;

	}
	if cur == NULL
	{
		cur = fallback;
	}
	if cur != NULL
	{
		ssl.handshake.key_cert = cur;
		do
		{
		}
		while (0);
		return 0;
	}
	return -1;
}

fn ssl_ciphersuite_match(mbedtls_ssl_context * ssl, i32 suite_id, const mbedtls_ssl_ciphersuite_t ** ciphersuite_info) -> i32
{
	const mbedtls_ssl_ciphersuite_t * suite_info;
	suite_info = mbedtls_ssl_ciphersuite_from_id(suite_id);
	if suite_info == NULL
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	do
	{
	}
	while (0);
	if suite_info.min_minor_ver > ssl.minor_ver || suite_info.max_minor_ver < ssl.minor_ver
	{
		do
		{
		}
		while (0);
		return 0;
	}
	if ssl.conf.transport == 1 && (suite_info.flags & 0x04)
	{
		return 0;
	}
	if mbedtls_ssl_ciphersuite_uses_ec(suite_info) && (ssl.handshake.curves == NULL || ssl.handshake.curves[0] == NULL)
	{
		do
		{
		}
		while (0);
		return 0;
	}
	if mbedtls_ssl_ciphersuite_uses_psk(suite_info) && ssl.conf.f_psk == NULL && (ssl.conf.psk == NULL || ssl.conf.psk_identity == NULL || ssl.conf.psk_identity_len == 0 || ssl.conf.psk_len == 0)
	{
		do
		{
		}
		while (0);
		return 0;
	}
	if ssl_pick_cert(ssl, suite_info) != 0
	{
		do
		{
		}
		while (0);
		return 0;
	}
	*ciphersuite_info = suite_info;
	return 0;
}

fn ssl_parse_client_hello(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret, got_common_suite;
	usize i, j;
	usize ciph_offset, comp_offset, ext_offset;
	usize msg_len, ciph_len, sess_len, comp_len, ext_len;
	usize cookie_offset, cookie_len;
	u8 *buf, *p, *ext;
	i32 handshake_failure = 0;
	const i32 * ciphersuites;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info;
	i32 major, minor;
	do
	{
	}
	while (0);
read_record_header:
	{
		if (ret = mbedtls_ssl_fetch_input(ssl, 5)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	buf = ssl.in_hdr;
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	if buf[0] != 22
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	mbedtls_ssl_read_version(&major, &minor, ssl.conf.transport, buf + 1);
	if major < 3
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	if ssl.conf.transport == 1
	{
		if ssl.in_ctr[0] != 0 || ssl.in_ctr[1] != 0
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
		memcpy(ssl.out_ctr + 2, ssl.in_ctr + 2, 6);
		if mbedtls_ssl_dtls_replay_check(ssl) != 0
		{
			do
			{
			}
			while (0);
			ssl.next_record_offset = 0;
			ssl.in_left = 0;
			goto read_record_header;
		}
		mbedtls_ssl_dtls_replay_update(ssl);
	}
	msg_len = (ssl.in_len[0] << 8) | ssl.in_len[1];
	{
		if msg_len > 16384
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
		if (ret = mbedtls_ssl_fetch_input(ssl, mbedtls_ssl_hdr_len(ssl) + msg_len)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if ssl.conf.transport == 1
		{
			ssl.next_record_offset = msg_len + mbedtls_ssl_hdr_len(ssl);
		}
		else
		{
			ssl.in_left = 0;
		}
	}
	buf = ssl.in_msg;
	do
	{
	}
	while (0);
	ssl.handshake.update_checksum(ssl, buf, msg_len);
	if msg_len < mbedtls_ssl_hs_hdr_len(ssl)
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	do
	{
	}
	while (0);
	if buf[0] != 1
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	do
	{
	}
	while (0);
	if buf[1] != 0 || msg_len != mbedtls_ssl_hs_hdr_len(ssl) + ((buf[2] << 8) | buf[3])
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	if ssl.conf.transport == 1
	{
		{
			u32 cli_msg_seq = (ssl.in_msg[4] << 8) | ssl.in_msg[5];
			ssl.handshake.out_msg_seq = cli_msg_seq;
			ssl.handshake.in_msg_seq = cli_msg_seq + 1;
		}
		if ssl.in_msg[6] != 0 || ssl.in_msg[7] != 0 || ssl.in_msg[8] != 0 || memcmp(ssl.in_msg + 1, ssl.in_msg + 9, 3) != 0
		{
			do
			{
			}
			while (0);
			return -0x7080;
		}
	}
	buf += mbedtls_ssl_hs_hdr_len(ssl);
	msg_len -= mbedtls_ssl_hs_hdr_len(ssl);
	if msg_len < 38
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	do
	{
	}
	while (0);
	mbedtls_ssl_read_version(&ssl.major_ver, &ssl.minor_ver, ssl.conf.transport, buf);
	ssl.handshake.max_major_ver = ssl.major_ver;
	ssl.handshake.max_minor_ver = ssl.minor_ver;
	if ssl.major_ver < ssl.conf.min_major_ver || ssl.minor_ver < ssl.conf.min_minor_ver
	{
		do
		{
		}
		while (0);
		mbedtls_ssl_send_alert_message(ssl, 2, 70);
		return -0x6E80;
	}
	if ssl.major_ver > ssl.conf.max_major_ver
	{
		ssl.major_ver = ssl.conf.max_major_ver;
		ssl.minor_ver = ssl.conf.max_minor_ver;
	}
	else
		if ssl.minor_ver > ssl.conf.max_minor_ver
		{
			ssl.minor_ver = ssl.conf.max_minor_ver;
		}
	do
	{
	}
	while (0);
	memcpy(ssl.handshake.randbytes, buf + 2, 32);
	sess_len = buf[34];
	if sess_len > sizeof(ssl.session_negotiate.id) || sess_len + 34 + 2 > msg_len
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	do
	{
	}
	while (0);
	ssl.session_negotiate.id_len = sess_len;
	memset(ssl.session_negotiate.id, 0, sizeof(ssl.session_negotiate.id));
	memcpy(ssl.session_negotiate.id, buf + 35, ssl.session_negotiate.id_len);
	if ssl.conf.transport == 1
	{
		cookie_offset = 35 + sess_len;
		cookie_len = buf[cookie_offset];
		if cookie_offset + 1 + cookie_len + 2 > msg_len
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
		do
		{
		}
		while (0);
		if ssl.conf.f_cookie_check != NULL
		{
			if ssl.conf.f_cookie_check(ssl.conf.p_cookie, buf + cookie_offset + 1, cookie_len, ssl.cli_id, ssl.cli_id_len) != 0
			{
				do
				{
				}
				while (0);
				ssl.handshake.verify_cookie_len = 1;
			}
			else
			{
				do
				{
				}
				while (0);
				ssl.handshake.verify_cookie_len = 0;
			}
		}
		else
		{
			if cookie_len != 0
			{
				do
				{
				}
				while (0);
				return -0x7900;
			}
			do
			{
			}
			while (0);
		}
		ciph_offset = cookie_offset + 1 + cookie_len;
	}
	else
	{
		ciph_offset = 35 + sess_len;
	}
	ciph_len = (buf[ciph_offset + 0] << 8) | (buf[ciph_offset + 1]);
	if ciph_len < 2 || ciph_len + 2 + ciph_offset + 1 > msg_len || (ciph_len % 2) != 0
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	do
	{
	}
	while (0);
	comp_offset = ciph_offset + 2 + ciph_len;
	comp_len = buf[comp_offset];
	if comp_len < 1 || comp_len > 16 || comp_len + comp_offset + 1 > msg_len
	{
		do
		{
		}
		while (0);
		return -0x7900;
	}
	do
	{
	}
	while (0);
	ssl.session_negotiate.compression = 0;
	if ssl.conf.transport == 1
	{
		ssl.session_negotiate.compression = 0;
	}
	ext_offset = comp_offset + 1 + comp_len;
	if msg_len > ext_offset
	{
		if msg_len < ext_offset + 2
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
		ext_len = (buf[ext_offset + 0] << 8) | (buf[ext_offset + 1]);
		if (ext_len > 0 && ext_len < 4) || msg_len != ext_offset + 2 + ext_len
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
	}
	else
	{
		ext_len = 0;
	}
	ext = buf + ext_offset + 2;
	do
	{
	}
	while (0);
	while (ext_len != 0)
	{
		u32 ext_id = ((ext[0] << 8) | (ext[1]));
		u32 ext_size = ((ext[2] << 8) | (ext[3]));
		if ext_size + 4 > ext_len
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
		switch (ext_id)
		{
			case 0:
			do
			{
			}
			while (0);
			if ssl.conf.f_sni == NULL
			{
				break;

			}
			ret = ssl_parse_servername_ext(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 0xFF01:
			do
			{
			}
			while (0);
			ret = ssl_parse_renegotiation_info(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 13:
			do
			{
			}
			while (0);
			ret = ssl_parse_signature_algorithms_ext(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 10:
			do
			{
			}
			while (0);
			ret = ssl_parse_supported_elliptic_curves(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 11:
			do
			{
			}
			while (0);
			ssl.handshake.cli_exts |= (1 << 0);
			ret = ssl_parse_supported_point_formats(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 1:
			do
			{
			}
			while (0);
			ret = ssl_parse_max_fragment_length_ext(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 22:
			do
			{
			}
			while (0);
			ret = ssl_parse_encrypt_then_mac_ext(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 0x0017:
			do
			{
			}
			while (0);
			ret = ssl_parse_extended_ms_ext(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 35:
			do
			{
			}
			while (0);
			ret = ssl_parse_session_ticket_ext(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

			case 16:
			do
			{
			}
			while (0);
			ret = ssl_parse_alpn_ext(ssl, ext + 4, ext_size);
			if ret != 0
			{
				return ret;
			}
			break;

		default:
			do
			{
			}
			while (0);
		}
		ext_len -= 4 + ext_size;
		ext += 4 + ext_size;
		if ext_len > 0 && ext_len < 4
		{
			do
			{
			}
			while (0);
			return -0x7900;
		}
	}
	for (i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2)
	{
		if p[0] == 0 && p[1] == 0xFF
		{
			do
			{
			}
			while (0);
			ssl.secure_renegotiation = 1;
			break;

		}
	}
	if ssl.secure_renegotiation != 1 && ssl.conf.allow_legacy_renegotiation == 2
	{
		do
		{
		}
		while (0);
		handshake_failure = 1;
	}
	if handshake_failure == 1
	{
		if (ret = mbedtls_ssl_send_fatal_handshake_failure(ssl)) != 0
		{
			return ret;
		}
		return -0x7900;
	}
	got_common_suite = 0;
	ciphersuites = ssl.conf.ciphersuite_list[ssl.minor_ver];
	ciphersuite_info = NULL;
	for (i = 0; ciphersuites[i] != 0; i++)
	{
		for (j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2)
		{
			if p[0] != ((ciphersuites[i] >> 8) & 0xFF) || p[1] != ((ciphersuites[i]) & 0xFF)
			{
				continue;
			}
			got_common_suite = 1;
			if (ret = ssl_ciphersuite_match(ssl, ciphersuites[i], &ciphersuite_info)) != 0
			{
				return ret;
			}
			if ciphersuite_info != NULL
			{
				goto have_ciphersuite;
			}
		}
	}
	if got_common_suite
	{
		do
		{
		}
		while (0);
		mbedtls_ssl_send_fatal_handshake_failure(ssl);
		return -0x6980;
	}
	else
	{
		do
		{
		}
		while (0);
		mbedtls_ssl_send_fatal_handshake_failure(ssl);
		return -0x7380;
	}
have_ciphersuite:
	do
	{
	}
	while (0);
	ssl.session_negotiate.ciphersuite = ciphersuites[i];
	ssl.transform_negotiate.ciphersuite_info = ciphersuite_info;
	mbedtls_ssl_optimize_checksum(ssl, ssl.transform_negotiate.ciphersuite_info);
	ssl.state++;
	if ssl.conf.transport == 1
	{
		mbedtls_ssl_recv_flight_completed(ssl);
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	const mbedtls_ssl_ciphersuite_t * suite = NULL;
	const mbedtls_cipher_info_t * cipher = NULL;
	if ssl.session_negotiate.encrypt_then_mac == 0 || ssl.minor_ver == 0
	{
		*olen = 0;
		return;
	}
	if (suite = mbedtls_ssl_ciphersuite_from_id(ssl.session_negotiate.ciphersuite)) == NULL || (cipher = mbedtls_cipher_info_from_type(suite.cipher)) == NULL || cipher.mode != MBEDTLS_MODE_CBC
	{
		*olen = 0;
		return;
	}
	do
	{
	}
	while (0);
	*p++ = (i8) ((22 >> 8) & 0xFF);
	*p++ = (i8) ((22) & 0xFF);
	*p++ = 0x00;
	*p++ = 0x00;
	*olen = 4;
}

fn ssl_write_extended_ms_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	if ssl.handshake.extended_ms == 0 || ssl.minor_ver == 0
	{
		*olen = 0;
		return;
	}
	do
	{
	}
	while (0);
	*p++ = (i8) ((0x0017 >> 8) & 0xFF);
	*p++ = (i8) ((0x0017) & 0xFF);
	*p++ = 0x00;
	*p++ = 0x00;
	*olen = 4;
}

fn ssl_write_session_ticket_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	if ssl.handshake.new_session_ticket == 0
	{
		*olen = 0;
		return;
	}
	do
	{
	}
	while (0);
	*p++ = (i8) ((35 >> 8) & 0xFF);
	*p++ = (i8) ((35) & 0xFF);
	*p++ = 0x00;
	*p++ = 0x00;
	*olen = 4;
}

fn ssl_write_renegotiation_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	if ssl.secure_renegotiation != 1
	{
		*olen = 0;
		return;
	}
	do
	{
	}
	while (0);
	*p++ = (i8) ((0xFF01 >> 8) & 0xFF);
	*p++ = (i8) ((0xFF01) & 0xFF);
	{
		*p++ = 0x00;
		*p++ = 0x01;
		*p++ = 0x00;
	}
	*olen = p - buf;
}

fn ssl_write_max_fragment_length_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	if ssl.session_negotiate.mfl_code == 0
	{
		*olen = 0;
		return;
	}
	do
	{
	}
	while (0);
	*p++ = (i8) ((1 >> 8) & 0xFF);
	*p++ = (i8) ((1) & 0xFF);
	*p++ = 0x00;
	*p++ = 1;
	*p++ = ssl.session_negotiate.mfl_code;
	*olen = 5;
}

fn ssl_write_supported_point_formats_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	u8 * p = buf;
	((void) ssl);
	if (ssl.handshake.cli_exts & (1 << 0)) == 0
	{
		*olen = 0;
		return;
	}
	do
	{
	}
	while (0);
	*p++ = (i8) ((11 >> 8) & 0xFF);
	*p++ = (i8) ((11) & 0xFF);
	*p++ = 0x00;
	*p++ = 2;
	*p++ = 1;
	*p++ = 0;
	*olen = 6;
}

fn ssl_write_alpn_ext(mbedtls_ssl_context * ssl, u8 * buf, usize * olen)
{
	if ssl.alpn_chosen == NULL
	{
		*olen = 0;
		return;
	}
	do
	{
	}
	while (0);
	buf[0] = (i8) ((16 >> 8) & 0xFF);
	buf[1] = (i8) ((16) & 0xFF);
	*olen = 7 + strlen(ssl.alpn_chosen);
	buf[2] = (i8) (((*olen - 4) >> 8) & 0xFF);
	buf[3] = (i8) (((*olen - 4)) & 0xFF);
	buf[4] = (i8) (((*olen - 6) >> 8) & 0xFF);
	buf[5] = (i8) (((*olen - 6)) & 0xFF);
	buf[6] = (i8) (((*olen - 7)) & 0xFF);
	memcpy(buf + 7, ssl.alpn_chosen, *olen - 7);
}

fn ssl_write_hello_verify_request(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	u8 * p = ssl.out_msg + 4;
	u8 * cookie_len_byte;
	do
	{
	}
	while (0);
	mbedtls_ssl_write_version(ssl.major_ver, ssl.minor_ver, ssl.conf.transport, p);
	do
	{
	}
	while (0);
	p += 2;
	if ssl.conf.f_cookie_write == NULL
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	cookie_len_byte = p++;
	if (ret = ssl.conf.f_cookie_write(ssl.conf.p_cookie, &p, ssl.out_buf + (16384 + 0 + 29 + 48 + 256), ssl.cli_id, ssl.cli_id_len)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	*cookie_len_byte = (i8) (p - (cookie_len_byte + 1));
	do
	{
	}
	while (0);
	ssl.out_msglen = p - ssl.out_msg;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 3;
	ssl.state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_write_server_hello(mbedtls_ssl_context * ssl) -> i32
{
	time_t t;
	i32 ret;
	usize olen, ext_len = 0, n;
	u8 *buf, *p;
	do
	{
	}
	while (0);
	if ssl.conf.transport == 1 && ssl.handshake.verify_cookie_len != 0
	{
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		return ssl_write_hello_verify_request(ssl);
	}
	if ssl.conf.f_rng == NULL
	{
		do
		{
		}
		while (0);
		return -0x7400;
	}
	buf = ssl.out_msg;
	p = buf + 4;
	mbedtls_ssl_write_version(ssl.major_ver, ssl.minor_ver, ssl.conf.transport, p);
	p += 2;
	do
	{
	}
	while (0);
	t = time(NULL);
	*p++ = (i8) (t >> 24);
	*p++ = (i8) (t >> 16);
	*p++ = (i8) (t >> 8);
	*p++ = (i8) (t);
	do
	{
	}
	while (0);
	if (ret = ssl.conf.f_rng(ssl.conf.p_rng, p, 28)) != 0
	{
		return ret;
	}
	p += 28;
	memcpy(ssl.handshake.randbytes + 32, buf + 6, 32);
	do
	{
	}
	while (0);
	if ssl.handshake.resume == 0 && ssl.session_negotiate.id_len != 0 && ssl.conf.f_get_cache != NULL && ssl.conf.f_get_cache(ssl.conf.p_cache, ssl.session_negotiate) == 0
	{
		do
		{
		}
		while (0);
		ssl.handshake.resume = 1;
	}
	if ssl.handshake.resume == 0
	{
		ssl.state++;
		ssl.session_negotiate.start = time(NULL);
		if ssl.handshake.new_session_ticket != 0
		{
			ssl.session_negotiate.id_len = n = 0;
			memset(ssl.session_negotiate.id, 0, 32);
		}
		else
		{
			ssl.session_negotiate.id_len = n = 32;
			if (ret = ssl.conf.f_rng(ssl.conf.p_rng, ssl.session_negotiate.id, n)) != 0
			{
				return ret;
			}
		}
	}
	else
	{
		n = ssl.session_negotiate.id_len;
		ssl.state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
		if (ret = mbedtls_ssl_derive_keys(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	*p++ = (i8) ssl.session_negotiate.id_len;
	memcpy(p, ssl.session_negotiate.id, ssl.session_negotiate.id_len);
	p += ssl.session_negotiate.id_len;
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	*p++ = (i8) (ssl.session_negotiate.ciphersuite >> 8);
	*p++ = (i8) (ssl.session_negotiate.ciphersuite);
	*p++ = (i8) (ssl.session_negotiate.compression);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	ssl_write_renegotiation_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_max_fragment_length_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_encrypt_then_mac_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_extended_ms_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_session_ticket_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_supported_point_formats_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	ssl_write_alpn_ext(ssl, p + 2 + ext_len, &olen);
	ext_len += olen;
	do
	{
	}
	while (0);
	if ext_len > 0
	{
		*p++ = (i8) ((ext_len >> 8) & 0xFF);
		*p++ = (i8) ((ext_len) &0xFF);
		p += ext_len;
	}
	ssl.out_msglen = p - buf;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 2;
	ret = mbedtls_ssl_write_record(ssl);
	do
	{
	}
	while (0);
	return ret;
}

fn ssl_write_certificate_request(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = -0x7080;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	usize dn_size, total_dn_size;
	usize ct_len, sa_len;
	u8 *buf, *p;
	const u8 * const end = ssl.out_msg + 16384;
	const mbedtls_x509_crt * crt;
	i32 authmode;
	do
	{
	}
	while (0);
	ssl.state++;
	if ssl.handshake.sni_authmode != 3
	{
		authmode = ssl.handshake.sni_authmode;
	}
	else
	{
		authmode = ssl.conf.authmode;
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE || authmode == 0
	{
		do
		{
		}
		while (0);
		return 0;
	}
	buf = ssl.out_msg;
	p = buf + 4;
	ct_len = 0;
	p[1 + ct_len++] = 1;
	p[1 + ct_len++] = 64;
	p[0] = (i8) ct_len++;
	p += ct_len;
	sa_len = 0;
	if ssl.minor_ver == 3
	{
		ssl.handshake.verify_sig_alg = 4;
		if ssl.transform_negotiate.ciphersuite_info.mac == MBEDTLS_MD_SHA384
		{
			ssl.handshake.verify_sig_alg = 5;
		}
		p[2 + sa_len++] = ssl.handshake.verify_sig_alg;
		p[2 + sa_len++] = 1;
		p[2 + sa_len++] = ssl.handshake.verify_sig_alg;
		p[2 + sa_len++] = 3;
		p[0] = (i8) (sa_len >> 8);
		p[1] = (i8) (sa_len);
		sa_len += 2;
		p += sa_len;
	}
	p += 2;
	if ssl.handshake.sni_ca_chain != NULL
	{
		crt = ssl.handshake.sni_ca_chain;
	}
	else
	{
		crt = ssl.conf.ca_chain;
	}
	total_dn_size = 0;
	while (crt != NULL && crt.version != 0)
	{
		dn_size = crt.subject_raw.len;
		if end < p || (usize)(end - p) < dn_size || (usize)(end - p) < 2 + dn_size
		{
			do
			{
			}
			while (0);
			break;

		}
		*p++ = (i8) (dn_size >> 8);
		*p++ = (i8) (dn_size);
		memcpy(p, crt.subject_raw.p, dn_size);
		p += dn_size;
		do
		{
		}
		while (0);
		total_dn_size += 2 + dn_size;
		crt = crt.next;
	}
	ssl.out_msglen = p - buf;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 13;
	ssl.out_msg[4 + ct_len + sa_len] = (i8) (total_dn_size >> 8);
	ssl.out_msg[5 + ct_len + sa_len] = (i8) (total_dn_size);
	ret = mbedtls_ssl_write_record(ssl);
	do
	{
	}
	while (0);
	return ret;
}

fn ssl_get_ecdh_params_from_cert(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	if !mbedtls_pk_can_do(mbedtls_ssl_own_key(ssl), MBEDTLS_PK_ECKEY)
	{
		do
		{
		}
		while (0);
		return -0x6D00;
	}
	if (ret = mbedtls_ecdh_get_params(&ssl.handshake.ecdh_ctx, mbedtls_pk_ec(*mbedtls_ssl_own_key(ssl)), MBEDTLS_ECDH_OURS)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	return 0;
}

fn ssl_write_server_key_exchange(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	usize n = 0;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	u8 * p = ssl.out_msg + 4;
	u8 * dig_i32 = p;
	usize dig_signed_len = 0, len;
	((void) dig_signed);
	((void) dig_signed_len);
	((void) len);
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA
	{
		ssl_get_ecdh_params_from_cert(ssl);
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
	{
		*(p++) = 0x00;
		*(p++) = 0x00;
		n += 2;
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK
	{
		if ssl.conf.dhm_P.p == NULL || ssl.conf.dhm_G.p == NULL
		{
			do
			{
			}
			while (0);
			return -0x7100;
		}
		if (ret = mbedtls_mpi_copy(&ssl.handshake.dhm_ctx.P, &ssl.conf.dhm_P)) != 0 || (ret = mbedtls_mpi_copy(&ssl.handshake.dhm_ctx.G, &ssl.conf.dhm_G)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if (ret = mbedtls_dhm_make_params(&ssl.handshake.dhm_ctx, (int) mbedtls_mpi_size(&ssl.handshake.dhm_ctx.P), p, &len, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		dig_i32 = p;
		dig_signed_len = len;
		p += len;
		n += len;
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
	{
		const mbedtls_ecp_curve_info ** curve = NULL;
		const mbedtls_ecp_group_id * gid;
		for (gid = ssl.conf.curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++)
			for (curve = ssl.handshake.curves; *curve != NULL; curve++)
				if (*curve)->grp_id == *gid
				{
					goto curve_matching_done;
				}
curve_matching_done:
		if curve == NULL || *curve == NULL
		{
			do
			{
			}
			while (0);
			return -0x7380;
		}
		do
		{
		}
		while (0);
		if (ret = mbedtls_ecp_group_load(&ssl.handshake.ecdh_ctx.grp, (*curve)->grp_id)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if (ret = mbedtls_ecdh_make_params(&ssl.handshake.ecdh_ctx, &len, p, 16384 - n, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		dig_i32 = p;
		dig_signed_len = len;
		p += len;
		n += len;
		do
		{
		}
		while (0);
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA
	{
		usize signature_len = 0;
		u32 hashlen = 0;
		u8 hash[64];
		mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
		if ssl.minor_ver == 3
		{
			md_alg = mbedtls_ssl_md_alg_from_hash(ssl.handshake.sig_alg);
			if md_alg == MBEDTLS_MD_NONE
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
		}
		else
		{
			md_alg = MBEDTLS_MD_NONE;
		}
		if md_alg != MBEDTLS_MD_NONE
		{
			mbedtls_md_context_t ctx;
			const mbedtls_md_info_t * md_info = mbedtls_md_info_from_type(md_alg);
			mbedtls_md_init(&ctx);
			hashlen = 0;
			if (ret = mbedtls_md_setup(&ctx, md_info, 0)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			mbedtls_md_starts(&ctx);
			mbedtls_md_update(&ctx, ssl.handshake.randbytes, 64);
			mbedtls_md_update(&ctx, dig_signed, dig_signed_len);
			mbedtls_md_finish(&ctx, hash);
			mbedtls_md_free(&ctx);
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		do
		{
		}
		while (0);
		if mbedtls_ssl_own_key(ssl) == NULL
		{
			do
			{
			}
			while (0);
			return -0x7600;
		}
		if ssl.minor_ver == 3
		{
			*(p++) = ssl.handshake.sig_alg;
			*(p++) = mbedtls_ssl_sig_from_pk(mbedtls_ssl_own_key(ssl));
			n += 2;
		}
		if (ret = mbedtls_pk_sign(mbedtls_ssl_own_key(ssl), md_alg, hash, hashlen, p + 2, &signature_len, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		*(p++) = (i8) (signature_len >> 8);
		*(p++) = (i8) (signature_len);
		n += 2;
		do
		{
		}
		while (0);
		n += signature_len;
	}
	ssl.out_msglen = 4 + n;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 12;
	ssl.state++;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_write_server_hello_done(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	do
	{
	}
	while (0);
	ssl.out_msglen = 4;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 14;
	ssl.state++;
	if ssl.conf.transport == 1
	{
		mbedtls_ssl_send_flight_completed(ssl);
	}
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_client_dh_public(mbedtls_ssl_context * ssl, u8 ** p, const u8 * end) -> i32
{
	i32 ret = -0x7080;
	usize n;
	if *p + 2 > end
	{
		do
		{
		}
		while (0);
		return -0x7C00;
	}
	n = ((*p)[0] << 8) | (*p)[1];
	*p += 2;
	if *p + n > end
	{
		do
		{
		}
		while (0);
		return -0x7C00;
	}
	if (ret = mbedtls_dhm_read_public(&ssl.handshake.dhm_ctx, *p, n)) != 0
	{
		do
		{
		}
		while (0);
		return -0x7C80;
	}
	*p += n;
	do
	{
	}
	while (0);
	return ret;
}

fn ssl_parse_encrypted_pms(mbedtls_ssl_context * ssl, const u8 * p, const u8 * end, usize pms_offset) -> i32
{
	i32 ret;
	usize len = mbedtls_pk_get_len(mbedtls_ssl_own_key(ssl));
	u8 * pms = ssl.handshake.premaster + pms_offset;
	u8 ver[2];
	u8 fake_pms[48], peer_pms[48];
	u8 mask;
	usize i, peer_pmslen;
	u32 diff;
	if !mbedtls_pk_can_do(mbedtls_ssl_own_key(ssl), MBEDTLS_PK_RSA)
	{
		do
		{
		}
		while (0);
		return -0x7600;
	}
	if ssl.minor_ver != 0
	{
		if *p++ != ((len >> 8) & 0xFF) || *p++ != ((len) &0xFF)
		{
			do
			{
			}
			while (0);
			return -0x7C00;
		}
	}
	if p + len != end
	{
		do
		{
		}
		while (0);
		return -0x7C00;
	}
	mbedtls_ssl_write_version(ssl.handshake.max_major_ver, ssl.handshake.max_minor_ver, ssl.conf.transport, ver);
	ret = ssl.conf.f_rng(ssl.conf.p_rng, fake_pms, sizeof(fake_pms));
	if ret != 0
	{
		return ret;
	}
	ret = mbedtls_pk_decrypt(mbedtls_ssl_own_key(ssl), p, len, peer_pms, &peer_pmslen, sizeof(peer_pms), ssl.conf.f_rng, ssl.conf.p_rng);
	diff = (i32 int) ret;
	diff |= peer_pmslen ^ 48;
	diff |= peer_pms[0] ^ ver[0];
	diff |= peer_pms[1] ^ ver[1];
	if sizeof(ssl.handshake.premaster) < pms_offset || sizeof(ssl.handshake.premaster) - pms_offset < 48
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	ssl.handshake.pmslen = 48;
	mask = -((diff | -diff) >> (sizeof(i32 int) * 8 - 1));
	for (i = 0; i < ssl.handshake.pmslen; i++)
	{
		pms[i] = (mask & fake_pms[i]) | ((~mask) & peer_pms[i]);
	}
	return 0;
}

fn ssl_parse_client_psk_identity(mbedtls_ssl_context * ssl, u8 ** p, const u8 * end) -> i32
{
	i32 ret = 0;
	usize n;
	if ssl.conf.f_psk == NULL && (ssl.conf.psk == NULL || ssl.conf.psk_identity == NULL || ssl.conf.psk_identity_len == 0 || ssl.conf.psk_len == 0)
	{
		do
		{
		}
		while (0);
		return -0x7600;
	}
	if *p + 2 > end
	{
		do
		{
		}
		while (0);
		return -0x7C00;
	}
	n = ((*p)[0] << 8) | (*p)[1];
	*p += 2;
	if n < 1 || n > 65535 || *p + n > end
	{
		do
		{
		}
		while (0);
		return -0x7C00;
	}
	if ssl.conf.f_psk != NULL
	{
		if ssl.conf.f_psk(ssl.conf.p_psk, ssl, *p, n) != 0
		{
			ret = -0x6C80;
		}
	}
	else
	{
		if n != ssl.conf.psk_identity_len || mbedtls_ssl_safer_memcmp(ssl.conf.psk_identity, *p, n) != 0
		{
			ret = -0x6C80;
		}
	}
	if ret == -0x6C80
	{
		do
		{
		}
		while (0);
		if (ret = mbedtls_ssl_send_alert_message(ssl, 2, 115)) != 0
		{
			return ret;
		}
		return -0x6C80;
	}
	*p += n;
	return 0;
}

fn ssl_parse_client_key_exchange(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info;
	u8 *p, *end;
	ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	do
	{
	}
	while (0);
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	p = ssl.in_msg + mbedtls_ssl_hs_hdr_len(ssl);
	end = ssl.in_msg + ssl.in_hslen;
	if ssl.in_msgtype != 22
	{
		do
		{
		}
		while (0);
		return -0x7C00;
	}
	if ssl.in_msg[0] != 16
	{
		do
		{
		}
		while (0);
		return -0x7C00;
	}
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA
	{
		if (ret = ssl_parse_client_dh_public(ssl, &p, end)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if p != end
		{
			do
			{
			}
			while (0);
			return -0x7C00;
		}
		if (ret = mbedtls_dhm_calc_secret(&ssl.handshake.dhm_ctx, ssl.handshake.premaster, sizeof(union mbedtls_ssl_premaster_secret), &ssl.handshake.pmslen, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
		{
			do
			{
			}
			while (0);
			return -0x7D00;
		}
		do
		{
		}
		while (0);
	}
	else
		if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA
		{
			if (ret = mbedtls_ecdh_read_public(&ssl.handshake.ecdh_ctx, p, end - p)) != 0
			{
				do
				{
				}
				while (0);
				return -0x7C80;
			}
			do
			{
			}
			while (0);
			if (ret = mbedtls_ecdh_calc_secret(&ssl.handshake.ecdh_ctx, &ssl.handshake.pmslen, ssl.handshake.premaster, 1024, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
			{
				do
				{
				}
				while (0);
				return -0x7D00;
			}
			do
			{
			}
			while (0);
		}
		else
			if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK
			{
				if (ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0
				{
					do
					{
					}
					while (0);
					return ret;
				}
				if p != end
				{
					do
					{
					}
					while (0);
					return -0x7C00;
				}
				if (ret = mbedtls_ssl_psk_derive_premaster(ssl, ciphersuite_info.key_exchange)) != 0
				{
					do
					{
					}
					while (0);
					return ret;
				}
			}
			else
				if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK
				{
					if (ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0
					{
						do
						{
						}
						while (0);
						return ret;
					}
					if (ret = ssl_parse_encrypted_pms(ssl, p, end, 2)) != 0
					{
						do
						{
						}
						while (0);
						return ret;
					}
					if (ret = mbedtls_ssl_psk_derive_premaster(ssl, ciphersuite_info.key_exchange)) != 0
					{
						do
						{
						}
						while (0);
						return ret;
					}
				}
				else
					if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK
					{
						if (ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0
						{
							do
							{
							}
							while (0);
							return ret;
						}
						if (ret = ssl_parse_client_dh_public(ssl, &p, end)) != 0
						{
							do
							{
							}
							while (0);
							return ret;
						}
						if p != end
						{
							do
							{
							}
							while (0);
							return -0x7C00;
						}
						if (ret = mbedtls_ssl_psk_derive_premaster(ssl, ciphersuite_info.key_exchange)) != 0
						{
							do
							{
							}
							while (0);
							return ret;
						}
					}
					else
						if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
						{
							if (ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0
							{
								do
								{
								}
								while (0);
								return ret;
							}
							if (ret = mbedtls_ecdh_read_public(&ssl.handshake.ecdh_ctx, p, end - p)) != 0
							{
								do
								{
								}
								while (0);
								return -0x7C80;
							}
							do
							{
							}
							while (0);
							if (ret = mbedtls_ssl_psk_derive_premaster(ssl, ciphersuite_info.key_exchange)) != 0
							{
								do
								{
								}
								while (0);
								return ret;
							}
						}
						else
							if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA
							{
								if (ret = ssl_parse_encrypted_pms(ssl, p, end, 0)) != 0
								{
									do
									{
									}
									while (0);
									return ret;
								}
							}
							else
							{
								do
								{
								}
								while (0);
								return -0x6C00;
							}
	if (ret = mbedtls_ssl_derive_keys(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	ssl.state++;
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_parse_certificate_verify(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = -0x7080;
	usize i, sig_len;
	u8 hash[48];
	u8 * hash_start = hash;
	usize hashlen;
	mbedtls_pk_type_t pk_alg;
	mbedtls_md_type_t md_alg;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE || ssl.session_negotiate.peer_cert == NULL
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	ssl.handshake.calc_verify(ssl, hash);
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	ssl.state++;
	if ssl.in_msgtype != 22 || ssl.in_msg[0] != 15
	{
		do
		{
		}
		while (0);
		return -0x7D80;
	}
	i = mbedtls_ssl_hs_hdr_len(ssl);
	if ssl.minor_ver == 3
	{
		if i + 2 > ssl.in_hslen
		{
			do
			{
			}
			while (0);
			return -0x7D80;
		}
		if ssl.in_msg[i] != ssl.handshake.verify_sig_alg
		{
			do
			{
			}
			while (0);
			return -0x7D80;
		}
		md_alg = mbedtls_ssl_md_alg_from_hash(ssl.handshake.verify_sig_alg);
		hashlen = 0;
		i++;
		if (pk_alg = mbedtls_ssl_pk_alg_from_sig(ssl.in_msg[i])) == MBEDTLS_PK_NONE
		{
			do
			{
			}
			while (0);
			return -0x7D80;
		}
		if !mbedtls_pk_can_do(&ssl.session_negotiate.peer_cert.pk, pk_alg)
		{
			do
			{
			}
			while (0);
			return -0x7D80;
		}
		i++;
	}
	else
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	if i + 2 > ssl.in_hslen
	{
		do
		{
		}
		while (0);
		return -0x7D80;
	}
	sig_len = (ssl.in_msg[i] << 8) | ssl.in_msg[i + 1];
	i += 2;
	if i + sig_len != ssl.in_hslen
	{
		do
		{
		}
		while (0);
		return -0x7D80;
	}
	if (ret = mbedtls_pk_verify(&ssl.session_negotiate.peer_cert.pk, md_alg, hash_start, hashlen, ssl.in_msg + i, sig_len)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return ret;
}

fn ssl_write_new_session_ticket(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	usize tlen;
	u32 lifetime;
	do
	{
	}
	while (0);
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 4;
	if (ret = ssl.conf.f_ticket_write(ssl.conf.p_ticket, ssl.session_negotiate, ssl.out_msg + 10, ssl.out_msg + 16384, &tlen, &lifetime)) != 0
	{
		do
		{
		}
		while (0);
		tlen = 0;
	}
	ssl.out_msg[4] = (lifetime >> 24) & 0xFF;
	ssl.out_msg[5] = (lifetime >> 16) & 0xFF;
	ssl.out_msg[6] = (lifetime >> 8) & 0xFF;
	ssl.out_msg[7] = (lifetime) &0xFF;
	ssl.out_msg[8] = (i8) ((tlen >> 8) & 0xFF);
	ssl.out_msg[9] = (i8) ((tlen) &0xFF);
	ssl.out_msglen = 10 + tlen;
	ssl.handshake.new_session_ticket = 0;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_handshake_server_step(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = 0;
	if ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl.handshake == NULL
	{
		return -0x7100;
	}
	do
	{
	}
	while (0);
	if (ret = mbedtls_ssl_flush_output(ssl)) != 0
	{
		return ret;
	}
	if ssl.conf.transport == 1 && ssl.handshake.retransmit_state == 1
	{
		if (ret = mbedtls_ssl_resend(ssl)) != 0
		{
			return ret;
		}
	}
	switch (ssl.state)
	{
		case MBEDTLS_SSL_HELLO_REQUEST:
		ssl.state = MBEDTLS_SSL_CLIENT_HELLO;
		break;

		case MBEDTLS_SSL_CLIENT_HELLO:
		ret = ssl_parse_client_hello(ssl);
		break;

		case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:
		return -0x6A80;
		case MBEDTLS_SSL_SERVER_HELLO:
		ret = ssl_write_server_hello(ssl);
		break;

		case MBEDTLS_SSL_SERVER_CERTIFICATE:
		ret = mbedtls_ssl_write_certificate(ssl);
		break;

		case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
		ret = ssl_write_server_key_exchange(ssl);
		break;

		case MBEDTLS_SSL_CERTIFICATE_REQUEST:
		ret = ssl_write_certificate_request(ssl);
		break;

		case MBEDTLS_SSL_SERVER_HELLO_DONE:
		ret = ssl_write_server_hello_done(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_CERTIFICATE:
		ret = mbedtls_ssl_parse_certificate(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
		ret = ssl_parse_client_key_exchange(ssl);
		break;

		case MBEDTLS_SSL_CERTIFICATE_VERIFY:
		ret = ssl_parse_certificate_verify(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
		ret = mbedtls_ssl_parse_change_cipher_spec(ssl);
		break;

		case MBEDTLS_SSL_CLIENT_FINISHED:
		ret = mbedtls_ssl_parse_finished(ssl);
		break;

		case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
		if ssl.handshake.new_session_ticket != 0
		{
			ret = ssl_write_new_session_ticket(ssl);
		}
		else
		{
			ret = mbedtls_ssl_write_change_cipher_spec(ssl);
		}
		break;

		case MBEDTLS_SSL_SERVER_FINISHED:
		ret = mbedtls_ssl_write_finished(ssl);
		break;

		case MBEDTLS_SSL_FLUSH_BUFFERS:
		do
		{
		}
		while (0);
		ssl.state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
		break;

		case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
		mbedtls_ssl_handshake_wrapup(ssl);
		break;

	default:
		do
		{
		}
		while (0);
		return -0x7100;
	}
	return ret;
}

typedef struct
{
	u8 name[4];
	u32 generation_time;
	mbedtls_cipher_context_t ctx;
} mbedtls_ssl_ticket_key;
typedef struct
{
	mbedtls_ssl_ticket_key keys[2];
	u8 active;
	u32 ticket_lifetime;
	i32 (*f_rng)(void *, u8 *, usize);
	void * p_rng;
	mbedtls_threading_mutex_t mutex;
} mbedtls_ssl_ticket_context;

mbedtls_ssl_ticket_write_t mbedtls_ssl_ticket_write;
mbedtls_ssl_ticket_parse_t mbedtls_ssl_ticket_parse;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_ssl_ticket_init(mbedtls_ssl_ticket_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_ssl_ticket_context));
	mbedtls_mutex_init(&ctx.mutex);
}

fn ssl_ticket_gen_key(mbedtls_ssl_ticket_context * ctx, u8 index) -> i32
{
	i32 ret;
	u8 buf[32];
	mbedtls_ssl_ticket_key * key = ctx.keys + index;
	key.generation_time = (u32) time(NULL);
	if (ret = ctx.f_rng(ctx.p_rng, key.name, sizeof(key.name))) != 0
	{
		return ret;
	}
	if (ret = ctx.f_rng(ctx.p_rng, buf, sizeof(buf))) != 0
	{
		return ret;
	}
	ret = mbedtls_cipher_setkey(&key.ctx, buf, mbedtls_cipher_get_key_bitlen(&key.ctx), MBEDTLS_ENCRYPT);
	zeroize(buf, sizeof(buf));
	return ret;
}

fn ssl_ticket_update_keys(mbedtls_ssl_ticket_context * ctx) -> i32
{
	if ctx.ticket_lifetime != 0
	{
		u32 current_time = (u32) time(NULL);
		u32 key_time = ctx.keys[ctx.active].generation_time;
		if current_time > key_time && current_time - key_time < ctx.ticket_lifetime
		{
			return 0;
		}
		ctx.active = 1 - ctx.active;
		return ssl_ticket_gen_key(ctx, ctx.active);
	}
	else
	{
		return 0;
	}
}

pub fn mbedtls_ssl_ticket_setup(mbedtls_ssl_ticket_context * ctx, i32 (*f_rng)(void *, u8 *, usize), void * p_rng, mbedtls_cipher_type_t cipher, u32 lifetime) -> i32
{
	i32 ret;
	const mbedtls_cipher_info_t * cipher_info;
	ctx.f_rng = f_rng;
	ctx.p_rng = p_rng;
	ctx.ticket_lifetime = lifetime;
	cipher_info = mbedtls_cipher_info_from_type(cipher);
	if cipher_info == NULL
	{
		return -0x7100;
	}
	if cipher_info.mode != MBEDTLS_MODE_GCM && cipher_info.mode != MBEDTLS_MODE_CCM
	{
		return -0x7100;
	}
	if cipher_info.key_bitlen > 8 * 32
	{
		return -0x7100;
	}
	if (ret = mbedtls_cipher_setup(&ctx.keys[0].ctx, cipher_info)) != 0 || (ret = mbedtls_cipher_setup(&ctx.keys[1].ctx, cipher_info)) != 0
	{
		return ret;
	}
	if (ret = ssl_ticket_gen_key(ctx, 0)) != 0 || (ret = ssl_ticket_gen_key(ctx, 1)) != 0
	{
		return ret;
	}
	return 0;
}

fn ssl_save_session(const mbedtls_ssl_session * session, u8 * buf, usize buf_len, usize * olen) -> i32
{
	u8 * p = buf;
	usize left = buf_len;
	usize cert_len;
	if left < sizeof(mbedtls_ssl_session)
	{
		return -0x6A00;
	}
	memcpy(p, session, sizeof(mbedtls_ssl_session));
	p += sizeof(mbedtls_ssl_session);
	left -= sizeof(mbedtls_ssl_session);
	if session.peer_cert == NULL
	{
		cert_len = 0;
	}
	else
	{
		cert_len = session.peer_cert.raw.len;
	}
	if left < 3 + cert_len
	{
		return -0x6A00;
	}
	*p++ = (i8) (cert_len >> 16 & 0xFF);
	*p++ = (i8) (cert_len >> 8 & 0xFF);
	*p++ = (i8) (cert_len & 0xFF);
	if session.peer_cert != NULL
	{
		memcpy(p, session.peer_cert.raw.p, cert_len);
	}
	p += cert_len;
	*olen = p - buf;
	return 0;
}

fn ssl_load_session(mbedtls_ssl_session * session, const u8 * buf, usize len) -> i32
{
	const u8 * p = buf;
	const u8 * const end = buf + len;
	usize cert_len;
	if p + sizeof(mbedtls_ssl_session) > end
	{
		return -0x7100;
	}
	memcpy(session, p, sizeof(mbedtls_ssl_session));
	p += sizeof(mbedtls_ssl_session);
	if p + 3 > end
	{
		return -0x7100;
	}
	cert_len = (p[0] << 16) | (p[1] << 8) | p[2];
	p += 3;
	if cert_len == 0
	{
		session.peer_cert = NULL;
	}
	else
	{
		i32 ret;
		if p + cert_len > end
		{
			return -0x7100;
		}
		session.peer_cert = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
		if session.peer_cert == NULL
		{
			return -0x7F00;
		}
		mbedtls_x509_crt_init(session.peer_cert);
		if (ret = mbedtls_x509_crt_parse_der(session.peer_cert, p, cert_len)) != 0
		{
			mbedtls_x509_crt_free(session.peer_cert);
			mbedtls_free(session.peer_cert);
			session.peer_cert = NULL;
			return ret;
		}
		p += cert_len;
	}
	if p != end
	{
		return -0x7100;
	}
	return 0;
}

pub fn mbedtls_ssl_ticket_write(void * p_ticket, const mbedtls_ssl_session * session, u8 * start, const u8 * end, usize * tlen, u32 * ticket_lifetime) -> i32
{
	i32 ret;
	mbedtls_ssl_ticket_context * ctx = p_ticket;
	mbedtls_ssl_ticket_key * key;
	u8 * key_name = start;
	u8 * iv = start + 4;
	u8 * state_len_bytes = iv + 12;
	u8 * state = state_len_bytes + 2;
	u8 * tag;
	usize clear_len, ciph_len;
	*tlen = 0;
	if ctx == NULL || ctx.f_rng == NULL
	{
		return -0x7100;
	}
	if end - start < 4 + 12 + 2 + 16
	{
		return -0x6A00;
	}
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	if (ret = ssl_ticket_update_keys(ctx)) != 0
	{
		goto cleanup;
	}
	key = &ctx.keys[ctx.active];
	*ticket_lifetime = ctx.ticket_lifetime;
	memcpy(key_name, key.name, 4);
	if (ret = ctx.f_rng(ctx.p_rng, iv, 12)) != 0
	{
		goto cleanup;
	}
	if (ret = ssl_save_session(session, state, end - state, &clear_len)) != 0 || (i32 long) clear_len > 65535
	{
		goto cleanup;
	}
	state_len_bytes[0] = (clear_len >> 8) & 0xff;
	state_len_bytes[1] = (clear_len) &0xff;
	tag = state + clear_len;
	if (ret = mbedtls_cipher_auth_encrypt(&key.ctx, iv, 12, key_name, 4 + 12 + 2, state, clear_len, state, &ciph_len, tag, 16)) != 0
	{
		goto cleanup;
	}
	if ciph_len != clear_len
	{
		ret = -0x6C00;
		goto cleanup;
	}
	*tlen = 4 + 12 + 2 + 16 + ciph_len;
cleanup:
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

fn * ssl_ticket_select_key(mbedtls_ssl_ticket_context * ctx, const u8 name[4]) -> mbedtls_ssl_ticket_key
{
	u8 i;
	for (i = 0; i < sizeof(ctx.keys) / sizeof(*ctx.keys); i++)
		if memcmp(name, ctx.keys[i].name, 4) == 0
		{
			return &ctx.keys[i];
		}
	return NULL;
}

pub fn mbedtls_ssl_ticket_parse(void * p_ticket, mbedtls_ssl_session * session, u8 * buf, usize len) -> i32
{
	i32 ret;
	mbedtls_ssl_ticket_context * ctx = p_ticket;
	mbedtls_ssl_ticket_key * key;
	u8 * key_name = buf;
	u8 * iv = buf + 4;
	u8 * enc_len_p = iv + 12;
	u8 * ticket = enc_len_p + 2;
	u8 * tag;
	usize enc_len, clear_len;
	if ctx == NULL || ctx.f_rng == NULL
	{
		return -0x7100;
	}
	if len < 4 + 12 + 2 + 16
	{
		return -0x7100;
	}
	if (ret = mbedtls_mutex_lock(&ctx.mutex)) != 0
	{
		return ret;
	}
	if (ret = ssl_ticket_update_keys(ctx)) != 0
	{
		goto cleanup;
	}
	enc_len = (enc_len_p[0] << 8) | enc_len_p[1];
	tag = ticket + enc_len;
	if len != 4 + 12 + 2 + enc_len + 16
	{
		ret = -0x7100;
		goto cleanup;
	}
	if (key = ssl_ticket_select_key(ctx, key_name)) == NULL
	{
		ret = -0x6D80;
		goto cleanup;
	}
	if (ret = mbedtls_cipher_auth_decrypt(&key.ctx, iv, 12, key_name, 4 + 12 + 2, ticket, enc_len, ticket, &clear_len, tag, 16)) != 0
	{
		if ret == -0x6300
		{
			ret = -0x7180;
		}
		goto cleanup;
	}
	if clear_len != enc_len
	{
		ret = -0x6C00;
		goto cleanup;
	}
	if (ret = ssl_load_session(session, ticket, clear_len)) != 0
	{
		goto cleanup;
	}
	{
		time_t current_time = time(NULL);
		if current_time < session.start || (u32)(current_time - session.start) > ctx.ticket_lifetime
		{
			ret = -0x6D80;
			goto cleanup;
		}
	}
cleanup:
	if mbedtls_mutex_unlock(&ctx.mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

pub fn mbedtls_ssl_ticket_free(mbedtls_ssl_ticket_context * ctx)
{
	mbedtls_cipher_free(&ctx.keys[0].ctx);
	mbedtls_cipher_free(&ctx.keys[1].ctx);
	mbedtls_mutex_free(&ctx.mutex);
	zeroize(ctx, sizeof(mbedtls_ssl_ticket_context));
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

fn usize ssl_ep_len(const mbedtls_ssl_context * ssl) -> inline
{
	if ssl.conf.transport == 1
	{
		return 2;
	}
	return 0;
}

fn ssl_set_timer(mbedtls_ssl_context * ssl, u32 millisecs)
{
	if ssl.f_set_timer == NULL
	{
		return;
	}
	do
	{
	}
	while (0);
	ssl.f_set_timer(ssl.p_timer, millisecs / 4, millisecs);
}

fn ssl_check_timer(mbedtls_ssl_context * ssl) -> i32
{
	if ssl.f_get_timer == NULL
	{
		return 0;
	}
	if ssl.f_get_timer(ssl.p_timer) == 2
	{
		do
		{
		}
		while (0);
		return -1;
	}
	return 0;
}

fn ssl_double_retransmit_timeout(mbedtls_ssl_context * ssl) -> i32
{
	u32 new_timeout;
	if ssl.handshake.retransmit_timeout >= ssl.conf.hs_timeout_max
	{
		return -1;
	}
	new_timeout = 2 * ssl.handshake.retransmit_timeout;
	if new_timeout < ssl.handshake.retransmit_timeout || new_timeout > ssl.conf.hs_timeout_max
	{
		new_timeout = ssl.conf.hs_timeout_max;
	}
	ssl.handshake.retransmit_timeout = new_timeout;
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_reset_retransmit_timeout(mbedtls_ssl_context * ssl)
{
	ssl.handshake.retransmit_timeout = ssl.conf.hs_timeout_min;
	do
	{
	}
	while (0);
}

static u32 mfl_code_to_length[5] =
{
	16384, 512, 1024, 2048, 4096,
};
fn ssl_session_copy(mbedtls_ssl_session * dst, const mbedtls_ssl_session * src) -> i32
{
	mbedtls_ssl_session_free(dst);
	memcpy(dst, src, sizeof(mbedtls_ssl_session));
	if src.peer_cert != NULL
	{
		i32 ret;
		dst.peer_cert = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
		if dst.peer_cert == NULL
		{
			return -0x7F00;
		}
		mbedtls_x509_crt_init(dst.peer_cert);
		if (ret = mbedtls_x509_crt_parse_der(dst.peer_cert, src.peer_cert.raw.p, src.peer_cert.raw.len)) != 0
		{
			mbedtls_free(dst.peer_cert);
			dst.peer_cert = NULL;
			return ret;
		}
	}
	if src.ticket != NULL
	{
		dst.ticket = mbedtls_calloc(1, src.ticket_len);
		if dst.ticket == NULL
		{
			return -0x7F00;
		}
		memcpy(dst.ticket, src.ticket, src.ticket_len);
	}
	return 0;
}

i32 (*mbedtls_ssl_hw_record_init)(mbedtls_ssl_context * ssl, const u8 * key_enc, const u8 * key_dec, usize keylen, const u8 * iv_enc, const u8 * iv_dec, usize ivlen, const u8 * mac_enc, const u8 * mac_dec, usize maclen) = NULL;
i32 (*mbedtls_ssl_hw_record_activate)(mbedtls_ssl_context * ssl, i32 direction) = NULL;
i32 (*mbedtls_ssl_hw_record_reset)(mbedtls_ssl_context * ssl) = NULL;
i32 (*mbedtls_ssl_hw_record_write)(mbedtls_ssl_context * ssl) = NULL;
i32 (*mbedtls_ssl_hw_record_read)(mbedtls_ssl_context * ssl) = NULL;
i32 (*mbedtls_ssl_hw_record_finish)(mbedtls_ssl_context * ssl) = NULL;
fn tls_prf_generic(mbedtls_md_type_t md_type, const u8 * secret, usize slen, const i8 * label, const u8 * random, usize rlen, u8 * dstbuf, usize dlen) -> i32
{
	usize nb;
	usize i, j, k, md_len;
	u8 tmp[128];
	u8 h_i[64];
	const mbedtls_md_info_t * md_info;
	mbedtls_md_context_t md_ctx;
	i32 ret;
	mbedtls_md_init(&md_ctx);
	if (md_info = mbedtls_md_info_from_type(md_type)) == NULL
	{
		return -0x6C00;
	}
	md_len = mbedtls_md_get_size(md_info);
	if sizeof(tmp) < md_len + strlen(label) + rlen
	{
		return -0x7100;
	}
	nb = strlen(label);
	memcpy(tmp + md_len, label, nb);
	memcpy(tmp + md_len + nb, random, rlen);
	nb += rlen;
	if (ret = mbedtls_md_setup(&md_ctx, md_info, 1)) != 0
	{
		return ret;
	}
	mbedtls_md_hmac_starts(&md_ctx, secret, slen);
	mbedtls_md_hmac_update(&md_ctx, tmp + md_len, nb);
	mbedtls_md_hmac_finish(&md_ctx, tmp);
	for (i = 0; i < dlen; i += md_len)
	{
		mbedtls_md_hmac_reset(&md_ctx);
		mbedtls_md_hmac_update(&md_ctx, tmp, md_len + nb);
		mbedtls_md_hmac_finish(&md_ctx, h_i);
		mbedtls_md_hmac_reset(&md_ctx);
		mbedtls_md_hmac_update(&md_ctx, tmp, md_len);
		mbedtls_md_hmac_finish(&md_ctx, tmp);
		k = (i + md_len > dlen) ? dlen % md_len : md_len;
		for (j = 0; j < k; j++)
		{
			dstbuf[i + j] = h_i[j];
		}
	}
	mbedtls_md_free(&md_ctx);
	zeroize(tmp, sizeof(tmp));
	zeroize(h_i, sizeof(h_i));
	return 0;
}

fn tls_prf_sha256(const u8 * secret, usize slen, const i8 * label, const u8 * random, usize rlen, u8 * dstbuf, usize dlen) -> i32
{
	return tls_prf_generic(MBEDTLS_MD_SHA256, secret, slen, label, random, rlen, dstbuf, dlen);
}

fn tls_prf_sha384(const u8 * secret, usize slen, const i8 * label, const u8 * random, usize rlen, u8 * dstbuf, usize dlen) -> i32
{
	return tls_prf_generic(MBEDTLS_MD_SHA384, secret, slen, label, random, rlen, dstbuf, dlen);
}

pub fn mbedtls_ssl_derive_keys(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = 0;
	u8 tmp[64];
	u8 keyblk[256];
	u8 * key1;
	u8 * key2;
	u8 * mac_enc;
	u8 * mac_dec;
	usize iv_copy_len;
	const mbedtls_cipher_info_t * cipher_info;
	const mbedtls_md_info_t * md_info;
	mbedtls_ssl_session * session = ssl.session_negotiate;
	mbedtls_ssl_transform * transform = ssl.transform_negotiate;
	mbedtls_ssl_handshake_params * handshake = ssl.handshake;
	do
	{
	}
	while (0);
	cipher_info = mbedtls_cipher_info_from_type(transform.ciphersuite_info.cipher);
	if cipher_info == NULL
	{
		do
		{
		}
		while (0);
		return -0x7100;
	}
	md_info = mbedtls_md_info_from_type(transform.ciphersuite_info.mac);
	if md_info == NULL
	{
		do
		{
		}
		while (0);
		return -0x7100;
	}
	if ssl.minor_ver == 3 && transform.ciphersuite_info.mac == MBEDTLS_MD_SHA384
	{
		handshake.tls_prf = tls_prf_sha384;
		handshake.calc_verify = ssl_calc_verify_tls_sha384;
		handshake.calc_finished = ssl_calc_finished_tls_sha384;
	}
	else
		if ssl.minor_ver == 3
		{
			handshake.tls_prf = tls_prf_sha256;
			handshake.calc_verify = ssl_calc_verify_tls_sha256;
			handshake.calc_finished = ssl_calc_finished_tls_sha256;
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
	if handshake.resume == 0
	{
		do
		{
		}
		while (0);
		if ssl.handshake.extended_ms == 1
		{
			u8 session_hash[48];
			usize hash_len;
			do
			{
			}
			while (0);
			ssl.handshake.calc_verify(ssl, session_hash);
			if ssl.minor_ver == 3
			{
				if ssl.transform_negotiate.ciphersuite_info.mac == MBEDTLS_MD_SHA384
				{
					hash_len = 48;
				}
				else
				{
					hash_len = 32;
				}
			}
			else
			{
				hash_len = 36;
			}
			do
			{
			}
			while (0);
			ret = handshake.tls_prf(handshake.premaster, handshake.pmslen, "extended master secret", session_hash, hash_len, session.master, 48);
			if ret != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
		}
		else
		{
			ret = handshake.tls_prf(handshake.premaster, handshake.pmslen, "master secret", handshake.randbytes, 64, session.master, 48);
		}
		if ret != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		zeroize(handshake.premaster, sizeof(handshake.premaster));
	}
	else
		do
		{
		}
		while (0);
	memcpy(tmp, handshake.randbytes, 64);
	memcpy(handshake.randbytes, tmp + 32, 32);
	memcpy(handshake.randbytes + 32, tmp, 32);
	zeroize(tmp, sizeof(tmp));
	ret = handshake.tls_prf(session.master, 48, "key expansion", handshake.randbytes, 64, keyblk, 256);
	if ret != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	zeroize(handshake.randbytes, sizeof(handshake.randbytes));
	transform.keylen = cipher_info.key_bitlen / 8;
	if cipher_info.mode == MBEDTLS_MODE_GCM || cipher_info.mode == MBEDTLS_MODE_CCM
	{
		transform.maclen = 0;
		transform.ivlen = 12;
		transform.fixed_ivlen = 4;
		transform.minlen = transform.ivlen - transform.fixed_ivlen + (transform.ciphersuite_info.flags & 0x02 ? 8 : 16);
	}
	else
	{
		if (ret = mbedtls_md_setup(&transform.md_ctx_enc, md_info, 1)) != 0 || (ret = mbedtls_md_setup(&transform.md_ctx_dec, md_info, 1)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		transform.maclen = mbedtls_md_get_size(md_info);
		transform.ivlen = cipher_info.iv_size;
		if cipher_info.mode == MBEDTLS_MODE_STREAM
		{
			transform.minlen = transform.maclen;
		}
		else
		{
			if session.encrypt_then_mac == 1
			{
				transform.minlen = transform.maclen + cipher_info.block_size;
			}
			else
			{
				transform.minlen = transform.maclen + cipher_info.block_size - transform.maclen % cipher_info.block_size;
			}
			if ssl.minor_ver == 2 || ssl.minor_ver == 3
			{
				transform.minlen += transform.ivlen;
			}
			else
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
		}
	}
	do
	{
	}
	while (0);
	if ssl.conf.endpoi32 == 0
	{
		key1 = keyblk + transform.maclen * 2;
		key2 = keyblk + transform.maclen * 2 + transform.keylen;
		mac_enc = keyblk;
		mac_dec = keyblk + transform.maclen;
		iv_copy_len = (transform.fixed_ivlen) ? transform.fixed_ivlen : transform.ivlen;
		memcpy(transform.iv_enc, key2 + transform.keylen, iv_copy_len);
		memcpy(transform.iv_dec, key2 + transform.keylen + iv_copy_len, iv_copy_len);
	}
	else
		if ssl.conf.endpoi32 == 1
		{
			key1 = keyblk + transform.maclen * 2 + transform.keylen;
			key2 = keyblk + transform.maclen * 2;
			mac_enc = keyblk + transform.maclen;
			mac_dec = keyblk;
			iv_copy_len = (transform.fixed_ivlen) ? transform.fixed_ivlen : transform.ivlen;
			memcpy(transform.iv_dec, key1 + transform.keylen, iv_copy_len);
			memcpy(transform.iv_enc, key1 + transform.keylen + iv_copy_len, iv_copy_len);
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
	if ssl.minor_ver >= 1
	{
		mbedtls_md_hmac_starts(&transform.md_ctx_enc, mac_enc, transform.maclen);
		mbedtls_md_hmac_starts(&transform.md_ctx_dec, mac_dec, transform.maclen);
	}
	else
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	if mbedtls_ssl_hw_record_init != NULL
	{
		i32 ret = 0;
		do
		{
		}
		while (0);
		if (ret = mbedtls_ssl_hw_record_init(ssl, key1, key2, transform.keylen, transform.iv_enc, transform.iv_dec, iv_copy_len, mac_enc, mac_dec, transform.maclen)) != 0
		{
			do
			{
			}
			while (0);
			return -0x7F80;
		}
	}
	if (ret = mbedtls_cipher_setup(&transform.cipher_ctx_enc, cipher_info)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if (ret = mbedtls_cipher_setup(&transform.cipher_ctx_dec, cipher_info)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if (ret = mbedtls_cipher_setkey(&transform.cipher_ctx_enc, key1, cipher_info.key_bitlen, MBEDTLS_ENCRYPT)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if (ret = mbedtls_cipher_setkey(&transform.cipher_ctx_dec, key2, cipher_info.key_bitlen, MBEDTLS_DECRYPT)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if cipher_info.mode == MBEDTLS_MODE_CBC
	{
		if (ret = mbedtls_cipher_set_padding_mode(&transform.cipher_ctx_enc, MBEDTLS_PADDING_NONE)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if (ret = mbedtls_cipher_set_padding_mode(&transform.cipher_ctx_dec, MBEDTLS_PADDING_NONE)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	zeroize(keyblk, sizeof(keyblk));
	do
	{
	}
	while (0);
	return 0;
}

pub fn ssl_calc_verify_tls_sha256(mbedtls_ssl_context * ssl, u8 hash[32])
{
	mbedtls_sha256_context sha256;
	mbedtls_sha256_init(&sha256);
	do
	{
	}
	while (0);
	mbedtls_sha256_clone(&sha256, &ssl.handshake.fin_sha256);
	mbedtls_sha256_finish(&sha256, hash);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	mbedtls_sha256_free(&sha256);
	return;
}

pub fn ssl_calc_verify_tls_sha384(mbedtls_ssl_context * ssl, u8 hash[48])
{
	mbedtls_sha512_context sha512;
	mbedtls_sha512_init(&sha512);
	do
	{
	}
	while (0);
	mbedtls_sha512_clone(&sha512, &ssl.handshake.fin_sha512);
	mbedtls_sha512_finish(&sha512, hash);
	do
	{
	}
	while (0);
	do
	{
	}
	while (0);
	mbedtls_sha512_free(&sha512);
	return;
}

pub fn mbedtls_ssl_psk_derive_premaster(mbedtls_ssl_context * ssl, mbedtls_key_exchange_type_t key_ex) -> i32
{
	u8 * p = ssl.handshake.premaster;
	u8 * end = p + sizeof(ssl.handshake.premaster);
	const u8 * psk = ssl.conf.psk;
	usize psk_len = ssl.conf.psk_len;
	if ssl.handshake.psk != NULL
	{
		psk = ssl.handshake.psk;
		psk_len = ssl.handshake.psk_len;
	}
	if key_ex == MBEDTLS_KEY_EXCHANGE_PSK
	{
		if end - p < 2
		{
			return -0x7100;
		}
		*(p++) = (i8) (psk_len >> 8);
		*(p++) = (i8) (psk_len);
		if end < p || (usize)(end - p) < psk_len
		{
			return -0x7100;
		}
		memset(p, 0, psk_len);
		p += psk_len;
	}
	else
		if key_ex == MBEDTLS_KEY_EXCHANGE_RSA_PSK
		{
			*p++ = 0;
			*p++ = 48;
			p += 48;
		}
		else
			if key_ex == MBEDTLS_KEY_EXCHANGE_DHE_PSK
			{
				i32 ret;
				usize len;
				if (ret = mbedtls_dhm_calc_secret(&ssl.handshake.dhm_ctx, p + 2, end - (p + 2), &len, ssl.conf.f_rng, ssl.conf.p_rng)) != 0
				{
					do
					{
					}
					while (0);
					return ret;
				}
				*(p++) = (i8) (len >> 8);
				*(p++) = (i8) (len);
				p += len;
				do
				{
				}
				while (0);
			}
			else
				if key_ex == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
				{
					i32 ret;
					usize zlen;
					if (ret = mbedtls_ecdh_calc_secret(&ssl.handshake.ecdh_ctx, &zlen, p + 2, end - (p + 2), ssl.conf.f_rng, ssl.conf.p_rng)) != 0
					{
						do
						{
						}
						while (0);
						return ret;
					}
					*(p++) = (i8) (zlen >> 8);
					*(p++) = (i8) (zlen);
					p += zlen;
					do
					{
					}
					while (0);
				}
				else
				{
					do
					{
					}
					while (0);
					return -0x6C00;
				}
	if end - p < 2
	{
		return -0x7100;
	}
	*(p++) = (i8) (psk_len >> 8);
	*(p++) = (i8) (psk_len);
	if end < p || (usize)(end - p) < psk_len
	{
		return -0x7100;
	}
	memcpy(p, psk, psk_len);
	p += psk_len;
	ssl.handshake.pmslen = p - ssl.handshake.premaster;
	return 0;
}

fn ssl_encrypt_buf(mbedtls_ssl_context * ssl) -> i32
{
	mbedtls_cipher_mode_t mode;
	i32 auth_done = 0;
	do
	{
	}
	while (0);
	if ssl.session_out == NULL || ssl.transform_out == NULL
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	mode = mbedtls_cipher_get_cipher_mode(&ssl.transform_out.cipher_ctx_enc);
	do
	{
	}
	while (0);
	if mode == MBEDTLS_MODE_STREAM || (mode == MBEDTLS_MODE_CBC && ssl.session_out.encrypt_then_mac == 0)
	{
		if ssl.minor_ver >= 1
		{
			mbedtls_md_hmac_update(&ssl.transform_out.md_ctx_enc, ssl.out_ctr, 8);
			mbedtls_md_hmac_update(&ssl.transform_out.md_ctx_enc, ssl.out_hdr, 3);
			mbedtls_md_hmac_update(&ssl.transform_out.md_ctx_enc, ssl.out_len, 2);
			mbedtls_md_hmac_update(&ssl.transform_out.md_ctx_enc, ssl.out_msg, ssl.out_msglen);
			mbedtls_md_hmac_finish(&ssl.transform_out.md_ctx_enc, ssl.out_msg + ssl.out_msglen);
			mbedtls_md_hmac_reset(&ssl.transform_out.md_ctx_enc);
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		do
		{
		}
		while (0);
		ssl.out_msglen += ssl.transform_out.maclen;
		auth_done++;
	}
	if mode == MBEDTLS_MODE_GCM || mode == MBEDTLS_MODE_CCM
	{
		i32 ret;
		usize enc_msglen, olen;
		u8 * enc_msg;
		u8 add_data[13];
		u8 taglen = ssl.transform_out.ciphersuite_info.flags & 0x02 ? 8 : 16;
		memcpy(add_data, ssl.out_ctr, 8);
		add_data[8] = ssl.out_msgtype;
		mbedtls_ssl_write_version(ssl.major_ver, ssl.minor_ver, ssl.conf.transport, add_data + 9);
		add_data[11] = (ssl.out_msglen >> 8) & 0xFF;
		add_data[12] = ssl.out_msglen & 0xFF;
		do
		{
		}
		while (0);
		if ssl.transform_out.ivlen - ssl.transform_out.fixed_ivlen != 8
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		memcpy(ssl.transform_out.iv_enc + ssl.transform_out.fixed_ivlen, ssl.out_ctr, 8);
		memcpy(ssl.out_iv, ssl.out_ctr, 8);
		do
		{
		}
		while (0);
		enc_msg = ssl.out_msg;
		enc_msglen = ssl.out_msglen;
		ssl.out_msglen += ssl.transform_out.ivlen - ssl.transform_out.fixed_ivlen;
		do
		{
		}
		while (0);
		if (ret = mbedtls_cipher_auth_encrypt(&ssl.transform_out.cipher_ctx_enc, ssl.transform_out.iv_enc, ssl.transform_out.ivlen, add_data, 13, enc_msg, enc_msglen, enc_msg, &olen, enc_msg + enc_msglen, taglen)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		if olen != enc_msglen
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		ssl.out_msglen += taglen;
		auth_done++;
		do
		{
		}
		while (0);
	}
	else
		if mode == MBEDTLS_MODE_CBC
		{
			i32 ret;
			u8 * enc_msg;
			usize enc_msglen, padlen, olen = 0, i;
			padlen = ssl.transform_out.ivlen - (ssl.out_msglen + 1) % ssl.transform_out.ivlen;
			if padlen == ssl.transform_out.ivlen
			{
				padlen = 0;
			}
			for (i = 0; i <= padlen; i++)
			{
				ssl.out_msg[ssl.out_msglen + i] = (i8) padlen;
			}
			ssl.out_msglen += padlen + 1;
			enc_msglen = ssl.out_msglen;
			enc_msg = ssl.out_msg;
			if ssl.minor_ver >= 2
			{
				ret = ssl.conf.f_rng(ssl.conf.p_rng, ssl.transform_out.iv_enc, ssl.transform_out.ivlen);
				if ret != 0
				{
					return ret;
				}
				memcpy(ssl.out_iv, ssl.transform_out.iv_enc, ssl.transform_out.ivlen);
				enc_msg = ssl.out_msg;
				enc_msglen = ssl.out_msglen;
				ssl.out_msglen += ssl.transform_out.ivlen;
			}
			do
			{
			}
			while (0);
			if (ret = mbedtls_cipher_crypt(&ssl.transform_out.cipher_ctx_enc, ssl.transform_out.iv_enc, ssl.transform_out.ivlen, enc_msg, enc_msglen, enc_msg, &olen)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			if enc_msglen != olen
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
			if auth_done == 0
			{
				u8 pseudo_hdr[13];
				do
				{
				}
				while (0);
				memcpy(pseudo_hdr + 0, ssl.out_ctr, 8);
				memcpy(pseudo_hdr + 8, ssl.out_hdr, 3);
				pseudo_hdr[11] = (i8) ((ssl.out_msglen >> 8) & 0xFF);
				pseudo_hdr[12] = (i8) ((ssl.out_msglen) & 0xFF);
				do
				{
				}
				while (0);
				mbedtls_md_hmac_update(&ssl.transform_out.md_ctx_enc, pseudo_hdr, 13);
				mbedtls_md_hmac_update(&ssl.transform_out.md_ctx_enc, ssl.out_iv, ssl.out_msglen);
				mbedtls_md_hmac_finish(&ssl.transform_out.md_ctx_enc, ssl.out_iv + ssl.out_msglen);
				mbedtls_md_hmac_reset(&ssl.transform_out.md_ctx_enc);
				ssl.out_msglen += ssl.transform_out.maclen;
				auth_done++;
			}
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
	if auth_done != 1
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_decrypt_buf(mbedtls_ssl_context * ssl) -> i32
{
	usize i;
	mbedtls_cipher_mode_t mode;
	i32 auth_done = 0;
	usize padlen = 0, correct = 1;
	do
	{
	}
	while (0);
	if ssl.session_in == NULL || ssl.transform_in == NULL
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	mode = mbedtls_cipher_get_cipher_mode(&ssl.transform_in.cipher_ctx_dec);
	if ssl.in_msglen < ssl.transform_in.minlen
	{
		do
		{
		}
		while (0);
		return -0x7180;
	}
	if mode == MBEDTLS_MODE_GCM || mode == MBEDTLS_MODE_CCM
	{
		i32 ret;
		usize dec_msglen, olen;
		u8 * dec_msg;
		u8 * dec_msg_result;
		u8 add_data[13];
		u8 taglen = ssl.transform_in.ciphersuite_info.flags & 0x02 ? 8 : 16;
		usize explicit_iv_len = ssl.transform_in.ivlen - ssl.transform_in.fixed_ivlen;
		if ssl.in_msglen < explicit_iv_len + taglen
		{
			do
			{
			}
			while (0);
			return -0x7180;
		}
		dec_msglen = ssl.in_msglen - explicit_iv_len - taglen;
		dec_msg = ssl.in_msg;
		dec_msg_result = ssl.in_msg;
		ssl.in_msglen = dec_msglen;
		memcpy(add_data, ssl.in_ctr, 8);
		add_data[8] = ssl.in_msgtype;
		mbedtls_ssl_write_version(ssl.major_ver, ssl.minor_ver, ssl.conf.transport, add_data + 9);
		add_data[11] = (ssl.in_msglen >> 8) & 0xFF;
		add_data[12] = ssl.in_msglen & 0xFF;
		do
		{
		}
		while (0);
		memcpy(ssl.transform_in.iv_dec + ssl.transform_in.fixed_ivlen, ssl.in_iv, ssl.transform_in.ivlen - ssl.transform_in.fixed_ivlen);
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		if (ret = mbedtls_cipher_auth_decrypt(&ssl.transform_in.cipher_ctx_dec, ssl.transform_in.iv_dec, ssl.transform_in.ivlen, add_data, 13, dec_msg, dec_msglen, dec_msg_result, &olen, dec_msg + dec_msglen, taglen)) != 0
		{
			do
			{
			}
			while (0);
			if ret == -0x6300
			{
				return -0x7180;
			}
			return ret;
		}
		auth_done++;
		if olen != dec_msglen
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
	}
	else
		if mode == MBEDTLS_MODE_CBC
		{
			i32 ret;
			u8 * dec_msg;
			u8 * dec_msg_result;
			usize dec_msglen;
			usize minlen = 0;
			usize olen = 0;
			if ssl.minor_ver >= 2
			{
				minlen += ssl.transform_in.ivlen;
			}
			if ssl.in_msglen < minlen + ssl.transform_in.ivlen || ssl.in_msglen < minlen + ssl.transform_in.maclen + 1
			{
				do
				{
				}
				while (0);
				return -0x7180;
			}
			dec_msglen = ssl.in_msglen;
			dec_msg = ssl.in_msg;
			dec_msg_result = ssl.in_msg;
			if ssl.session_in.encrypt_then_mac == 1
			{
				u8 computed_mac[48];
				u8 pseudo_hdr[13];
				do
				{
				}
				while (0);
				dec_msglen -= ssl.transform_in.maclen;
				ssl.in_msglen -= ssl.transform_in.maclen;
				memcpy(pseudo_hdr + 0, ssl.in_ctr, 8);
				memcpy(pseudo_hdr + 8, ssl.in_hdr, 3);
				pseudo_hdr[11] = (i8) ((ssl.in_msglen >> 8) & 0xFF);
				pseudo_hdr[12] = (i8) ((ssl.in_msglen) & 0xFF);
				do
				{
				}
				while (0);
				mbedtls_md_hmac_update(&ssl.transform_in.md_ctx_dec, pseudo_hdr, 13);
				mbedtls_md_hmac_update(&ssl.transform_in.md_ctx_dec, ssl.in_iv, ssl.in_msglen);
				mbedtls_md_hmac_finish(&ssl.transform_in.md_ctx_dec, computed_mac);
				mbedtls_md_hmac_reset(&ssl.transform_in.md_ctx_dec);
				do
				{
				}
				while (0);
				do
				{
				}
				while (0);
				if mbedtls_ssl_safer_memcmp(ssl.in_iv + ssl.in_msglen, computed_mac, ssl.transform_in.maclen) != 0
				{
					do
					{
					}
					while (0);
					return -0x7180;
				}
				auth_done++;
			}
			if ssl.in_msglen % ssl.transform_in.ivlen != 0
			{
				do
				{
				}
				while (0);
				return -0x7180;
			}
			if ssl.minor_ver >= 2
			{
				dec_msglen -= ssl.transform_in.ivlen;
				ssl.in_msglen -= ssl.transform_in.ivlen;
				for (i = 0; i < ssl.transform_in.ivlen; i++)
				{
					ssl.transform_in.iv_dec[i] = ssl.in_iv[i];
				}
			}
			if (ret = mbedtls_cipher_crypt(&ssl.transform_in.cipher_ctx_dec, ssl.transform_in.iv_dec, ssl.transform_in.ivlen, dec_msg, dec_msglen, dec_msg_result, &olen)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			if dec_msglen != olen
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
			padlen = 1 + ssl.in_msg[ssl.in_msglen - 1];
			if ssl.in_msglen < ssl.transform_in.maclen + padlen && auth_done == 0
			{
				padlen = 0;
				correct = 0;
			}
			if ssl.minor_ver > 0
			{
				usize pad_count = 0, real_count = 1;
				usize padding_idx = ssl.in_msglen - padlen - 1;
				correct &= (ssl.in_msglen >= padlen + 1);
				correct &= (padding_idx < 16384 + ssl.transform_in.maclen);
				padding_idx *= correct;
				for (i = 1; i <= 256; i++)
				{
					real_count &= (i <= padlen);
					pad_count += real_count * (ssl.in_msg[padding_idx + i] == padlen - 1);
				}
				correct &= (pad_count == padlen);
				padlen &= correct * 0x1FF;
			}
			else
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
			ssl.in_msglen -= padlen;
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
	do
	{
	}
	while (0);
	if auth_done == 0
	{
		u8 tmp[48];
		ssl.in_msglen -= ssl.transform_in.maclen;
		ssl.in_len[0] = (i8) (ssl.in_msglen >> 8);
		ssl.in_len[1] = (i8) (ssl.in_msglen);
		memcpy(tmp, ssl.in_msg + ssl.in_msglen, ssl.transform_in.maclen);
		if ssl.minor_ver > 0
		{
			usize j, extra_run = 0;
			extra_run = (13 + ssl.in_msglen + padlen + 8) / 64 - (13 + ssl.in_msglen + 8) / 64;
			extra_run &= correct * 0xFF;
			mbedtls_md_hmac_update(&ssl.transform_in.md_ctx_dec, ssl.in_ctr, 8);
			mbedtls_md_hmac_update(&ssl.transform_in.md_ctx_dec, ssl.in_hdr, 3);
			mbedtls_md_hmac_update(&ssl.transform_in.md_ctx_dec, ssl.in_len, 2);
			mbedtls_md_hmac_update(&ssl.transform_in.md_ctx_dec, ssl.in_msg, ssl.in_msglen);
			mbedtls_md_hmac_finish(&ssl.transform_in.md_ctx_dec, ssl.in_msg + ssl.in_msglen);
			for (j = 0; j < extra_run + 1; j++)
			{
				mbedtls_md_process(&ssl.transform_in.md_ctx_dec, ssl.in_msg);
			}
			mbedtls_md_hmac_reset(&ssl.transform_in.md_ctx_dec);
		}
		else
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
		if mbedtls_ssl_safer_memcmp(tmp, ssl.in_msg + ssl.in_msglen, ssl.transform_in.maclen) != 0
		{
			correct = 0;
		}
		auth_done++;
		if correct == 0
		{
			return -0x7180;
		}
	}
	if auth_done != 1
	{
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	if ssl.in_msglen == 0
	{
		ssl.nb_zero++;
		if ssl.nb_zero > 3
		{
			do
			{
			}
			while (0);
			return -0x7180;
		}
	}
	else
	{
		ssl.nb_zero = 0;
	}
	if ssl.conf.transport == 1
	{
		;
	}
	else
	{
		for (i = 8; i > ssl_ep_len(ssl); i--)
			if ++ssl.in_ctr[i - 1] != 0
			{
				break;

			}
		if i == ssl_ep_len(ssl)
		{
			do
			{
			}
			while (0);
			return -0x6B80;
		}
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_fetch_input(mbedtls_ssl_context * ssl, usize nb_want) -> i32
{
	i32 ret;
	usize len;
	do
	{
	}
	while (0);
	if ssl.f_recv == NULL && ssl.f_recv_timeout == NULL
	{
		do
		{
		}
		while (0);
		return -0x7100;
	}
	if nb_want > (16384 + 0 + 29 + 48 + 256) - (usize)(ssl.in_hdr - ssl.in_buf)
	{
		do
		{
		}
		while (0);
		return -0x7100;
	}
	if ssl.conf.transport == 1
	{
		u32 timeout;
		if ssl.f_set_timer == NULL || ssl.f_get_timer == NULL
		{
			do
			{
			}
			while (0);
			return -0x7100;
		}
		if ssl.next_record_offset != 0
		{
			if ssl.in_left < ssl.next_record_offset
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
			ssl.in_left -= ssl.next_record_offset;
			if ssl.in_left != 0
			{
				do
				{
				}
				while (0);
				memmove(ssl.in_hdr, ssl.in_hdr + ssl.next_record_offset, ssl.in_left);
			}
			ssl.next_record_offset = 0;
		}
		do
		{
		}
		while (0);
		if nb_want <= ssl.in_left
		{
			do
			{
			}
			while (0);
			return 0;
		}
		if ssl.in_left != 0
		{
			do
			{
			}
			while (0);
			return -0x6C00;
		}
		if ssl_check_timer(ssl) != 0
		{
			ret = -0x6800;
		}
		else
		{
			len = (16384 + 0 + 29 + 48 + 256) - (ssl.in_hdr - ssl.in_buf);
			if ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER
			{
				timeout = ssl.handshake.retransmit_timeout;
			}
			else
			{
				timeout = ssl.conf.read_timeout;
			}
			do
			{
			}
			while (0);
			if ssl.f_recv_timeout != NULL
			{
				ret = ssl.f_recv_timeout(ssl.p_bio, ssl.in_hdr, len, timeout);
			}
			else
			{
				ret = ssl.f_recv(ssl.p_bio, ssl.in_hdr, len);
			}
			do
			{
			}
			while (0);
			if ret == 0
			{
				return -0x7280;
			}
		}
		if ret == -0x6800
		{
			do
			{
			}
			while (0);
			ssl_set_timer(ssl, 0);
			if ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER
			{
				if ssl_double_retransmit_timeout(ssl) != 0
				{
					do
					{
					}
					while (0);
					return -0x6800;
				}
				if (ret = mbedtls_ssl_resend(ssl)) != 0
				{
					do
					{
					}
					while (0);
					return ret;
				}
				return -0x6900;
			}
		}
		if ret < 0
		{
			return ret;
		}
		ssl.in_left = ret;
	}
	else
	{
		do
		{
		}
		while (0);
		while (ssl.in_left < nb_want)
		{
			len = nb_want - ssl.in_left;
			if ssl_check_timer(ssl) != 0
			{
				ret = -0x6800;
			}
			else
			{
				if ssl.f_recv_timeout != NULL
				{
					ret = ssl.f_recv_timeout(ssl.p_bio, ssl.in_hdr + ssl.in_left, len, ssl.conf.read_timeout);
				}
				else
				{
					ret = ssl.f_recv(ssl.p_bio, ssl.in_hdr + ssl.in_left, len);
				}
			}
			do
			{
			}
			while (0);
			do
			{
			}
			while (0);
			if ret == 0
			{
				return -0x7280;
			}
			if ret < 0
			{
				return ret;
			}
			ssl.in_left += ret;
		}
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_flush_output(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	u8 *buf, i;
	do
	{
	}
	while (0);
	if ssl.f_send == NULL
	{
		do
		{
		}
		while (0);
		return -0x7100;
	}
	if ssl.out_left == 0
	{
		do
		{
		}
		while (0);
		return 0;
	}
	while (ssl.out_left > 0)
	{
		do
		{
		}
		while (0);
		buf = ssl.out_hdr + mbedtls_ssl_hdr_len(ssl) + ssl.out_msglen - ssl.out_left;
		ret = ssl.f_send(ssl.p_bio, buf, ssl.out_left);
		do
		{
		}
		while (0);
		if ret <= 0
		{
			return ret;
		}
		ssl.out_left -= ret;
	}
	for (i = 8; i > ssl_ep_len(ssl); i--)
		if ++ssl.out_ctr[i - 1] != 0
		{
			break;

		}
	if i == ssl_ep_len(ssl)
	{
		do
		{
		}
		while (0);
		return -0x6B80;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_flight_append(mbedtls_ssl_context * ssl) -> i32
{
	mbedtls_ssl_flight_item * msg;
	if (msg = mbedtls_calloc(1, sizeof(mbedtls_ssl_flight_item))) == NULL
	{
		do
		{
		}
		while (0);
		return -0x7F00;
	}
	if (msg.p = mbedtls_calloc(1, ssl.out_msglen)) == NULL
	{
		do
		{
		}
		while (0);
		mbedtls_free(msg);
		return -0x7F00;
	}
	memcpy(msg.p, ssl.out_msg, ssl.out_msglen);
	msg.len = ssl.out_msglen;
	msg.type = ssl.out_msgtype;
	msg.next = NULL;
	if ssl.handshake.flight == NULL
	{
		ssl.handshake.flight = msg;
	}
	else
	{
		mbedtls_ssl_flight_item * cur = ssl.handshake.flight;
		while (cur.next != NULL)
		{
			cur = cur.next;
		}
		cur.next = msg;
	}
	return 0;
}

fn ssl_flight_free(mbedtls_ssl_flight_item * flight)
{
	mbedtls_ssl_flight_item * cur = flight;
	mbedtls_ssl_flight_item * next;
	while (cur != NULL)
	{
		next = cur.next;
		mbedtls_free(cur.p);
		mbedtls_free(cur);
		cur = next;
	}
}

fn ssl_swap_epochs(mbedtls_ssl_context * ssl)
{
	mbedtls_ssl_transform * tmp_transform;
	u8 tmp_out_ctr[8];
	if ssl.transform_out == ssl.handshake.alt_transform_out
	{
		do
		{
		}
		while (0);
		return;
	}
	do
	{
	}
	while (0);
	tmp_transform = ssl.transform_out;
	ssl.transform_out = ssl.handshake.alt_transform_out;
	ssl.handshake.alt_transform_out = tmp_transform;
	memcpy(tmp_out_ctr, ssl.out_ctr, 8);
	memcpy(ssl.out_ctr, ssl.handshake.alt_out_ctr, 8);
	memcpy(ssl.handshake.alt_out_ctr, tmp_out_ctr, 8);
	if ssl.transform_out != NULL && ssl.minor_ver >= 2
	{
		ssl.out_msg = ssl.out_iv + ssl.transform_out.ivlen - ssl.transform_out.fixed_ivlen;
	}
	else
	{
		ssl.out_msg = ssl.out_iv;
	}
	if mbedtls_ssl_hw_record_activate != NULL
	{
		if (ret = mbedtls_ssl_hw_record_activate(ssl, 0)) != 0
		{
			do
			{
			}
			while (0);
			return -0x7F80;
		}
	}
}

pub fn mbedtls_ssl_resend(mbedtls_ssl_context * ssl) -> i32
{
	do
	{
	}
	while (0);
	if ssl.handshake.retransmit_state != 1
	{
		do
		{
		}
		while (0);
		ssl.handshake.cur_msg = ssl.handshake.flight;
		ssl_swap_epochs(ssl);
		ssl.handshake.retransmit_state = 1;
	}
	while (ssl.handshake.cur_msg != NULL)
	{
		i32 ret;
		mbedtls_ssl_flight_item * cur = ssl.handshake.cur_msg;
		if cur.type == 22 && cur.p[0] == 20
		{
			ssl_swap_epochs(ssl);
		}
		memcpy(ssl.out_msg, cur.p, cur.len);
		ssl.out_msglen = cur.len;
		ssl.out_msgtype = cur.type;
		ssl.handshake.cur_msg = cur.next;
		do
		{
		}
		while (0);
		if (ret = mbedtls_ssl_write_record(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	if ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER
	{
		ssl.handshake.retransmit_state = 3;
	}
	else
	{
		ssl.handshake.retransmit_state = 2;
		ssl_set_timer(ssl, ssl.handshake.retransmit_timeout);
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_recv_flight_completed(mbedtls_ssl_context * ssl)
{
	ssl_flight_free(ssl.handshake.flight);
	ssl.handshake.flight = NULL;
	ssl.handshake.cur_msg = NULL;
	ssl.handshake.in_flight_start_seq = ssl.handshake.in_msg_seq;
	ssl_set_timer(ssl, 0);
	if ssl.in_msgtype == 22 && ssl.in_msg[0] == 20
	{
		ssl.handshake.retransmit_state = 3;
	}
	else
	{
		ssl.handshake.retransmit_state = 0;
	}
}

pub fn mbedtls_ssl_send_flight_completed(mbedtls_ssl_context * ssl)
{
	ssl_reset_retransmit_timeout(ssl);
	ssl_set_timer(ssl, ssl.handshake.retransmit_timeout);
	if ssl.in_msgtype == 22 && ssl.in_msg[0] == 20
	{
		ssl.handshake.retransmit_state = 3;
	}
	else
	{
		ssl.handshake.retransmit_state = 2;
	}
}

pub fn mbedtls_ssl_write_record(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret, done = 0, out_msg_type;
	usize len = ssl.out_msglen;
	do
	{
	}
	while (0);
	if ssl.conf.transport == 1 && ssl.handshake != NULL && ssl.handshake.retransmit_state == 1
	{
		;
	}
	else
		if ssl.out_msgtype == 22
		{
			out_msg_type = ssl.out_msg[0];
			if out_msg_type != 0 && ssl.handshake == NULL
			{
				do
				{
				}
				while (0);
				return -0x6C00;
			}
			ssl.out_msg[1] = (i8) ((len - 4) >> 16);
			ssl.out_msg[2] = (i8) ((len - 4) >> 8);
			ssl.out_msg[3] = (i8) ((len - 4));
			if ssl.conf.transport == 1
			{
				memmove(ssl.out_msg + 12, ssl.out_msg + 4, len - 4);
				ssl.out_msglen += 8;
				len += 8;
				if out_msg_type != 0
				{
					ssl.out_msg[4] = (ssl.handshake.out_msg_seq >> 8) & 0xFF;
					ssl.out_msg[5] = (ssl.handshake.out_msg_seq) & 0xFF;
					++(ssl.handshake.out_msg_seq);
				}
				else
				{
					ssl.out_msg[4] = 0;
					ssl.out_msg[5] = 0;
				}
				memset(ssl.out_msg + 6, 0x00, 3);
				memcpy(ssl.out_msg + 9, ssl.out_msg + 1, 3);
			}
			if out_msg_type != 0
			{
				ssl.handshake.update_checksum(ssl, ssl.out_msg, len);
			}
		}
	if ssl.conf.transport == 1 && ssl.handshake != NULL && ssl.handshake.retransmit_state != 1 && (ssl.out_msgtype == 20 || ssl.out_msgtype == 22)
	{
		if (ret = ssl_flight_append(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	if mbedtls_ssl_hw_record_write != NULL
	{
		do
		{
		}
		while (0);
		ret = mbedtls_ssl_hw_record_write(ssl);
		if ret != 0 && ret != -0x6F80
		{
			do
			{
			}
			while (0);
			return -0x7F80;
		}
		if ret == 0
		{
			done = 1;
		}
	}
	if !done
	{
		ssl.out_hdr[0] = (i8) ssl.out_msgtype;
		mbedtls_ssl_write_version(ssl.major_ver, ssl.minor_ver, ssl.conf.transport, ssl.out_hdr + 1);
		ssl.out_len[0] = (i8) (len >> 8);
		ssl.out_len[1] = (i8) (len);
		if ssl.transform_out != NULL
		{
			if (ret = ssl_encrypt_buf(ssl)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			len = ssl.out_msglen;
			ssl.out_len[0] = (i8) (len >> 8);
			ssl.out_len[1] = (i8) (len);
		}
		ssl.out_left = mbedtls_ssl_hdr_len(ssl) + ssl.out_msglen;
		do
		{
		}
		while (0);
		do
		{
		}
		while (0);
	}
	if (ret = mbedtls_ssl_flush_output(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_bitmask_set(u8 * mask, usize offset, usize len)
{
	u32 start_bits, end_bits;
	start_bits = 8 - (offset % 8);
	if start_bits != 8
	{
		usize first_byte_idx = offset / 8;
		if len <= start_bits
		{
			for (; len != 0; len--)
			{
				mask[first_byte_idx] |= 1 << (start_bits - len);
			}
			return;
		}
		offset += start_bits;
		len -= start_bits;
		for (; start_bits != 0; start_bits--)
		{
			mask[first_byte_idx] |= 1 << (start_bits - 1);
		}
	}
	end_bits = len % 8;
	if end_bits != 0
	{
		usize last_byte_idx = (offset + len) / 8;
		len -= end_bits;
		for (; end_bits != 0; end_bits--)
		{
			mask[last_byte_idx] |= 1 << (8 - end_bits);
		}
	}
	memset(mask + offset / 8, 0xFF, len / 8);
}

fn ssl_bitmask_check(u8 * mask, usize len) -> i32
{
	usize i;
	for (i = 0; i < len / 8; i++)
		if mask[i] != 0xFF
		{
			return -1;
		}
	for (i = 0; i < len % 8; i++)
		if (mask[len / 8] & (1 << (7 - i))) == 0
		{
			return -1;
		}
	return 0;
}

fn ssl_reassemble_dtls_handshake(mbedtls_ssl_context * ssl) -> i32
{
	u8 *msg, *bitmask;
	usize frag_len, frag_off;
	usize msg_len = ssl.in_hslen - 12;
	if ssl.handshake == NULL
	{
		do
		{
		}
		while (0);
		return -0x7080;
	}
	if ssl.handshake.hs_msg == NULL
	{
		usize alloc_len;
		do
		{
		}
		while (0);
		if ssl.in_hslen > 16384
		{
			do
			{
			}
			while (0);
			return -0x7080;
		}
		alloc_len = 12 + msg_len + msg_len / 8 + (msg_len % 8 != 0);
		ssl.handshake.hs_msg = mbedtls_calloc(1, alloc_len);
		if ssl.handshake.hs_msg == NULL
		{
			do
			{
			}
			while (0);
			return -0x7F00;
		}
		memcpy(ssl.handshake.hs_msg, ssl.in_msg, 6);
		memset(ssl.handshake.hs_msg + 6, 0, 3);
		memcpy(ssl.handshake.hs_msg + 9, ssl.handshake.hs_msg + 1, 3);
	}
	else
	{
		if memcmp(ssl.handshake.hs_msg, ssl.in_msg, 4) != 0
		{
			do
			{
			}
			while (0);
			return -0x7200;
		}
	}
	msg = ssl.handshake.hs_msg + 12;
	bitmask = msg + msg_len;
	frag_off = (ssl.in_msg[6] << 16) | (ssl.in_msg[7] << 8) | ssl.in_msg[8];
	frag_len = (ssl.in_msg[9] << 16) | (ssl.in_msg[10] << 8) | ssl.in_msg[11];
	if frag_off + frag_len > msg_len
	{
		do
		{
		}
		while (0);
		return -0x7200;
	}
	if frag_len + 12 > ssl.in_msglen
	{
		do
		{
		}
		while (0);
		return -0x7200;
	}
	do
	{
	}
	while (0);
	memcpy(msg + frag_off, ssl.in_msg + 12, frag_len);
	ssl_bitmask_set(bitmask, frag_off, frag_len);
	if ssl_bitmask_check(bitmask, msg_len) != 0
	{
		do
		{
		}
		while (0);
		return -0x6900;
	}
	do
	{
	}
	while (0);
	if frag_len + 12 < ssl.in_msglen
	{
		do
		{
		}
		while (0);
		return -0x7080;
	}
	if ssl.in_left > ssl.next_record_offset
	{
		u8 * cur_remain = ssl.in_hdr + ssl.next_record_offset;
		u8 * new_remain = ssl.in_msg + ssl.in_hslen;
		usize remain_len = ssl.in_left - ssl.next_record_offset;
		ssl.next_record_offset = new_remain - ssl.in_hdr;
		ssl.in_left = ssl.next_record_offset + remain_len;
		if ssl.in_left > (16384 + 0 + 29 + 48 + 256) - (usize)(ssl.in_hdr - ssl.in_buf)
		{
			do
			{
			}
			while (0);
			return -0x6A00;
		}
		memmove(new_remain, cur_remain, remain_len);
	}
	memcpy(ssl.in_msg, ssl.handshake.hs_msg, ssl.in_hslen);
	mbedtls_free(ssl.handshake.hs_msg);
	ssl.handshake.hs_msg = NULL;
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_prepare_handshake_record(mbedtls_ssl_context * ssl) -> i32
{
	if ssl.in_msglen < mbedtls_ssl_hs_hdr_len(ssl)
	{
		do
		{
		}
		while (0);
		return -0x7200;
	}
	ssl.in_hslen = mbedtls_ssl_hs_hdr_len(ssl) + ((ssl.in_msg[1] << 16) | (ssl.in_msg[2] << 8) | ssl.in_msg[3]);
	do
	{
	}
	while (0);
	if ssl.conf.transport == 1
	{
		i32 ret;
		u32 recv_msg_seq = (ssl.in_msg[4] << 8) | ssl.in_msg[5];
		if ssl.handshake != NULL && recv_msg_seq != ssl.handshake.in_msg_seq
		{
			if recv_msg_seq == ssl.handshake.in_flight_start_seq - 1 && ssl.in_msg[0] != 3
			{
				do
				{
				}
				while (0);
				if (ret = mbedtls_ssl_resend(ssl)) != 0
				{
					do
					{
					}
					while (0);
					return ret;
				}
			}
			else
			{
				do
				{
				}
				while (0);
			}
			return -0x6900;
		}
		if ssl.in_msglen < ssl.in_hslen || memcmp(ssl.in_msg + 6, "\0\0\0", 3) != 0 || memcmp(ssl.in_msg + 9, ssl.in_msg + 1, 3) != 0 || (ssl.handshake != NULL && ssl.handshake.hs_msg != NULL)
		{
			do
			{
			}
			while (0);
			if (ret = ssl_reassemble_dtls_handshake(ssl)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
		}
	}
	else
		if ssl.in_msglen < ssl.in_hslen
		{
			do
			{
			}
			while (0);
			return -0x7080;
		}
	if ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER && ssl.handshake != NULL
	{
		ssl.handshake.update_checksum(ssl, ssl.in_msg, ssl.in_hslen);
	}
	if ssl.conf.transport == 1 && ssl.handshake != NULL
	{
		ssl.handshake.in_msg_seq++;
	}
	return 0;
}

fn ssl_dtls_replay_reset(mbedtls_ssl_context * ssl)
{
	ssl.in_window_top = 0;
	ssl.in_window = 0;
}

fn u64 ssl_load_six_bytes(u8 * buf) -> inline
{
	return ((u64) buf[0] << 40) | ((u64) buf[1] << 32) | ((u64) buf[2] << 24) | ((u64) buf[3] << 16) | ((u64) buf[4] << 8) | ((u64) buf[5]);
}

pub fn mbedtls_ssl_dtls_replay_check(mbedtls_ssl_context * ssl) -> i32
{
	u64 rec_seqnum = ssl_load_six_bytes(ssl.in_ctr + 2);
	u64 bit;
	if ssl.conf.anti_replay == 0
	{
		return 0;
	}
	if rec_seqnum > ssl.in_window_top
	{
		return 0;
	}
	bit = ssl.in_window_top - rec_seqnum;
	if bit >= 64
	{
		return -1;
	}
	if (ssl.in_window & ((u64) 1 << bit)) != 0
	{
		return -1;
	}
	return 0;
}

pub fn mbedtls_ssl_dtls_replay_update(mbedtls_ssl_context * ssl)
{
	u64 rec_seqnum = ssl_load_six_bytes(ssl.in_ctr + 2);
	if ssl.conf.anti_replay == 0
	{
		return;
	}
	if rec_seqnum > ssl.in_window_top
	{
		u64 shift = rec_seqnum - ssl.in_window_top;
		if shift >= 64
		{
			ssl.in_window = 1;
		}
		else
		{
			ssl.in_window <<= shift;
			ssl.in_window |= 1;
		}
		ssl.in_window_top = rec_seqnum;
	}
	else
	{
		u64 bit = ssl.in_window_top - rec_seqnum;
		if bit < 64
		{
			ssl.in_window |= (u64) 1 << bit;
		}
	}
}

fn ssl_check_dtls_clihlo_cookie(mbedtls_ssl_cookie_write_t * f_cookie_write, mbedtls_ssl_cookie_check_t * f_cookie_check, void * p_cookie, const u8 * cli_id, usize cli_id_len, const u8 * in, usize in_len, u8 * obuf, usize buf_len, usize * olen) -> i32
{
	usize sid_len, cookie_len;
	u8 * p;
	if f_cookie_write == NULL || f_cookie_check == NULL
	{
		return -0x7100;
	}
	if in_len < 61 || in[0] != 22 || in[3] != 0 || in[4] != 0 || in[19] != 0 || in[20] != 0 || in[21] != 0
	{
		return -0x7900;
	}
	sid_len = in[59];
	if sid_len > in_len - 61
	{
		return -0x7900;
	}
	cookie_len = in[60 + sid_len];
	if cookie_len > in_len - 60
	{
		return -0x7900;
	}
	if f_cookie_check(p_cookie, in + sid_len + 61, cookie_len, cli_id, cli_id_len) == 0
	{
		return 0;
	}
	if buf_len < 28
	{
		return -0x6A00;
	}
	memcpy(obuf, in, 25);
	obuf[13] = 3;
	obuf[25] = 0xfe;
	obuf[26] = 0xff;
	p = obuf + 28;
	if f_cookie_write(p_cookie, &p, obuf + buf_len, cli_id, cli_id_len) != 0
	{
		return -0x6C00;
	}
	*olen = p - obuf;
	obuf[27] = (i8) (*olen - 28);
	obuf[14] = obuf[22] = (i8) ((*olen - 25) >> 16);
	obuf[15] = obuf[23] = (i8) ((*olen - 25) >> 8);
	obuf[16] = obuf[24] = (i8) ((*olen - 25));
	obuf[11] = (i8) ((*olen - 13) >> 8);
	obuf[12] = (i8) ((*olen - 13));
	return -0x6A80;
}

fn ssl_handle_possible_reconnect(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	usize len;
	ret = ssl_check_dtls_clihlo_cookie(ssl.conf.f_cookie_write, ssl.conf.f_cookie_check, ssl.conf.p_cookie, ssl.cli_id, ssl.cli_id_len, ssl.in_buf, ssl.in_left, ssl.out_buf, 16384, &len);
	do
	{
	}
	while (0);
	if ret == -0x6A80
	{
		(void) ssl.f_send(ssl.p_bio, ssl.out_buf, len);
		return -0x6A80;
	}
	if ret == 0
	{
		if (ret = ssl_session_reset_int(ssl, 1)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		return -0x6780;
	}
	return ret;
}

fn ssl_parse_record_header(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	i32 major_ver, minor_ver;
	do
	{
	}
	while (0);
	ssl.in_msgtype = ssl.in_hdr[0];
	ssl.in_msglen = (ssl.in_len[0] << 8) | ssl.in_len[1];
	mbedtls_ssl_read_version(&major_ver, &minor_ver, ssl.conf.transport, ssl.in_hdr + 1);
	do
	{
	}
	while (0);
	if ssl.in_msgtype != 22 && ssl.in_msgtype != 21 && ssl.in_msgtype != 20 && ssl.in_msgtype != 23
	{
		do
		{
		}
		while (0);
		if (ret = mbedtls_ssl_send_alert_message(ssl, 2, 10)) != 0
		{
			return ret;
		}
		return -0x7200;
	}
	if major_ver != ssl.major_ver
	{
		do
		{
		}
		while (0);
		return -0x7200;
	}
	if minor_ver > ssl.conf.max_minor_ver
	{
		do
		{
		}
		while (0);
		return -0x7200;
	}
	if ssl.in_msglen > (16384 + 0 + 29 + 48 + 256) - (usize)(ssl.in_msg - ssl.in_buf)
	{
		do
		{
		}
		while (0);
		return -0x7200;
	}
	if ssl.transform_in == NULL
	{
		if ssl.in_msglen < 1 || ssl.in_msglen > 16384
		{
			do
			{
			}
			while (0);
			return -0x7200;
		}
	}
	else
	{
		if ssl.in_msglen < ssl.transform_in.minlen
		{
			do
			{
			}
			while (0);
			return -0x7200;
		}
		if ssl.minor_ver >= 1 && ssl.in_msglen > ssl.transform_in.minlen + 16384 + 256
		{
			do
			{
			}
			while (0);
			return -0x7200;
		}
	}
	if ssl.conf.transport == 1
	{
		u32 rec_epoch = (ssl.in_ctr[0] << 8) | ssl.in_ctr[1];
		if ssl.in_msgtype == 20 && ssl.state != MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC && ssl.state != MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC
		{
			do
			{
			}
			while (0);
			return -0x6700;
		}
		if ssl.in_msgtype == 23 && ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER
		{
			do
			{
			}
			while (0);
			return -0x6700;
		}
		if rec_epoch != ssl.in_epoch
		{
			do
			{
			}
			while (0);
			if ssl.conf.endpoi32 == 1 && ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER && rec_epoch == 0 && ssl.in_msgtype == 22 && ssl.in_left > 13 && ssl.in_buf[13] == 1
			{
				do
				{
				}
				while (0);
				return ssl_handle_possible_reconnect(ssl);
			}
			else
			{
				return -0x6700;
			}
		}
		if rec_epoch == ssl.in_epoch && mbedtls_ssl_dtls_replay_check(ssl) != 0
		{
			do
			{
			}
			while (0);
			return -0x6700;
		}
	}
	return 0;
}

fn ssl_prepare_record_content(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret, done = 0;
	do
	{
	}
	while (0);
	if mbedtls_ssl_hw_record_read != NULL
	{
		do
		{
		}
		while (0);
		ret = mbedtls_ssl_hw_record_read(ssl);
		if ret != 0 && ret != -0x6F80
		{
			do
			{
			}
			while (0);
			return -0x7F80;
		}
		if ret == 0
		{
			done = 1;
		}
	}
	if !done && ssl.transform_in != NULL
	{
		if (ret = ssl_decrypt_buf(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		do
		{
		}
		while (0);
		if ssl.in_msglen > 16384
		{
			do
			{
			}
			while (0);
			return -0x7200;
		}
	}
	if ssl.conf.transport == 1
	{
		mbedtls_ssl_dtls_replay_update(ssl);
	}
	return 0;
}

pub fn mbedtls_ssl_read_record(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	do
	{
	}
	while (0);
	if ssl.in_hslen != 0 && ssl.in_hslen < ssl.in_msglen
	{
		ssl.in_msglen -= ssl.in_hslen;
		memmove(ssl.in_msg, ssl.in_msg + ssl.in_hslen, ssl.in_msglen);
		do
		{
		}
		while (0);
		if (ret = ssl_prepare_handshake_record(ssl)) != 0
		{
			return ret;
		}
		return 0;
	}
	ssl.in_hslen = 0;
read_record_header:
	if (ret = mbedtls_ssl_fetch_input(ssl, mbedtls_ssl_hdr_len(ssl))) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if (ret = ssl_parse_record_header(ssl)) != 0
	{
		if ssl.conf.transport == 1 && ret != -0x6780
		{
			if ret == -0x6700
			{
				ssl.next_record_offset = ssl.in_msglen + mbedtls_ssl_hdr_len(ssl);
				do
				{
				}
				while (0);
			}
			else
			{
				ssl.next_record_offset = 0;
				ssl.in_left = 0;
				do
				{
				}
				while (0);
			}
			goto read_record_header;
		}
		return ret;
	}
	if (ret = mbedtls_ssl_fetch_input(ssl, mbedtls_ssl_hdr_len(ssl) + ssl.in_msglen)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl.conf.transport == 1
	{
		ssl.next_record_offset = ssl.in_msglen + mbedtls_ssl_hdr_len(ssl);
	}
	else
	{
		ssl.in_left = 0;
	}
	if (ret = ssl_prepare_record_content(ssl)) != 0
	{
		if ssl.conf.transport == 1
		{
			if ret == -0x7200 || ret == -0x7180
			{
				if ssl.state == MBEDTLS_SSL_CLIENT_FINISHED || ssl.state == MBEDTLS_SSL_SERVER_FINISHED
				{
					return ret;
				}
				if ssl.conf.badmac_limit != 0 && ++ssl.badmac_seen >= ssl.conf.badmac_limit
				{
					do
					{
					}
					while (0);
					return -0x7180;
				}
				do
				{
				}
				while (0);
				goto read_record_header;
			}
			return ret;
		}
		else
		{
			return ret;
		}
	}
	if ssl.conf.transport == 1 && ssl.handshake != NULL && ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER
	{
		if ssl.in_msgtype == 22 && ssl.in_msg[0] == 20
		{
			do
			{
			}
			while (0);
			if (ret = mbedtls_ssl_resend(ssl)) != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
			return -0x6900;
		}
		else
		{
			ssl_handshake_wrapup_free_hs_transform(ssl);
		}
	}
	if ssl.in_msgtype == 22
	{
		if (ret = ssl_prepare_handshake_record(ssl)) != 0
		{
			return ret;
		}
	}
	if ssl.in_msgtype == 21
	{
		do
		{
		}
		while (0);
		if ssl.in_msg[0] == 2
		{
			do
			{
			}
			while (0);
			return -0x7780;
		}
		if ssl.in_msg[0] == 1 && ssl.in_msg[1] == 0
		{
			do
			{
			}
			while (0);
			return -0x7880;
		}
		if ssl.in_msg[0] == 1 && ssl.in_msg[1] == 100
		{
			do
			{
			}
			while (0);
			return 0;
		}
		goto read_record_header;
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_send_fatal_handshake_failure(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	if (ret = mbedtls_ssl_send_alert_message(ssl, 2, 40)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_ssl_send_alert_message(mbedtls_ssl_context * ssl, u8 level, u8 message) -> i32
{
	i32 ret;
	if ssl == NULL || ssl.conf == NULL
	{
		return -0x7100;
	}
	do
	{
	}
	while (0);
	ssl.out_msgtype = 21;
	ssl.out_msglen = 2;
	ssl.out_msg[0] = level;
	ssl.out_msg[1] = message;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_write_certificate(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = -0x7080;
	usize i, n;
	const mbedtls_x509_crt * crt;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if ssl.conf.endpoi32 == 0
	{
		if ssl.client_auth == 0
		{
			do
			{
			}
			while (0);
			ssl.state++;
			return 0;
		}
	}
	if ssl.conf.endpoi32 == 1
	{
		if mbedtls_ssl_own_cert(ssl) == NULL
		{
			do
			{
			}
			while (0);
			return -0x7580;
		}
	}
	do
	{
	}
	while (0);
	i = 7;
	crt = mbedtls_ssl_own_cert(ssl);
	while (crt != NULL)
	{
		n = crt.raw.len;
		if n > 16384 - 3 - i
		{
			do
			{
			}
			while (0);
			return -0x7500;
		}
		ssl.out_msg[i] = (i8) (n >> 16);
		ssl.out_msg[i + 1] = (i8) (n >> 8);
		ssl.out_msg[i + 2] = (i8) (n);
		i += 3;
		memcpy(ssl.out_msg + i, crt.raw.p, n);
		i += n;
		crt = crt.next;
	}
	ssl.out_msg[4] = (i8) ((i - 7) >> 16);
	ssl.out_msg[5] = (i8) ((i - 7) >> 8);
	ssl.out_msg[6] = (i8) ((i - 7));
	ssl.out_msglen = i;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 11;
	ssl.state++;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return ret;
}

pub fn mbedtls_ssl_parse_certificate(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = -0x7080;
	usize i, n;
	const mbedtls_ssl_ciphersuite_t * ciphersuite_info = ssl.transform_negotiate.ciphersuite_info;
	i32 authmode = ssl.conf.authmode;
	do
	{
	}
	while (0);
	if ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if ssl.conf.endpoi32 == 1 && ciphersuite_info.key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK
	{
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if ssl.handshake.sni_authmode != 3
	{
		authmode = ssl.handshake.sni_authmode;
	}
	if ssl.conf.endpoi32 == 1 && authmode == 0
	{
		ssl.session_negotiate.verify_result = 0x80;
		do
		{
		}
		while (0);
		ssl.state++;
		return 0;
	}
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	ssl.state++;
	if ssl.conf.endpoi32 == 1 && ssl.minor_ver != 0
	{
		if ssl.in_hslen == 3 + mbedtls_ssl_hs_hdr_len(ssl) && ssl.in_msgtype == 22 && ssl.in_msg[0] == 11 && memcmp(ssl.in_msg + mbedtls_ssl_hs_hdr_len(ssl), "\0\0\0", 3) == 0
		{
			do
			{
			}
			while (0);
			ssl.session_negotiate.verify_result = 0x40;
			if authmode == 1
			{
				return 0;
			}
			else
			{
				return -0x7480;
			}
		}
	}
	if ssl.in_msgtype != 22
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	if ssl.in_msg[0] != 11 || ssl.in_hslen < mbedtls_ssl_hs_hdr_len(ssl) + 3 + 3
	{
		do
		{
		}
		while (0);
		return -0x7A00;
	}
	i = mbedtls_ssl_hs_hdr_len(ssl);
	n = (ssl.in_msg[i + 1] << 8) | ssl.in_msg[i + 2];
	if ssl.in_msg[i] != 0 || ssl.in_hslen != n + 3 + mbedtls_ssl_hs_hdr_len(ssl)
	{
		do
		{
		}
		while (0);
		return -0x7A00;
	}
	if ssl.session_negotiate.peer_cert != NULL
	{
		mbedtls_x509_crt_free(ssl.session_negotiate.peer_cert);
		mbedtls_free(ssl.session_negotiate.peer_cert);
	}
	if (ssl.session_negotiate.peer_cert = mbedtls_calloc(1, sizeof(mbedtls_x509_crt))) == NULL
	{
		do
		{
		}
		while (0);
		return -0x7F00;
	}
	mbedtls_x509_crt_init(ssl.session_negotiate.peer_cert);
	i += 3;
	while (i < ssl.in_hslen)
	{
		if ssl.in_msg[i] != 0
		{
			do
			{
			}
			while (0);
			return -0x7A00;
		}
		n = ((i32 int) ssl.in_msg[i + 1] << 8) | (i32 int) ssl.in_msg[i + 2];
		i += 3;
		if n < 128 || i + n > ssl.in_hslen
		{
			do
			{
			}
			while (0);
			return -0x7A00;
		}
		ret = mbedtls_x509_crt_parse_der(ssl.session_negotiate.peer_cert, ssl.in_msg + i, n);
		if ret != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
		i += n;
	}
	do
	{
	}
	while (0);
	if authmode != 0
	{
		mbedtls_x509_crt * ca_chain;
		mbedtls_x509_crl * ca_crl;
		if ssl.handshake.sni_ca_chain != NULL
		{
			ca_chain = ssl.handshake.sni_ca_chain;
			ca_crl = ssl.handshake.sni_ca_crl;
		}
		else
		{
			ca_chain = ssl.conf.ca_chain;
			ca_crl = ssl.conf.ca_crl;
		}
		if ca_chain == NULL
		{
			do
			{
			}
			while (0);
			return -0x7680;
		}
		ret = mbedtls_x509_crt_verify_with_profile(ssl.session_negotiate.peer_cert, ca_chain, ca_crl, ssl.conf.cert_profile, ssl.hostname, &ssl.session_negotiate.verify_result, ssl.conf.f_vrfy, ssl.conf.p_vrfy);
		if ret != 0
		{
			do
			{
			}
			while (0);
		}
		{
			const mbedtls_pk_context * pk = &ssl.session_negotiate.peer_cert.pk;
			if mbedtls_pk_can_do(pk, MBEDTLS_PK_ECKEY) && mbedtls_ssl_check_curve(ssl, mbedtls_pk_ec(*pk)->grp.id) != 0
			{
				do
				{
				}
				while (0);
				if ret == 0
				{
					ret = -0x7A00;
				}
			}
		}
		if mbedtls_ssl_check_cert_usage(ssl.session_negotiate.peer_cert, ciphersuite_info, !ssl.conf.endpoint, &ssl.session_negotiate.verify_result) != 0
		{
			do
			{
			}
			while (0);
			if ret == 0
			{
				ret = -0x7A00;
			}
		}
		if authmode == 1
		{
			ret = 0;
		}
	}
	do
	{
	}
	while (0);
	return ret;
}

pub fn mbedtls_ssl_write_change_cipher_spec(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	do
	{
	}
	while (0);
	ssl.out_msgtype = 20;
	ssl.out_msglen = 1;
	ssl.out_msg[0] = 1;
	ssl.state++;
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_parse_change_cipher_spec(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	do
	{
	}
	while (0);
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl.in_msgtype != 20
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	if ssl.in_msglen != 1 || ssl.in_msg[0] != 1
	{
		do
		{
		}
		while (0);
		return -0x7E00;
	}
	do
	{
	}
	while (0);
	ssl.transform_in = ssl.transform_negotiate;
	ssl.session_in = ssl.session_negotiate;
	if ssl.conf.transport == 1
	{
		ssl_dtls_replay_reset(ssl);
		if ++ssl.in_epoch == 0
		{
			do
			{
			}
			while (0);
			return -0x6B80;
		}
	}
	else
	{
		memset(ssl.in_ctr, 0, 8);
	}
	if ssl.minor_ver >= 2
	{
		ssl.in_msg = ssl.in_iv + ssl.transform_negotiate.ivlen - ssl.transform_negotiate.fixed_ivlen;
	}
	else
	{
		ssl.in_msg = ssl.in_iv;
	}
	if mbedtls_ssl_hw_record_activate != NULL
	{
		if (ret = mbedtls_ssl_hw_record_activate(ssl, 1)) != 0
		{
			do
			{
			}
			while (0);
			return -0x7F80;
		}
	}
	ssl.state++;
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_optimize_checksum(mbedtls_ssl_context * ssl, const mbedtls_ssl_ciphersuite_t * ciphersuite_info)
{
	((void) ciphersuite_info);
	if ciphersuite_info.mac == MBEDTLS_MD_SHA384
	{
		ssl.handshake.update_checksum = ssl_update_checksum_sha384;
	}
	else
		if ciphersuite_info.mac != MBEDTLS_MD_SHA384
		{
			ssl.handshake.update_checksum = ssl_update_checksum_sha256;
		}
		else
		{
			do
			{
			}
			while (0);
			return;
		}
}

pub fn mbedtls_ssl_reset_checksum(mbedtls_ssl_context * ssl)
{
	mbedtls_sha256_starts(&ssl.handshake.fin_sha256, 0);
	mbedtls_sha512_starts(&ssl.handshake.fin_sha512, 1);
}

fn ssl_update_checksum_start(mbedtls_ssl_context * ssl, const u8 * buf, usize len)
{
	mbedtls_sha256_update(&ssl.handshake.fin_sha256, buf, len);
	mbedtls_sha512_update(&ssl.handshake.fin_sha512, buf, len);
}

fn ssl_update_checksum_sha256(mbedtls_ssl_context * ssl, const u8 * buf, usize len)
{
	mbedtls_sha256_update(&ssl.handshake.fin_sha256, buf, len);
}

fn ssl_update_checksum_sha384(mbedtls_ssl_context * ssl, const u8 * buf, usize len)
{
	mbedtls_sha512_update(&ssl.handshake.fin_sha512, buf, len);
}

fn ssl_calc_finished_tls_sha256(mbedtls_ssl_context * ssl, u8 * buf, i32 from)
{
	i32 len = 12;
	const i8 * sender;
	mbedtls_sha256_context sha256;
	u8 padbuf[32];
	mbedtls_ssl_session * session = ssl.session_negotiate;
	if !session
	{
		session = ssl.session;
	}
	mbedtls_sha256_init(&sha256);
	do
	{
	}
	while (0);
	mbedtls_sha256_clone(&sha256, &ssl.handshake.fin_sha256);
	do
	{
	}
	while (0);
	sender = (from == 0) ? "client finished" : "server finished";
	mbedtls_sha256_finish(&sha256, padbuf);
	ssl.handshake.tls_prf(session.master, 48, sender, padbuf, 32, buf, len);
	do
	{
	}
	while (0);
	mbedtls_sha256_free(&sha256);
	zeroize(padbuf, sizeof(padbuf));
	do
	{
	}
	while (0);
}

fn ssl_calc_finished_tls_sha384(mbedtls_ssl_context * ssl, u8 * buf, i32 from)
{
	i32 len = 12;
	const i8 * sender;
	mbedtls_sha512_context sha512;
	u8 padbuf[48];
	mbedtls_ssl_session * session = ssl.session_negotiate;
	if !session
	{
		session = ssl.session;
	}
	mbedtls_sha512_init(&sha512);
	do
	{
	}
	while (0);
	mbedtls_sha512_clone(&sha512, &ssl.handshake.fin_sha512);
	do
	{
	}
	while (0);
	sender = (from == 0) ? "client finished" : "server finished";
	mbedtls_sha512_finish(&sha512, padbuf);
	ssl.handshake.tls_prf(session.master, 48, sender, padbuf, 48, buf, len);
	do
	{
	}
	while (0);
	mbedtls_sha512_free(&sha512);
	zeroize(padbuf, sizeof(padbuf));
	do
	{
	}
	while (0);
}

fn ssl_handshake_wrapup_free_hs_transform(mbedtls_ssl_context * ssl)
{
	do
	{
	}
	while (0);
	mbedtls_ssl_handshake_free(ssl.handshake);
	mbedtls_free(ssl.handshake);
	ssl.handshake = NULL;
	if ssl.transform
	{
		mbedtls_ssl_transform_free(ssl.transform);
		mbedtls_free(ssl.transform);
	}
	ssl.transform = ssl.transform_negotiate;
	ssl.transform_negotiate = NULL;
	do
	{
	}
	while (0);
}

pub fn mbedtls_ssl_handshake_wrapup(mbedtls_ssl_context * ssl)
{
	i32 resume = ssl.handshake.resume;
	do
	{
	}
	while (0);
	if ssl.session
	{
		ssl.session_negotiate.encrypt_then_mac = ssl.session.encrypt_then_mac;
		mbedtls_ssl_session_free(ssl.session);
		mbedtls_free(ssl.session);
	}
	ssl.session = ssl.session_negotiate;
	ssl.session_negotiate = NULL;
	if ssl.conf.f_set_cache != NULL && ssl.session.id_len != 0 && resume == 0
	{
		if ssl.conf.f_set_cache(ssl.conf.p_cache, ssl.session) != 0
			do
			{
			}
			while (0);
	}
	if ssl.conf.transport == 1 && ssl.handshake.flight != NULL
	{
		ssl_set_timer(ssl, 0);
		do
		{
		}
		while (0);
	}
	else
	{
		ssl_handshake_wrapup_free_hs_transform(ssl);
	}
	ssl.state++;
	do
	{
	}
	while (0);
}

pub fn mbedtls_ssl_write_finished(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret, hash_len;
	do
	{
	}
	while (0);
	if ssl.minor_ver >= 2
	{
		ssl.out_msg = ssl.out_iv + ssl.transform_negotiate.ivlen - ssl.transform_negotiate.fixed_ivlen;
	}
	else
	{
		ssl.out_msg = ssl.out_iv;
	}
	ssl.handshake.calc_finished(ssl, ssl.out_msg + 4, ssl.conf.endpoint);
	hash_len = (ssl.minor_ver == 0) ? 36 : 12;
	ssl.out_msglen = 4 + hash_len;
	ssl.out_msgtype = 22;
	ssl.out_msg[0] = 20;
	if ssl.handshake.resume != 0
	{
		if ssl.conf.endpoi32 == 0
		{
			ssl.state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
		}
		if ssl.conf.endpoi32 == 1
		{
			ssl.state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
		}
	}
	else
	{
		ssl.state++;
	}
	do
	{
	}
	while (0);
	if ssl.conf.transport == 1
	{
		u8 i;
		ssl.handshake.alt_transform_out = ssl.transform_out;
		memcpy(ssl.handshake.alt_out_ctr, ssl.out_ctr, 8);
		memset(ssl.out_ctr + 2, 0, 6);
		for (i = 2; i > 0; i--)
			if ++ssl.out_ctr[i - 1] != 0
			{
				break;

			}
		if i == 0
		{
			do
			{
			}
			while (0);
			return -0x6B80;
		}
	}
	else
	{
		memset(ssl.out_ctr, 0, 8);
	}
	ssl.transform_out = ssl.transform_negotiate;
	ssl.session_out = ssl.session_negotiate;
	if mbedtls_ssl_hw_record_activate != NULL
	{
		if (ret = mbedtls_ssl_hw_record_activate(ssl, 0)) != 0
		{
			do
			{
			}
			while (0);
			return -0x7F80;
		}
	}
	if ssl.conf.transport == 1
	{
		mbedtls_ssl_send_flight_completed(ssl);
	}
	if (ret = mbedtls_ssl_write_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_parse_finished(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	u32 hash_len;
	u8 buf[12];
	do
	{
	}
	while (0);
	ssl.handshake.calc_finished(ssl, buf, ssl.conf.endpoi32 ^ 1);
	if (ret = mbedtls_ssl_read_record(ssl)) != 0
	{
		do
		{
		}
		while (0);
		return ret;
	}
	if ssl.in_msgtype != 22
	{
		do
		{
		}
		while (0);
		return -0x7700;
	}
	hash_len = 12;
	if ssl.in_msg[0] != 20 || ssl.in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + hash_len
	{
		do
		{
		}
		while (0);
		return -0x7E80;
	}
	if mbedtls_ssl_safer_memcmp(ssl.in_msg + mbedtls_ssl_hs_hdr_len(ssl), buf, hash_len) != 0
	{
		do
		{
		}
		while (0);
		return -0x7E80;
	}
	if ssl.handshake.resume != 0
	{
		if ssl.conf.endpoi32 == 0
		{
			ssl.state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
		}
		if ssl.conf.endpoi32 == 1
		{
			ssl.state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
		}
	}
	else
	{
		ssl.state++;
	}
	if ssl.conf.transport == 1
	{
		mbedtls_ssl_recv_flight_completed(ssl);
	}
	do
	{
	}
	while (0);
	return 0;
}

fn ssl_handshake_params_init(mbedtls_ssl_handshake_params * handshake)
{
	memset(handshake, 0, sizeof(mbedtls_ssl_handshake_params));
	mbedtls_sha256_init(&handshake.fin_sha256);
	mbedtls_sha256_starts(&handshake.fin_sha256, 0);
	mbedtls_sha512_init(&handshake.fin_sha512);
	mbedtls_sha512_starts(&handshake.fin_sha512, 1);
	handshake.update_checksum = ssl_update_checksum_start;
	handshake.sig_alg = 2;
	mbedtls_dhm_init(&handshake.dhm_ctx);
	mbedtls_ecdh_init(&handshake.ecdh_ctx);
	handshake.sni_authmode = 3;
}

fn ssl_transform_init(mbedtls_ssl_transform * transform)
{
	memset(transform, 0, sizeof(mbedtls_ssl_transform));
	mbedtls_cipher_init(&transform.cipher_ctx_enc);
	mbedtls_cipher_init(&transform.cipher_ctx_dec);
	mbedtls_md_init(&transform.md_ctx_enc);
	mbedtls_md_init(&transform.md_ctx_dec);
}

pub fn mbedtls_ssl_session_init(mbedtls_ssl_session * session)
{
	memset(session, 0, sizeof(mbedtls_ssl_session));
}

fn ssl_handshake_init(mbedtls_ssl_context * ssl) -> i32
{
	if ssl.transform_negotiate
	{
		mbedtls_ssl_transform_free(ssl.transform_negotiate);
	}
	if ssl.session_negotiate
	{
		mbedtls_ssl_session_free(ssl.session_negotiate);
	}
	if ssl.handshake
	{
		mbedtls_ssl_handshake_free(ssl.handshake);
	}
	if ssl.transform_negotiate == NULL
	{
		ssl.transform_negotiate = mbedtls_calloc(1, sizeof(mbedtls_ssl_transform));
	}
	if ssl.session_negotiate == NULL
	{
		ssl.session_negotiate = mbedtls_calloc(1, sizeof(mbedtls_ssl_session));
	}
	if ssl.handshake == NULL
	{
		ssl.handshake = mbedtls_calloc(1, sizeof(mbedtls_ssl_handshake_params));
	}
	if ssl.handshake == NULL || ssl.transform_negotiate == NULL || ssl.session_negotiate == NULL
	{
		do
		{
		}
		while (0);
		mbedtls_free(ssl.handshake);
		mbedtls_free(ssl.transform_negotiate);
		mbedtls_free(ssl.session_negotiate);
		ssl.handshake = NULL;
		ssl.transform_negotiate = NULL;
		ssl.session_negotiate = NULL;
		return -0x7F00;
	}
	mbedtls_ssl_session_init(ssl.session_negotiate);
	ssl_transform_init(ssl.transform_negotiate);
	ssl_handshake_params_init(ssl.handshake);
	if ssl.conf.transport == 1
	{
		ssl.handshake.alt_transform_out = ssl.transform_out;
		if ssl.conf.endpoi32 == 0
		{
			ssl.handshake.retransmit_state = 0;
		}
		else
		{
			ssl.handshake.retransmit_state = 2;
		}
		ssl_set_timer(ssl, 0);
	}
	return 0;
}

fn ssl_cookie_write_dummy(void * ctx, u8 ** p, u8 * end, const u8 * cli_id, usize cli_id_len) -> i32
{
	((void) ctx);
	((void) p);
	((void) end);
	((void) cli_id);
	((void) cli_id_len);
	return -0x7080;
}

fn ssl_cookie_check_dummy(void * ctx, const u8 * cookie, usize cookie_len, const u8 * cli_id, usize cli_id_len) -> i32
{
	((void) ctx);
	((void) cookie);
	((void) cookie_len);
	((void) cli_id);
	((void) cli_id_len);
	return -0x7080;
}

pub fn mbedtls_ssl_init(mbedtls_ssl_context * ssl)
{
	memset(ssl, 0, sizeof(mbedtls_ssl_context));
}

pub fn mbedtls_ssl_setup(mbedtls_ssl_context * ssl, const mbedtls_ssl_config * conf) -> i32
{
	i32 ret;
	const usize len = (16384 + 0 + 29 + 48 + 256);
	ssl.conf = conf;
	if (ssl.in_buf = mbedtls_calloc(1, len)) == NULL || (ssl.out_buf = mbedtls_calloc(1, len)) == NULL
	{
		do
		{
		}
		while (0);
		mbedtls_free(ssl.in_buf);
		ssl.in_buf = NULL;
		return -0x7F00;
	}
	if conf.transport == 1
	{
		ssl.out_hdr = ssl.out_buf;
		ssl.out_ctr = ssl.out_buf + 3;
		ssl.out_len = ssl.out_buf + 11;
		ssl.out_iv = ssl.out_buf + 13;
		ssl.out_msg = ssl.out_buf + 13;
		ssl.in_hdr = ssl.in_buf;
		ssl.in_ctr = ssl.in_buf + 3;
		ssl.in_len = ssl.in_buf + 11;
		ssl.in_iv = ssl.in_buf + 13;
		ssl.in_msg = ssl.in_buf + 13;
	}
	else
	{
		ssl.out_ctr = ssl.out_buf;
		ssl.out_hdr = ssl.out_buf + 8;
		ssl.out_len = ssl.out_buf + 11;
		ssl.out_iv = ssl.out_buf + 13;
		ssl.out_msg = ssl.out_buf + 13;
		ssl.in_ctr = ssl.in_buf;
		ssl.in_hdr = ssl.in_buf + 8;
		ssl.in_len = ssl.in_buf + 11;
		ssl.in_iv = ssl.in_buf + 13;
		ssl.in_msg = ssl.in_buf + 13;
	}
	if (ret = ssl_handshake_init(ssl)) != 0
	{
		return ret;
	}
	return 0;
}

fn ssl_session_reset_int(mbedtls_ssl_context * ssl, i32 partial) -> i32
{
	i32 ret;
	ssl.state = MBEDTLS_SSL_HELLO_REQUEST;
	ssl_set_timer(ssl, 0);
	ssl.secure_renegotiation = 0;
	ssl.in_offt = NULL;
	ssl.in_msg = ssl.in_buf + 13;
	ssl.in_msgtype = 0;
	ssl.in_msglen = 0;
	if partial == 0
	{
		ssl.in_left = 0;
	}
	ssl.next_record_offset = 0;
	ssl.in_epoch = 0;
	ssl_dtls_replay_reset(ssl);
	ssl.in_hslen = 0;
	ssl.nb_zero = 0;
	ssl.record_read = 0;
	ssl.out_msg = ssl.out_buf + 13;
	ssl.out_msgtype = 0;
	ssl.out_msglen = 0;
	ssl.out_left = 0;
	ssl.transform_in = NULL;
	ssl.transform_out = NULL;
	memset(ssl.out_buf, 0, (16384 + 0 + 29 + 48 + 256));
	if partial == 0
	{
		memset(ssl.in_buf, 0, (16384 + 0 + 29 + 48 + 256));
	}
	if mbedtls_ssl_hw_record_reset != NULL
	{
		do
		{
		}
		while (0);
		if (ret = mbedtls_ssl_hw_record_reset(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return -0x7F80;
		}
	}
	if ssl.transform
	{
		mbedtls_ssl_transform_free(ssl.transform);
		mbedtls_free(ssl.transform);
		ssl.transform = NULL;
	}
	if ssl.session
	{
		mbedtls_ssl_session_free(ssl.session);
		mbedtls_free(ssl.session);
		ssl.session = NULL;
	}
	ssl.alpn_chosen = NULL;
	if partial == 0
	{
		mbedtls_free(ssl.cli_id);
		ssl.cli_id = NULL;
		ssl.cli_id_len = 0;
	}
	if (ret = ssl_handshake_init(ssl)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_ssl_session_reset(mbedtls_ssl_context * ssl) -> i32
{
	return ssl_session_reset_int(ssl, 0);
}

pub fn mbedtls_ssl_conf_endpoint(mbedtls_ssl_config * conf, i32 endpoint)
{
	conf.endpoi32 = endpoint;
}

pub fn mbedtls_ssl_conf_transport(mbedtls_ssl_config * conf, i32 transport)
{
	conf.transport = transport;
}

pub fn mbedtls_ssl_conf_dtls_anti_replay(mbedtls_ssl_config * conf, i8 mode)
{
	conf.anti_replay = mode;
}

pub fn mbedtls_ssl_conf_dtls_badmac_limit(mbedtls_ssl_config * conf, i32 limit)
{
	conf.badmac_limit = limit;
}

pub fn mbedtls_ssl_conf_handshake_timeout(mbedtls_ssl_config * conf, u32 min, u32 max)
{
	conf.hs_timeout_min = min;
	conf.hs_timeout_max = max;
}

pub fn mbedtls_ssl_conf_authmode(mbedtls_ssl_config * conf, i32 authmode)
{
	conf.authmode = authmode;
}

pub fn mbedtls_ssl_conf_verify(mbedtls_ssl_config * conf, i32 (*f_vrfy)(void *, mbedtls_x509_crt *, int, u32 *), void * p_vrfy)
{
	conf.f_vrfy = f_vrfy;
	conf.p_vrfy = p_vrfy;
}

pub fn mbedtls_ssl_conf_rng(mbedtls_ssl_config * conf, i32 (*f_rng)(void *, u8 *, usize), void * p_rng)
{
	conf.f_rng = f_rng;
	conf.p_rng = p_rng;
}

pub fn mbedtls_ssl_conf_dbg(mbedtls_ssl_config * conf, void (*f_dbg)(void *, int, const i8 *, int, const i8 *), void * p_dbg)
{
	conf.f_dbg = f_dbg;
	conf.p_dbg = p_dbg;
}

pub fn mbedtls_ssl_set_bio(mbedtls_ssl_context * ssl, void * p_bio, mbedtls_ssl_send_t * f_send, mbedtls_ssl_recv_t * f_recv, mbedtls_ssl_recv_timeout_t * f_recv_timeout)
{
	ssl.p_bio = p_bio;
	ssl.f_send = f_send;
	ssl.f_recv = f_recv;
	ssl.f_recv_timeout = f_recv_timeout;
}

pub fn mbedtls_ssl_conf_read_timeout(mbedtls_ssl_config * conf, u32 timeout)
{
	conf.read_timeout = timeout;
}

pub fn mbedtls_ssl_set_timer_cb(mbedtls_ssl_context * ssl, void * p_timer, mbedtls_ssl_set_timer_t * f_set_timer, mbedtls_ssl_get_timer_t * f_get_timer)
{
	ssl.p_timer = p_timer;
	ssl.f_set_timer = f_set_timer;
	ssl.f_get_timer = f_get_timer;
	ssl_set_timer(ssl, 0);
}

pub fn mbedtls_ssl_conf_session_cache(mbedtls_ssl_config * conf, void * p_cache, i32 (*f_get_cache)(void *, mbedtls_ssl_session *), i32 (*f_set_cache)(void *, const mbedtls_ssl_session *))
{
	conf.p_cache = p_cache;
	conf.f_get_cache = f_get_cache;
	conf.f_set_cache = f_set_cache;
}

pub fn mbedtls_ssl_set_session(mbedtls_ssl_context * ssl, const mbedtls_ssl_session * session) -> i32
{
	i32 ret;
	if ssl == NULL || session == NULL || ssl.session_negotiate == NULL || ssl.conf.endpoi32 != 0
	{
		return -0x7100;
	}
	if (ret = ssl_session_copy(ssl.session_negotiate, session)) != 0
	{
		return ret;
	}
	ssl.handshake.resume = 1;
	return 0;
}

pub fn mbedtls_ssl_conf_ciphersuites(mbedtls_ssl_config * conf, const i32 * ciphersuites)
{
	conf.ciphersuite_list[0] = ciphersuites;
	conf.ciphersuite_list[1] = ciphersuites;
	conf.ciphersuite_list[2] = ciphersuites;
	conf.ciphersuite_list[3] = ciphersuites;
}

pub fn mbedtls_ssl_conf_ciphersuites_for_version(mbedtls_ssl_config * conf, const i32 * ciphersuites, i32 major, i32 minor)
{
	if major != 3
	{
		return;
	}
	if minor < 0 || minor > 3
	{
		return;
	}
	conf.ciphersuite_list[minor] = ciphersuites;
}

pub fn mbedtls_ssl_conf_cert_profile(mbedtls_ssl_config * conf, const mbedtls_x509_crt_profile * profile)
{
	conf.cert_profile = profile;
}

fn ssl_append_key_cert(mbedtls_ssl_key_cert ** head, mbedtls_x509_crt * cert, mbedtls_pk_context * key) -> i32
{
	mbedtls_ssl_key_cert * new;
	new = mbedtls_calloc(1, sizeof(mbedtls_ssl_key_cert));
	if new == NULL
	{
		return -0x7F00;
	}
	new.cert = cert;
	new.key = key;
	new.next = NULL;
	if *head == NULL
	{
		*head = new;
	}
	else
	{
		mbedtls_ssl_key_cert * cur = *head;
		while (cur.next != NULL)
		{
			cur = cur.next;
		}
		cur.next = new;
	}
	return 0;
}

pub fn mbedtls_ssl_conf_own_cert(mbedtls_ssl_config * conf, mbedtls_x509_crt * own_cert, mbedtls_pk_context * pk_key) -> i32
{
	return ssl_append_key_cert(&conf.key_cert, own_cert, pk_key);
}

pub fn mbedtls_ssl_conf_ca_chain(mbedtls_ssl_config * conf, mbedtls_x509_crt * ca_chain, mbedtls_x509_crl * ca_crl)
{
	conf.ca_chain = ca_chain;
	conf.ca_crl = ca_crl;
}

pub fn mbedtls_ssl_set_hs_own_cert(mbedtls_ssl_context * ssl, mbedtls_x509_crt * own_cert, mbedtls_pk_context * pk_key) -> i32
{
	return ssl_append_key_cert(&ssl.handshake.sni_key_cert, own_cert, pk_key);
}

pub fn mbedtls_ssl_set_hs_ca_chain(mbedtls_ssl_context * ssl, mbedtls_x509_crt * ca_chain, mbedtls_x509_crl * ca_crl)
{
	ssl.handshake.sni_ca_chain = ca_chain;
	ssl.handshake.sni_ca_crl = ca_crl;
}

pub fn mbedtls_ssl_set_hs_authmode(mbedtls_ssl_context * ssl, i32 authmode)
{
	ssl.handshake.sni_authmode = authmode;
}

pub fn mbedtls_ssl_conf_psk(mbedtls_ssl_config * conf, const u8 * psk, usize psk_len, const u8 * psk_identity, usize psk_identity_len) -> i32
{
	if psk == NULL || psk_identity == NULL
	{
		return -0x7100;
	}
	if psk_len > 32
	{
		return -0x7100;
	}
	if (psk_identity_len >> 16) != 0 || psk_identity_len > 16384
	{
		return -0x7100;
	}
	if conf.psk != NULL || conf.psk_identity != NULL
	{
		mbedtls_free(conf.psk);
		mbedtls_free(conf.psk_identity);
		conf.psk = NULL;
		conf.psk_identity = NULL;
	}
	if (conf.psk = mbedtls_calloc(1, psk_len)) == NULL || (conf.psk_identity = mbedtls_calloc(1, psk_identity_len)) == NULL
	{
		mbedtls_free(conf.psk);
		mbedtls_free(conf.psk_identity);
		conf.psk = NULL;
		conf.psk_identity = NULL;
		return -0x7F00;
	}
	conf.psk_len = psk_len;
	conf.psk_identity_len = psk_identity_len;
	memcpy(conf.psk, psk, conf.psk_len);
	memcpy(conf.psk_identity, psk_identity, conf.psk_identity_len);
	return 0;
}

pub fn mbedtls_ssl_set_hs_psk(mbedtls_ssl_context * ssl, const u8 * psk, usize psk_len) -> i32
{
	if psk == NULL || ssl.handshake == NULL
	{
		return -0x7100;
	}
	if psk_len > 32
	{
		return -0x7100;
	}
	if ssl.handshake.psk != NULL
	{
		mbedtls_free(ssl.handshake.psk);
	}
	if (ssl.handshake.psk = mbedtls_calloc(1, psk_len)) == NULL
	{
		return -0x7F00;
	}
	ssl.handshake.psk_len = psk_len;
	memcpy(ssl.handshake.psk, psk, ssl.handshake.psk_len);
	return 0;
}

pub fn mbedtls_ssl_conf_psk_cb(mbedtls_ssl_config * conf, i32 (*f_psk)(void *, mbedtls_ssl_context *, const u8 *, usize), void * p_psk)
{
	conf.f_psk = f_psk;
	conf.p_psk = p_psk;
}

pub fn mbedtls_ssl_conf_dh_param(mbedtls_ssl_config * conf, const i8 * dhm_P, const i8 * dhm_G) -> i32
{
	i32 ret;
	if (ret = mbedtls_mpi_read_string(&conf.dhm_P, 16, dhm_P)) != 0 || (ret = mbedtls_mpi_read_string(&conf.dhm_G, 16, dhm_G)) != 0
	{
		mbedtls_mpi_free(&conf.dhm_P);
		mbedtls_mpi_free(&conf.dhm_G);
		return ret;
	}
	return 0;
}

pub fn mbedtls_ssl_conf_dh_param_ctx(mbedtls_ssl_config * conf, mbedtls_dhm_context * dhm_ctx) -> i32
{
	i32 ret;
	if (ret = mbedtls_mpi_copy(&conf.dhm_P, &dhm_ctx.P)) != 0 || (ret = mbedtls_mpi_copy(&conf.dhm_G, &dhm_ctx.G)) != 0
	{
		mbedtls_mpi_free(&conf.dhm_P);
		mbedtls_mpi_free(&conf.dhm_G);
		return ret;
	}
	return 0;
}

pub fn mbedtls_ssl_conf_dhm_min_bitlen(mbedtls_ssl_config * conf, u32 bitlen)
{
	conf.dhm_min_bitlen = bitlen;
}

pub fn mbedtls_ssl_conf_sig_hashes(mbedtls_ssl_config * conf, const i32 * hashes)
{
	conf.sig_hashes = hashes;
}

pub fn mbedtls_ssl_conf_curves(mbedtls_ssl_config * conf, const mbedtls_ecp_group_id * curve_list)
{
	conf.curve_list = curve_list;
}

pub fn mbedtls_ssl_set_hostname(mbedtls_ssl_context * ssl, const i8 * hostname) -> i32
{
	usize hostname_len;
	if hostname == NULL
	{
		return -0x7100;
	}
	hostname_len = strlen(hostname);
	if hostname_len + 1 == 0
	{
		return -0x7100;
	}
	if hostname_len > 255
	{
		return -0x7100;
	}
	ssl.hostname = mbedtls_calloc(1, hostname_len + 1);
	if ssl.hostname == NULL
	{
		return -0x7F00;
	}
	memcpy(ssl.hostname, hostname, hostname_len);
	ssl.hostname[hostname_len] = '\0';
	return 0;
}

pub fn mbedtls_ssl_conf_sni(mbedtls_ssl_config * conf, i32 (*f_sni)(void *, mbedtls_ssl_context *, const u8 *, usize), void * p_sni)
{
	conf.f_sni = f_sni;
	conf.p_sni = p_sni;
}

pub fn mbedtls_ssl_conf_alpn_protocols(mbedtls_ssl_config * conf, const i8 ** protos) -> i32
{
	usize cur_len, tot_len;
	const i8 ** p;
	tot_len = 0;
	for (p = protos; *p != NULL; p++)
	{
		cur_len = strlen(*p);
		tot_len += cur_len;
		if cur_len == 0 || cur_len > 255 || tot_len > 65535
		{
			return -0x7100;
		}
	}
	conf.alpn_list = protos;
	return 0;
}

pub fn i8 * mbedtls_ssl_get_alpn_protocol(const mbedtls_ssl_context * ssl) -> const
{
	return ssl.alpn_chosen;
}

pub fn mbedtls_ssl_conf_max_version(mbedtls_ssl_config * conf, i32 major, i32 minor)
{
	conf.max_major_ver = major;
	conf.max_minor_ver = minor;
}

pub fn mbedtls_ssl_conf_min_version(mbedtls_ssl_config * conf, i32 major, i32 minor)
{
	conf.min_major_ver = major;
	conf.min_minor_ver = minor;
}

pub fn mbedtls_ssl_conf_encrypt_then_mac(mbedtls_ssl_config * conf, i8 etm)
{
	conf.encrypt_then_mac = etm;
}

pub fn mbedtls_ssl_conf_extended_master_secret(mbedtls_ssl_config * conf, i8 ems)
{
	conf.extended_ms = ems;
}

pub fn mbedtls_ssl_conf_max_frag_len(mbedtls_ssl_config * conf, u8 mfl_code) -> i32
{
	if mfl_code >= 5 || mfl_code_to_length[mfl_code] > 16384
	{
		return -0x7100;
	}
	conf.mfl_code = mfl_code;
	return 0;
}

pub fn mbedtls_ssl_conf_legacy_renegotiation(mbedtls_ssl_config * conf, i32 allow_legacy)
{
	conf.allow_legacy_renegotiation = allow_legacy;
}

pub fn mbedtls_ssl_conf_session_tickets(mbedtls_ssl_config * conf, i32 use_tickets)
{
	conf.session_tickets = use_tickets;
}

pub fn mbedtls_ssl_conf_session_tickets_cb(mbedtls_ssl_config * conf, mbedtls_ssl_ticket_write_t * f_ticket_write, mbedtls_ssl_ticket_parse_t * f_ticket_parse, void * p_ticket)
{
	conf.f_ticket_write = f_ticket_write;
	conf.f_ticket_parse = f_ticket_parse;
	conf.p_ticket = p_ticket;
}

pub fn mbedtls_ssl_get_bytes_avail(const mbedtls_ssl_context * ssl) -> usize
{
	return ssl.in_offt == NULL ? 0 : ssl.in_msglen;
}

pub fn mbedtls_ssl_get_verify_result(const mbedtls_ssl_context * ssl) -> u32
{
	if ssl.session != NULL
	{
		return ssl.session.verify_result;
	}
	if ssl.session_negotiate != NULL
	{
		return ssl.session_negotiate.verify_result;
	}
	return 0xFFFFFFFF;
}

pub fn i8 * mbedtls_ssl_get_ciphersuite(const mbedtls_ssl_context * ssl) -> const
{
	if ssl == NULL || ssl.session == NULL
	{
		return NULL;
	}
	return mbedtls_ssl_get_ciphersuite_name(ssl.session.ciphersuite);
}

pub fn i8 * mbedtls_ssl_get_version(const mbedtls_ssl_context * ssl) -> const
{
	if ssl.conf.transport == 1
	{
		switch (ssl.minor_ver)
		{
			case 2:
			return "DTLSv1.0";
			case 3:
			return "DTLSv1.2";
		default:
			return "unknown (DTLS)";
		}
	}
	switch (ssl.minor_ver)
	{
		case 0:
		return "SSLv3.0";
		case 1:
		return "TLSv1.0";
		case 2:
		return "TLSv1.1";
		case 3:
		return "TLSv1.2";
	default:
		return "unknown";
	}
}

pub fn mbedtls_ssl_get_record_expansion(const mbedtls_ssl_context * ssl) -> i32
{
	usize transform_expansion;
	const mbedtls_ssl_transform * transform = ssl.transform_out;
	if transform == NULL
	{
		return (int) mbedtls_ssl_hdr_len(ssl);
	}
	switch (mbedtls_cipher_get_cipher_mode(&transform.cipher_ctx_enc))
	{
		case MBEDTLS_MODE_GCM:
		case MBEDTLS_MODE_CCM:
		case MBEDTLS_MODE_STREAM:
		transform_expansion = transform.minlen;
		break;

		case MBEDTLS_MODE_CBC:
		transform_expansion = transform.maclen + mbedtls_cipher_get_block_size(&transform.cipher_ctx_enc);
		break;

	default:
		do
		{
		}
		while (0);
		return -0x6C00;
	}
	return (int) (mbedtls_ssl_hdr_len(ssl) + transform_expansion);
}

pub fn mbedtls_ssl_get_max_frag_len(const mbedtls_ssl_context * ssl) -> usize
{
	usize max_len;
	max_len = mfl_code_to_length[ssl.conf.mfl_code];
	if ssl.session_out != NULL && mfl_code_to_length[ssl.session_out.mfl_code] < max_len
	{
		max_len = mfl_code_to_length[ssl.session_out.mfl_code];
	}
	return max_len;
}

pub fn mbedtls_x509_crt * mbedtls_ssl_get_peer_cert(const mbedtls_ssl_context * ssl) -> const
{
	if ssl == NULL || ssl.session == NULL
	{
		return NULL;
	}
	return ssl.session.peer_cert;
}

pub fn mbedtls_ssl_get_session(const mbedtls_ssl_context * ssl, mbedtls_ssl_session * dst) -> i32
{
	if ssl == NULL || dst == NULL || ssl.session == NULL || ssl.conf.endpoi32 != 0
	{
		return -0x7100;
	}
	return ssl_session_copy(dst, ssl.session);
}

pub fn mbedtls_ssl_handshake_step(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = -0x7080;
	if ssl == NULL || ssl.conf == NULL
	{
		return -0x7100;
	}
	if ssl.conf.endpoi32 == 0
	{
		ret = mbedtls_ssl_handshake_client_step(ssl);
	}
	if ssl.conf.endpoi32 == 1
	{
		ret = mbedtls_ssl_handshake_server_step(ssl);
	}
	return ret;
}

pub fn mbedtls_ssl_handshake(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret = 0;
	if ssl == NULL || ssl.conf == NULL
	{
		return -0x7100;
	}
	do
	{
	}
	while (0);
	while (ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER)
	{
		ret = mbedtls_ssl_handshake_step(ssl);
		if ret != 0
		{
			break;

		}
	}
	do
	{
	}
	while (0);
	return ret;
}

pub fn mbedtls_ssl_read(mbedtls_ssl_context * ssl, u8 * buf, usize len) -> i32
{
	i32 ret, record_read = 0;
	usize n;
	if ssl == NULL || ssl.conf == NULL
	{
		return -0x7100;
	}
	do
	{
	}
	while (0);
	if ssl.conf.transport == 1
	{
		if (ret = mbedtls_ssl_flush_output(ssl)) != 0
		{
			return ret;
		}
		if ssl.handshake != NULL && ssl.handshake.retransmit_state == 1
		{
			if (ret = mbedtls_ssl_resend(ssl)) != 0
			{
				return ret;
			}
		}
	}
	if ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER
	{
		ret = mbedtls_ssl_handshake(ssl);
		if ret == -0x6B00
		{
			record_read = 1;
		}
		else
			if ret != 0
			{
				do
				{
				}
				while (0);
				return ret;
			}
	}
	if ssl.in_offt == NULL
	{
		if ssl.f_get_timer != NULL && ssl.f_get_timer(ssl.p_timer) == -1
		{
			ssl_set_timer(ssl, ssl.conf.read_timeout);
		}
		if !record_read
		{
			if (ret = mbedtls_ssl_read_record(ssl)) != 0
			{
				if ret == -0x7280
				{
					return 0;
				}
				do
				{
				}
				while (0);
				return ret;
			}
		}
		if ssl.in_msglen == 0 && ssl.in_msgtype == 23
		{
			if (ret = mbedtls_ssl_read_record(ssl)) != 0
			{
				if ret == -0x7280
				{
					return 0;
				}
				do
				{
				}
				while (0);
				return ret;
			}
		}
		if ssl.in_msgtype == 21
		{
			do
			{
			}
			while (0);
			return -0x6900;
		}
		if ssl.in_msgtype != 23
		{
			do
			{
			}
			while (0);
			return -0x7700;
		}
		ssl.in_offt = ssl.in_msg;
		if ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER
		{
			ssl_set_timer(ssl, 0);
		}
	}
	n = (len < ssl.in_msglen) ? len : ssl.in_msglen;
	memcpy(buf, ssl.in_offt, n);
	ssl.in_msglen -= n;
	if ssl.in_msglen == 0
	{
		ssl.in_offt = NULL;
	}
	else
	{
		ssl.in_offt += n;
	}
	do
	{
	}
	while (0);
	return (int) n;
}

fn ssl_write_real(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	i32 ret;
	usize max_len = mbedtls_ssl_get_max_frag_len(ssl);
	if len > max_len
	{
		if ssl.conf.transport == 1
		{
			do
			{
			}
			while (0);
			return -0x7100;
		}
		else
		{
			len = max_len;
		}
	}
	if ssl.out_left != 0
	{
		if (ret = mbedtls_ssl_flush_output(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	else
	{
		ssl.out_msglen = len;
		ssl.out_msgtype = 23;
		memcpy(ssl.out_msg, buf, len);
		if (ret = mbedtls_ssl_write_record(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	return (int) len;
}

pub fn mbedtls_ssl_write(mbedtls_ssl_context * ssl, const u8 * buf, usize len) -> i32
{
	i32 ret;
	do
	{
	}
	while (0);
	if ssl == NULL || ssl.conf == NULL
	{
		return -0x7100;
	}
	if ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER
	{
		if (ret = mbedtls_ssl_handshake(ssl)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	ret = ssl_write_real(ssl, buf, len);
	do
	{
	}
	while (0);
	return ret;
}

pub fn mbedtls_ssl_close_notify(mbedtls_ssl_context * ssl) -> i32
{
	i32 ret;
	if ssl == NULL || ssl.conf == NULL
	{
		return -0x7100;
	}
	do
	{
	}
	while (0);
	if ssl.out_left != 0
	{
		return mbedtls_ssl_flush_output(ssl);
	}
	if ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER
	{
		if (ret = mbedtls_ssl_send_alert_message(ssl, 1, 0)) != 0
		{
			do
			{
			}
			while (0);
			return ret;
		}
	}
	do
	{
	}
	while (0);
	return 0;
}

pub fn mbedtls_ssl_transform_free(mbedtls_ssl_transform * transform)
{
	if transform == NULL
	{
		return;
	}
	mbedtls_cipher_free(&transform.cipher_ctx_enc);
	mbedtls_cipher_free(&transform.cipher_ctx_dec);
	mbedtls_md_free(&transform.md_ctx_enc);
	mbedtls_md_free(&transform.md_ctx_dec);
	zeroize(transform, sizeof(mbedtls_ssl_transform));
}

fn ssl_key_cert_free(mbedtls_ssl_key_cert * key_cert)
{
	mbedtls_ssl_key_cert *cur = key_cert, *next;
	while (cur != NULL)
	{
		next = cur.next;
		mbedtls_free(cur);
		cur = next;
	}
}

pub fn mbedtls_ssl_handshake_free(mbedtls_ssl_handshake_params * handshake)
{
	if handshake == NULL
	{
		return;
	}
	mbedtls_sha256_free(&handshake.fin_sha256);
	mbedtls_sha512_free(&handshake.fin_sha512);
	mbedtls_dhm_free(&handshake.dhm_ctx);
	mbedtls_ecdh_free(&handshake.ecdh_ctx);
	mbedtls_free((void *) handshake.curves);
	if handshake.psk != NULL
	{
		zeroize(handshake.psk, handshake.psk_len);
		mbedtls_free(handshake.psk);
	}
	if handshake.sni_key_cert != NULL
	{
		mbedtls_ssl_key_cert *cur = handshake.sni_key_cert, *next;
		while (cur != NULL)
		{
			next = cur.next;
			mbedtls_free(cur);
			cur = next;
		}
	}
	mbedtls_free(handshake.verify_cookie);
	mbedtls_free(handshake.hs_msg);
	ssl_flight_free(handshake.flight);
	zeroize(handshake, sizeof(mbedtls_ssl_handshake_params));
}

pub fn mbedtls_ssl_session_free(mbedtls_ssl_session * session)
{
	if session == NULL
	{
		return;
	}
	if session.peer_cert != NULL
	{
		mbedtls_x509_crt_free(session.peer_cert);
		mbedtls_free(session.peer_cert);
	}
	mbedtls_free(session.ticket);
	zeroize(session, sizeof(mbedtls_ssl_session));
}

pub fn mbedtls_ssl_free(mbedtls_ssl_context * ssl)
{
	if ssl == NULL
	{
		return;
	}
	do
	{
	}
	while (0);
	if ssl.out_buf != NULL
	{
		zeroize(ssl.out_buf, (16384 + 0 + 29 + 48 + 256));
		mbedtls_free(ssl.out_buf);
	}
	if ssl.in_buf != NULL
	{
		zeroize(ssl.in_buf, (16384 + 0 + 29 + 48 + 256));
		mbedtls_free(ssl.in_buf);
	}
	if ssl.transform
	{
		mbedtls_ssl_transform_free(ssl.transform);
		mbedtls_free(ssl.transform);
	}
	if ssl.handshake
	{
		mbedtls_ssl_handshake_free(ssl.handshake);
		mbedtls_ssl_transform_free(ssl.transform_negotiate);
		mbedtls_ssl_session_free(ssl.session_negotiate);
		mbedtls_free(ssl.handshake);
		mbedtls_free(ssl.transform_negotiate);
		mbedtls_free(ssl.session_negotiate);
	}
	if ssl.session
	{
		mbedtls_ssl_session_free(ssl.session);
		mbedtls_free(ssl.session);
	}
	if ssl.hostname != NULL
	{
		zeroize(ssl.hostname, strlen(ssl.hostname));
		mbedtls_free(ssl.hostname);
	}
	if mbedtls_ssl_hw_record_finish != NULL
	{
		do
		{
		}
		while (0);
		mbedtls_ssl_hw_record_finish(ssl);
	}
	mbedtls_free(ssl.cli_id);
	do
	{
	}
	while (0);
	zeroize(ssl, sizeof(mbedtls_ssl_context));
}

pub fn mbedtls_ssl_config_init(mbedtls_ssl_config * conf)
{
	memset(conf, 0, sizeof(mbedtls_ssl_config));
}

static i32 ssl_preset_default_hashes[] = {MBEDTLS_MD_SHA512, MBEDTLS_MD_SHA384, MBEDTLS_MD_SHA256, MBEDTLS_MD_SHA224, MBEDTLS_MD_SHA1, MBEDTLS_MD_NONE};
static i32 ssl_preset_suiteb_ciphersuites[] = {0xC02B, 0xC02C, 0};
static i32 ssl_preset_suiteb_hashes[] = {MBEDTLS_MD_SHA256, MBEDTLS_MD_SHA384, MBEDTLS_MD_NONE};
static mbedtls_ecp_group_id ssl_preset_suiteb_curves[] = {MBEDTLS_ECP_DP_SECP256R1, MBEDTLS_ECP_DP_SECP384R1, MBEDTLS_ECP_DP_NONE};
pub fn mbedtls_ssl_config_defaults(mbedtls_ssl_config * conf, i32 endpoint, i32 transport, i32 preset) -> i32
{
	i32 ret;
	mbedtls_ssl_conf_endpoint(conf, endpoint);
	mbedtls_ssl_conf_transport(conf, transport);
	if endpoi32 == 0
	{
		conf.authmode = 2;
		conf.session_tickets = 1;
	}
	conf.encrypt_then_mac = 1;
	conf.extended_ms = 1;
	conf.f_cookie_write = ssl_cookie_write_dummy;
	conf.f_cookie_check = ssl_cookie_check_dummy;
	conf.anti_replay = 1;
	conf.hs_timeout_min = 1000;
	conf.hs_timeout_max = 60000;
	if endpoi32 == 1
	{
		if ((ret = mbedtls_ssl_conf_dh_param(conf, "AD107E1E9123A9D0D660FAA79559C51FA20D64E5683B9FD1"
											 "B54B1597B61D0A75E6FA141DF95A56DBAF9A3C407BA1DF15"
											 "EB3D688A309C180E1DE6B85A1274A0A66D3F8152AD6AC212"
											 "9037C9EDEFDA4DF8D91E8FEF55B7394B7AD5B7D0B6C12207"
											 "C9F98D11ED34DBF6C6BA0B2C8BBC27BE6A00E0A0B9C49708"
											 "B3BF8A317091883681286130BC8985DB1602E714415D9330"
											 "278273C7DE31EFDC7310F7121FD5A07415987D9ADC0A486D"
											 "CDF93ACC44328387315D75E198C641A480CD86A1B9E587E8"
											 "BE60E69CC928B2B9C52172E413042E9B23F10B0E16E79763"
											 "C9B53DCF4BA80A29E3FB73C16B8E75B97EF363E2FFA31F71"
											 "CF9DE5384E71B81C0AC4DFFE0C10E64F",
											 "AC4032EF4F2D9AE39DF30B5C8FFDAC506CDEBE7B89998CAF"
											 "74866A08CFE4FFE3A6824A4E10B9A6F0DD921F01A70C4AFA"
											 "AB739D7700C29F52C57DB17C620A8652BE5E9001A8D66AD7"
											 "C17669101999024AF4D027275AC1348BB8A762D0521BC98A"
											 "E247150422EA1ED409939D54DA7460CDB5F6C6B250717CBE"
											 "F180EB34118E98D119529A45D6F834566E3025E316A330EF"
											 "BB77A86F0C1AB15B051AE3D428C8F8ACB70A8137150B8EEB"
											 "10E183EDD19963DDD9E263E4770589EF6AA21E7F5F2FF381"
											 "B539CCE3409D13CD566AFBB48D6C019181E1BCFE94B30269"
											 "EDFE72FE9B6AA4BD7B5A0F1C71CFFF4C19C418E1F6EC0179"
											 "81BC087F2A7065B384B890D3191F2BFA")) != 0)
		{
			return ret;
		}
	}
	switch (preset)
	{
		case 2:
		conf.min_major_ver = 3;
		conf.min_minor_ver = 3;
		conf.max_major_ver = 3;
		conf.max_minor_ver = 3;
		conf.ciphersuite_list[0] = conf.ciphersuite_list[1] = conf.ciphersuite_list[2] = conf.ciphersuite_list[3] = ssl_preset_suiteb_ciphersuites;
		conf.cert_profile = &mbedtls_x509_crt_profile_suiteb;
		conf.sig_hashes = ssl_preset_suiteb_hashes;
		conf.curve_list = ssl_preset_suiteb_curves;
		break;

	default:
		conf.min_major_ver = 3;
		conf.min_minor_ver = 1;
		conf.max_major_ver = 3;
		conf.max_minor_ver = 3;
		if transport == 1
		{
			conf.min_minor_ver = 2;
		}
		conf.ciphersuite_list[0] = conf.ciphersuite_list[1] = conf.ciphersuite_list[2] = conf.ciphersuite_list[3] = mbedtls_ssl_list_ciphersuites();
		conf.cert_profile = &mbedtls_x509_crt_profile_default;
		conf.sig_hashes = ssl_preset_default_hashes;
		conf.curve_list = mbedtls_ecp_grp_id_list();
		conf.dhm_min_bitlen = 1024;
	}
	return 0;
}

pub fn mbedtls_ssl_config_free(mbedtls_ssl_config * conf)
{
	mbedtls_mpi_free(&conf.dhm_P);
	mbedtls_mpi_free(&conf.dhm_G);
	if conf.psk != NULL
	{
		zeroize(conf.psk, conf.psk_len);
		zeroize(conf.psk_identity, conf.psk_identity_len);
		mbedtls_free(conf.psk);
		mbedtls_free(conf.psk_identity);
		conf.psk_len = 0;
		conf.psk_identity_len = 0;
	}
	ssl_key_cert_free(conf.key_cert);
	zeroize(conf, sizeof(mbedtls_ssl_config));
}

pub fn mbedtls_ssl_sig_from_pk(mbedtls_pk_context * pk) -> u8
{
	if mbedtls_pk_can_do(pk, MBEDTLS_PK_RSA)
	{
		return 1;
	}
	if mbedtls_pk_can_do(pk, MBEDTLS_PK_ECDSA)
	{
		return 3;
	}
	return 0;
}

pub fn mbedtls_ssl_pk_alg_from_sig(u8 sig) -> mbedtls_pk_type_t
{
	switch (sig)
	{
		case 1:
		return MBEDTLS_PK_RSA;
		case 3:
		return MBEDTLS_PK_ECDSA;
	default:
		return MBEDTLS_PK_NONE;
	}
}

pub fn mbedtls_ssl_md_alg_from_hash(u8 hash) -> mbedtls_md_type_t
{
	switch (hash)
	{
		case 1:
		return MBEDTLS_MD_MD5;
		case 2:
		return MBEDTLS_MD_SHA1;
		case 3:
		return MBEDTLS_MD_SHA224;
		case 4:
		return MBEDTLS_MD_SHA256;
		case 5:
		return MBEDTLS_MD_SHA384;
		case 6:
		return MBEDTLS_MD_SHA512;
	default:
		return MBEDTLS_MD_NONE;
	}
}

pub fn mbedtls_ssl_hash_from_md_alg(i32 md) -> u8
{
	switch (md)
	{
		case MBEDTLS_MD_MD5:
		return 1;
		case MBEDTLS_MD_SHA1:
		return 2;
		case MBEDTLS_MD_SHA224:
		return 3;
		case MBEDTLS_MD_SHA256:
		return 4;
		case MBEDTLS_MD_SHA384:
		return 5;
		case MBEDTLS_MD_SHA512:
		return 6;
	default:
		return 0;
	}
}

pub fn mbedtls_ssl_check_curve(const mbedtls_ssl_context * ssl, mbedtls_ecp_group_id grp_id) -> i32
{
	const mbedtls_ecp_group_id * gid;
	if ssl.conf.curve_list == NULL
	{
		return -1;
	}
	for (gid = ssl.conf.curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++)
		if *gid == grp_id
		{
			return 0;
		}
	return -1;
}

pub fn mbedtls_ssl_check_sig_hash(const mbedtls_ssl_context * ssl, mbedtls_md_type_t md) -> i32
{
	const i32 * cur;
	if ssl.conf.sig_hashes == NULL
	{
		return -1;
	}
	for (cur = ssl.conf.sig_hashes; *cur != MBEDTLS_MD_NONE; cur++)
		if *cur == (int) md
		{
			return 0;
		}
	return -1;
}

pub fn mbedtls_ssl_check_cert_usage(const mbedtls_x509_crt * cert, const mbedtls_ssl_ciphersuite_t * ciphersuite, i32 cert_endpoint, u32 * flags) -> i32
{
	i32 ret = 0;
	i32 usage = 0;
	const i8 * ext_oid;
	usize ext_len;
	if cert_endpoi32 == 1
	{
		switch (ciphersuite.key_exchange)
		{
			case MBEDTLS_KEY_EXCHANGE_RSA:
			case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
			usage = (0x20);
			break;

			case MBEDTLS_KEY_EXCHANGE_DHE_RSA:
			case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
			case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
			usage = (0x80);
			break;

			case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
			case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
			usage = (0x08);
			break;

			case MBEDTLS_KEY_EXCHANGE_NONE:
			case MBEDTLS_KEY_EXCHANGE_PSK:
			case MBEDTLS_KEY_EXCHANGE_DHE_PSK:
			case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
			case MBEDTLS_KEY_EXCHANGE_ECJPAKE:
			usage = 0;
		}
	}
	else
	{
		usage = (0x80);
	}
	if mbedtls_x509_crt_check_key_usage(cert, usage) != 0
	{
		*flags |= 0x0800;
		ret = -1;
	}
	if cert_endpoi32 == 1
	{
		ext_oid = "\x2b"
				  "\x06"
				  "\x01\x05\x05\x07"
				  "\x03"
				  "\x01";
		ext_len = (sizeof("\x2b"
						  "\x06"
						  "\x01\x05\x05\x07"
						  "\x03"
						  "\x01") -
				   1);
	}
	else
	{
		ext_oid = "\x2b"
				  "\x06"
				  "\x01\x05\x05\x07"
				  "\x03"
				  "\x02";
		ext_len = (sizeof("\x2b"
						  "\x06"
						  "\x01\x05\x05\x07"
						  "\x03"
						  "\x02") -
				   1);
	}
	if mbedtls_x509_crt_check_extended_key_usage(cert, ext_oid, ext_len) != 0
	{
		*flags |= 0x1000;
		ret = -1;
	}
	return ret;
}

pub fn mbedtls_ssl_write_version(i32 major, i32 minor, i32 transport, u8 ver[2])
{
	if transport == 1
	{
		if minor == 2
		{
			--minor;
		}
		ver[0] = (i8) (255 - (major - 2));
		ver[1] = (i8) (255 - (minor - 1));
	}
	else
	{
		ver[0] = (i8) major;
		ver[1] = (i8) minor;
	}
}

pub fn mbedtls_ssl_read_version(i32 * major, i32 * minor, i32 transport, const u8 ver[2])
{
	if transport == 1
	{
		*major = 255 - ver[0] + 2;
		*minor = 255 - ver[1] + 1;
		if *minor == 1
		{
			++*minor;
		}
	}
	else
	{
		*major = ver[0];
		*minor = ver[1];
	}
}

fn threading_mutex_init_pthread(mbedtls_threading_mutex_t * mutex)
{
	if mutex == NULL
	{
		return;
	}
	mutex.is_valid = pthread_mutex_init(&mutex.mutex, NULL) == 0;
}

fn threading_mutex_free_pthread(mbedtls_threading_mutex_t * mutex)
{
	if mutex == NULL
	{
		return;
	}
	(void) pthread_mutex_destroy(&mutex.mutex);
}

fn threading_mutex_lock_pthread(mbedtls_threading_mutex_t * mutex) -> i32
{
	if mutex == NULL || !mutex.is_valid
	{
		return -0x001C;
	}
	if pthread_mutex_lock(&mutex.mutex) != 0
	{
		return -0x001E;
	}
	return 0;
}

fn threading_mutex_unlock_pthread(mbedtls_threading_mutex_t * mutex) -> i32
{
	if mutex == NULL || !mutex.is_valid
	{
		return -0x001C;
	}
	if pthread_mutex_unlock(&mutex.mutex) != 0
	{
		return -0x001E;
	}
	return 0;
}

void (*mbedtls_mutex_init)(mbedtls_threading_mutex_t *) = threading_mutex_init_pthread;
void (*mbedtls_mutex_free)(mbedtls_threading_mutex_t *) = threading_mutex_free_pthread;
i32 (*mbedtls_mutex_lock)(mbedtls_threading_mutex_t *) = threading_mutex_lock_pthread;
i32 (*mbedtls_mutex_unlock)(mbedtls_threading_mutex_t *) = threading_mutex_unlock_pthread;
mbedtls_threading_mutex_t mbedtls_threading_readdir_mutex = {PTHREAD_MUTEX_INITIALIZER, 1};
mbedtls_threading_mutex_t mbedtls_threading_gmtime_mutex = {PTHREAD_MUTEX_INITIALIZER, 1};
struct _hr_time
{
	struct timeval start;
};
pub fn mbedtls_timing_hardclock() -> u32
{
	u32 lo, hi;
	__asm volatile("rdtsc" : "=a"(lo), "=d"(hi));
	return lo | (hi << 32);
}

volatile i32 mbedtls_timing_alarmed = 0;
pub fn mbedtls_timing_get_timer(struct mbedtls_timing_hr_time * val, i32 reset) -> u32
{
	u32 delta;
	struct timeval offset;
	struct _hr_time * t = (struct _hr_time *) val;
	gettimeofday(&offset, NULL);
	if reset
	{
		t.start.tv_sec = offset.tv_sec;
		t.start.tv_usec = offset.tv_usec;
		return 0;
	}
	delta = (offset.tv_sec - t.start.tv_sec) * 1000 + (offset.tv_usec - t.start.tv_usec) / 1000;
	return delta;
}

fn sighandler(i32 signum)
{
	mbedtls_timing_alarmed = 1;
	signal(signum, sighandler);
}

pub fn mbedtls_set_alarm(i32 seconds)
{
	mbedtls_timing_alarmed = 0;
	signal(SIGALRM, sighandler);
	alarm(seconds);
}

pub fn mbedtls_timing_set_delay(void * data, u32 int_ms, u32 fin_ms)
{
	mbedtls_timing_delay_context * ctx = (mbedtls_timing_delay_context *) data;
	ctx.int_ms = int_ms;
	ctx.fin_ms = fin_ms;
	if fin_ms != 0
	{
		(void) mbedtls_timing_get_timer(&ctx.timer, 1);
	}
}

pub fn mbedtls_timing_get_delay(void * data) -> i32
{
	mbedtls_timing_delay_context * ctx = (mbedtls_timing_delay_context *) data;
	u32 elapsed_ms;
	if ctx.fin_ms == 0
	{
		return -1;
	}
	elapsed_ms = mbedtls_timing_get_timer(&ctx.timer, 0);
	if elapsed_ms >= ctx.fin_ms
	{
		return 2;
	}
	if elapsed_ms >= ctx.int_ms
	{
		return 1;
	}
	return 0;
}

fn busy_msleep(u32 msec)
{
	struct mbedtls_timing_hr_time hires;
	u32 i = 0;
	volatile u32 j;
	(void) mbedtls_timing_get_timer(&hires, 1);
	while (mbedtls_timing_get_timer(&hires, 0) < msec)
	{
		i++;
	}
	j = i;
	(void) j;
}

pub fn mbedtls_timing_self_test(i32 verbose) -> i32
{
	u32 cycles, ratio;
	u32 millisecs, secs;
	i32 hardfail;
	struct mbedtls_timing_hr_time hires;
	u32 a, b;
	mbedtls_timing_delay_context ctx;
	if verbose != 0
	{
		printf("  TIMING tests note: will take some time!\n");
	}
	if verbose != 0
	{
		printf("  TIMING test #1 (set_alarm / get_timer): ");
	}
	for (secs = 1; secs <= 3; secs++)
	{
		(void) mbedtls_timing_get_timer(&hires, 1);
		mbedtls_set_alarm((int) secs);
		while (!mbedtls_timing_alarmed)
			;
		millisecs = mbedtls_timing_get_timer(&hires, 0);
		if millisecs < 800 * secs || millisecs > 1200 * secs + 300
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			return 1;
		}
	}
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  TIMING test #2 (set/get_delay        ): ");
	}
	for (a = 200; a <= 400; a += 200)
	{
		for (b = 200; b <= 400; b += 200)
		{
			mbedtls_timing_set_delay(&ctx, a, a + b);
			busy_msleep(a - a / 8);
			if mbedtls_timing_get_delay(&ctx) != 0
				do
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
				while (0);
			busy_msleep(a / 4);
			if mbedtls_timing_get_delay(&ctx) != 1
				do
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
				while (0);
			busy_msleep(b - a / 8 - b / 8);
			if mbedtls_timing_get_delay(&ctx) != 1
				do
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
				while (0);
			busy_msleep(b / 4);
			if mbedtls_timing_get_delay(&ctx) != 2
				do
				{
					if verbose != 0
					{
						printf("failed\n");
					}
					return 1;
				}
				while (0);
		}
	}
	mbedtls_timing_set_delay(&ctx, 0, 0);
	busy_msleep(200);
	if mbedtls_timing_get_delay(&ctx) != -1
		do
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			return 1;
		}
		while (0);
	if verbose != 0
	{
		printf("passed\n");
	}
	if verbose != 0
	{
		printf("  TIMING test #3 (hardclock / get_timer): ");
	}
	hardfail = 0;
hard_test:
	if hardfail > 1
	{
		if verbose != 0
		{
			printf("failed (ignored)\n");
		}
		goto hard_test_done;
	}
	millisecs = 1;
	cycles = mbedtls_timing_hardclock();
	busy_msleep(millisecs);
	cycles = mbedtls_timing_hardclock() - cycles;
	ratio = cycles / millisecs;
	for (millisecs = 2; millisecs <= 4; millisecs++)
	{
		cycles = mbedtls_timing_hardclock();
		busy_msleep(millisecs);
		cycles = mbedtls_timing_hardclock() - cycles;
		if cycles / millisecs < ratio - ratio / 5 || cycles / millisecs > ratio + ratio / 5
		{
			hardfail++;
			goto hard_test;
		}
	}
	if verbose != 0
	{
		printf("passed\n");
	}
hard_test_done:
	if verbose != 0
	{
		printf("\n");
	}
	return 0;
}

pub fn mbedtls_version_get_number() -> u32
{
	return 0x02030000;
}

pub fn mbedtls_version_get_string(i8 * string)
{
	memcpy(string, "2.3.0", sizeof("2.3.0"));
}

pub fn mbedtls_version_get_string_full(i8 * string)
{
	memcpy(string, "mbed TLS 2.3.0", sizeof("mbed TLS 2.3.0"));
}

static const i8 * features[] = {"MBEDTLS_HAVE_ASM", "MBEDTLS_HAVE_SSE2", "MBEDTLS_HAVE_TIME", "MBEDTLS_HAVE_TIME_DATE", "MBEDTLS_PLATFORM_MEMORY", "MBEDTLS_DEPRECATED_REMOVED", "MBEDTLS_CIPHER_MODE_CBC", "MBEDTLS_CIPHER_MODE_CFB", "MBEDTLS_CIPHER_MODE_CTR", "MBEDTLS_CIPHER_PADDING_PKCS7", "MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS", "MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN", "MBEDTLS_CIPHER_PADDING_ZEROS", "MBEDTLS_REMOVE_ARC4_CIPHERSUITES", "MBEDTLS_ECP_DP_SECP192R1_ENABLED", "MBEDTLS_ECP_DP_SECP224R1_ENABLED", "MBEDTLS_ECP_DP_SECP256R1_ENABLED", "MBEDTLS_ECP_DP_SECP384R1_ENABLED", "MBEDTLS_ECP_DP_SECP521R1_ENABLED", "MBEDTLS_ECP_DP_SECP192K1_ENABLED", "MBEDTLS_ECP_DP_SECP224K1_ENABLED", "MBEDTLS_ECP_DP_SECP256K1_ENABLED", "MBEDTLS_ECP_DP_BP256R1_ENABLED", "MBEDTLS_ECP_DP_BP384R1_ENABLED", "MBEDTLS_ECP_DP_BP512R1_ENABLED", "MBEDTLS_ECP_DP_CURVE25519_ENABLED", "MBEDTLS_ECP_NIST_OPTIM", "MBEDTLS_ECDSA_DETERMINISTIC", "MBEDTLS_KEY_EXCHANGE_PSK_ENABLED", "MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED", "MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED", "MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED", "MBEDTLS_KEY_EXCHANGE_RSA_ENABLED", "MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED", "MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED", "MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED", "MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED", "MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED", "MBEDTLS_PK_PARSE_EC_EXTENDED", "MBEDTLS_ERROR_STRERROR_DUMMY", "MBEDTLS_GENPRIME", "MBEDTLS_FS_IO", "MBEDTLS_PK_RSA_ALT_SUPPORT", "MBEDTLS_PKCS1_V15", "MBEDTLS_PKCS1_V21", "MBEDTLS_SELF_TEST", "MBEDTLS_SSL_ENCRYPT_THEN_MAC", "MBEDTLS_SSL_EXTENDED_MASTER_SECRET", "MBEDTLS_SSL_HW_RECORD_ACCEL", "MBEDTLS_SSL_MAX_FRAGMENT_LENGTH", "MBEDTLS_SSL_PROTO_TLS1_2", "MBEDTLS_SSL_PROTO_DTLS", "MBEDTLS_SSL_ALPN", "MBEDTLS_SSL_DTLS_ANTI_REPLAY", "MBEDTLS_SSL_DTLS_HELLO_VERIFY", "MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE", "MBEDTLS_SSL_DTLS_BADMAC_LIMIT", "MBEDTLS_SSL_SESSION_TICKETS", "MBEDTLS_SSL_SERVER_NAME_INDICATION", "MBEDTLS_THREADING_PTHREAD", "MBEDTLS_VERSION_FEATURES", "MBEDTLS_X509_CHECK_KEY_USAGE", "MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE", "MBEDTLS_X509_RSASSA_PSS_SUPPORT", "MBEDTLS_AESNI_C", "MBEDTLS_AES_C", "MBEDTLS_ASN1_PARSE_C", "MBEDTLS_ASN1_WRITE_C", "MBEDTLS_BASE64_C", "MBEDTLS_BIGNUM_C", "MBEDTLS_BLOWFISH_C", "MBEDTLS_CAMELLIA_C", "MBEDTLS_CCM_C", "MBEDTLS_CIPHER_C", "MBEDTLS_CTR_DRBG_C", "MBEDTLS_DES_C", "MBEDTLS_DHM_C", "MBEDTLS_ECDH_C", "MBEDTLS_ECDSA_C", "MBEDTLS_ECJPAKE_C", "MBEDTLS_ECP_C", "MBEDTLS_ENTROPY_C", "MBEDTLS_ERROR_C", "MBEDTLS_GCM_C", "MBEDTLS_HMAC_DRBG_C", "MBEDTLS_MD_C", "MBEDTLS_MD5_C", "MBEDTLS_MEMORY_BUFFER_ALLOC_C", "MBEDTLS_OID_C", "MBEDTLS_PADLOCK_C", "MBEDTLS_PEM_PARSE_C", "MBEDTLS_PEM_WRITE_C", "MBEDTLS_PK_C", "MBEDTLS_PK_PARSE_C", "MBEDTLS_PK_WRITE_C", "MBEDTLS_PKCS5_C", "MBEDTLS_PKCS12_C", "MBEDTLS_PLATFORM_C", "MBEDTLS_RIPEMD160_C", "MBEDTLS_RSA_C", "MBEDTLS_SHA1_C", "MBEDTLS_SHA256_C", "MBEDTLS_SHA512_C", "MBEDTLS_SSL_CACHE_C", "MBEDTLS_SSL_COOKIE_C", "MBEDTLS_SSL_TICKET_C", "MBEDTLS_SSL_CLI_C", "MBEDTLS_SSL_SRV_C", "MBEDTLS_SSL_TLS_C", "MBEDTLS_THREADING_C", "MBEDTLS_TIMING_C", "MBEDTLS_VERSION_C", "MBEDTLS_X509_USE_C", "MBEDTLS_X509_CRT_PARSE_C", "MBEDTLS_X509_CRL_PARSE_C", "MBEDTLS_X509_CSR_PARSE_C", "MBEDTLS_X509_CREATE_C", "MBEDTLS_X509_CRT_WRITE_C", "MBEDTLS_X509_CSR_WRITE_C", "MBEDTLS_XTEA_C", NULL};
pub fn mbedtls_version_check_feature(const i8 * feature) -> i32
{
	const i8 ** idx = features;
	if *idx == NULL
	{
		return -2;
	}
	if feature == NULL
	{
		return -1;
	}
	while (*idx != NULL)
	{
		if !strcmp(*idx, feature)
		{
			return 0;
		}
		idx++;
	}
	return -1;
}

pub fn mbedtls_x509_get_serial(u8 ** p, const u8 * end, mbedtls_x509_buf * serial) -> i32
{
	i32 ret;
	if (end - *p) < 1
	{
		return -0x2280 + -0x0060;
	}
	if **p != (0x80 | 0x00 | 2) && **p != 0x02
	{
		return -0x2280 + -0x0062;
	}
	serial.tag = *(*p)++;
	if (ret = mbedtls_asn1_get_len(p, end, &serial.len)) != 0
	{
		return -0x2280 + ret;
	}
	serial.p = *p;
	*p += serial.len;
	return 0;
}

pub fn mbedtls_x509_get_alg_null(u8 ** p, const u8 * end, mbedtls_x509_buf * alg) -> i32
{
	i32 ret;
	if (ret = mbedtls_asn1_get_alg_null(p, end, alg)) != 0
	{
		return -0x2300 + ret;
	}
	return 0;
}

pub fn mbedtls_x509_get_alg(u8 ** p, const u8 * end, mbedtls_x509_buf * alg, mbedtls_x509_buf * params) -> i32
{
	i32 ret;
	if (ret = mbedtls_asn1_get_alg(p, end, alg, params)) != 0
	{
		return -0x2300 + ret;
	}
	return 0;
}

fn x509_get_hash_alg(const mbedtls_x509_buf * alg, mbedtls_md_type_t * md_alg) -> i32
{
	i32 ret;
	u8 * p;
	const u8 * end;
	mbedtls_x509_buf md_oid;
	usize len;
	if alg.tag != (0x20 | 0x10)
	{
		return -0x2300 + -0x0062;
	}
	p = (u8 *) alg.p;
	end = p + alg.len;
	if p >= end
	{
		return -0x2300 + -0x0060;
	}
	md_oid.tag = *p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &md_oid.len, 0x06)) != 0
	{
		return -0x2300 + ret;
	}
	md_oid.p = p;
	p += md_oid.len;
	if (ret = mbedtls_oid_get_md_alg(&md_oid, md_alg)) != 0
	{
		return -0x2300 + ret;
	}
	if p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x05)) != 0 || len != 0
	{
		return -0x2300 + ret;
	}
	if p != end
	{
		return -0x2300 + -0x0066;
	}
	return 0;
}

pub fn mbedtls_x509_get_rsassa_pss_params(const mbedtls_x509_buf * params, mbedtls_md_type_t * md_alg, mbedtls_md_type_t * mgf_md, i32 * salt_len) -> i32
{
	i32 ret;
	u8 * p;
	const u8 *end, *end2;
	usize len;
	mbedtls_x509_buf alg_id, alg_params;
	*md_alg = MBEDTLS_MD_SHA1;
	*mgf_md = MBEDTLS_MD_SHA1;
	*salt_len = 20;
	if params.tag != (0x20 | 0x10)
	{
		return -0x2300 + -0x0062;
	}
	p = (u8 *) params.p;
	end = p + params.len;
	if p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 0)) == 0
	{
		end2 = p + len;
		if (ret = mbedtls_x509_get_alg_null(&p, end2, &alg_id)) != 0
		{
			return ret;
		}
		if (ret = mbedtls_oid_get_md_alg(&alg_id, md_alg)) != 0
		{
			return -0x2300 + ret;
		}
		if p != end2
		{
			return -0x2300 + -0x0066;
		}
	}
	else
		if ret != -0x0062
		{
			return -0x2300 + ret;
		}
	if p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 1)) == 0
	{
		end2 = p + len;
		if (ret = mbedtls_x509_get_alg(&p, end2, &alg_id, &alg_params)) != 0
		{
			return ret;
		}
		if ((((sizeof("\x2a"
					  "\x86\x48"
					  "\x86\xf7\x0d"
					  "\x01"
					  "\x01"
					  "\x08") -
				1) != (&alg_id)->len) ||
				memcmp(("\x2a"
						"\x86\x48"
						"\x86\xf7\x0d"
						"\x01"
						"\x01"
						"\x08"),
					   (&alg_id)->p, (&alg_id)->len) != 0) != 0)
		{
			return -0x2080 + -0x002E;
		}
		if (ret = x509_get_hash_alg(&alg_params, mgf_md)) != 0
		{
			return ret;
		}
		if p != end2
		{
			return -0x2300 + -0x0066;
		}
	}
	else
		if ret != -0x0062
		{
			return -0x2300 + ret;
		}
	if p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 2)) == 0
	{
		end2 = p + len;
		if (ret = mbedtls_asn1_get_int(&p, end2, salt_len)) != 0
		{
			return -0x2300 + ret;
		}
		if p != end2
		{
			return -0x2300 + -0x0066;
		}
	}
	else
		if ret != -0x0062
		{
			return -0x2300 + ret;
		}
	if p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 3)) == 0
	{
		i32 trailer_field;
		end2 = p + len;
		if (ret = mbedtls_asn1_get_int(&p, end2, &trailer_field)) != 0
		{
			return -0x2300 + ret;
		}
		if p != end2
		{
			return -0x2300 + -0x0066;
		}
		if trailer_field != 1
		{
			return -0x2300;
		}
	}
	else
		if ret != -0x0062
		{
			return -0x2300 + ret;
		}
	if p != end
	{
		return -0x2300 + -0x0066;
	}
	return 0;
}

fn x509_get_attr_type_value(u8 ** p, const u8 * end, mbedtls_x509_name * cur) -> i32
{
	i32 ret;
	usize len;
	mbedtls_x509_buf * oid;
	mbedtls_x509_buf * val;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x2380 + ret;
	}
	if (end - *p) < 1
	{
		return -0x2380 + -0x0060;
	}
	oid = &cur.oid;
	oid.tag = **p;
	if (ret = mbedtls_asn1_get_tag(p, end, &oid.len, 0x06)) != 0
	{
		return -0x2380 + ret;
	}
	oid.p = *p;
	*p += oid.len;
	if (end - *p) < 1
	{
		return -0x2380 + -0x0060;
	}
	if **p != 0x1E && **p != 0x0C && **p != 0x14 && **p != 0x13 && **p != 0x16 && **p != 0x1C && **p != 0x03
	{
		return -0x2380 + -0x0062;
	}
	val = &cur.val;
	val.tag = *(*p)++;
	if (ret = mbedtls_asn1_get_len(p, end, &val.len)) != 0
	{
		return -0x2380 + ret;
	}
	val.p = *p;
	*p += val.len;
	cur.next = NULL;
	return 0;
}

pub fn mbedtls_x509_get_name(u8 ** p, const u8 * end, mbedtls_x509_name * cur) -> i32
{
	i32 ret;
	usize set_len;
	const u8 * end_set;
	while (1)
	{
		if (ret = mbedtls_asn1_get_tag(p, end, &set_len, 0x20 | 0x11)) != 0
		{
			return -0x2380 + ret;
		}
		end_set = *p + set_len;
		while (1)
		{
			if (ret = x509_get_attr_type_value(p, end_set, cur)) != 0
			{
				return ret;
			}
			if *p == end_set
			{
				break;

			}
			cur.next_merged = 1;
			cur.next = mbedtls_calloc(1, sizeof(mbedtls_x509_name));
			if cur.next == NULL
			{
				return -0x2880;
			}
			cur = cur.next;
		}
		if *p == end
		{
			return 0;
		}
		cur.next = mbedtls_calloc(1, sizeof(mbedtls_x509_name));
		if cur.next == NULL
		{
			return -0x2880;
		}
		cur = cur.next;
	}
}

fn x509_parse_int(u8 ** p, i32 n, i32 * res) -> i32
{
	*res = 0;
	for (; n > 0; --n)
	{
		if (**p < '0') || (**p > '9')
		{
			return -0x2400;
		}
		*res *= 10;
		*res += (*(*p)++ - '0');
	}
	return 0;
}

pub fn mbedtls_x509_get_time(u8 ** p, const u8 * end, mbedtls_x509_time * time) -> i32
{
	i32 ret;
	usize len;
	u8 tag;
	if (end - *p) < 1
	{
		return -0x2400 + -0x0060;
	}
	tag = **p;
	if tag == 0x17
	{
		(*p)++;
		ret = mbedtls_asn1_get_len(p, end, &len);
		if ret != 0
		{
			return -0x2400 + ret;
		}
		if (ret = x509_parse_int(p, 2, &time.year)) != 0
		{
			return ret;
		};
		if (ret = x509_parse_int(p, 2, &time.mon)) != 0
		{
			return ret;
		};
		if (ret = x509_parse_int(p, 2, &time.day)) != 0
		{
			return ret;
		};
		if (ret = x509_parse_int(p, 2, &time.hour)) != 0
		{
			return ret;
		};
		if (ret = x509_parse_int(p, 2, &time.min)) != 0
		{
			return ret;
		};
		if len > 10
			if (ret = x509_parse_int(p, 2, &time.sec)) != 0
			{
				return ret;
			};
		if len > 12 && *(*p)++ != 'Z'
		{
			return -0x2400;
		}
		time.year += 100 * (time.year < 50);
		time.year += 1900;
		return 0;
	}
	else
		if tag == 0x18
		{
			(*p)++;
			ret = mbedtls_asn1_get_len(p, end, &len);
			if ret != 0
			{
				return -0x2400 + ret;
			}
			if (ret = x509_parse_int(p, 4, &time.year)) != 0
			{
				return ret;
			};
			if (ret = x509_parse_int(p, 2, &time.mon)) != 0
			{
				return ret;
			};
			if (ret = x509_parse_int(p, 2, &time.day)) != 0
			{
				return ret;
			};
			if (ret = x509_parse_int(p, 2, &time.hour)) != 0
			{
				return ret;
			};
			if (ret = x509_parse_int(p, 2, &time.min)) != 0
			{
				return ret;
			};
			if len > 12
				if (ret = x509_parse_int(p, 2, &time.sec)) != 0
				{
					return ret;
				};
			if len > 14 && *(*p)++ != 'Z'
			{
				return -0x2400;
			}
			return 0;
		}
		else
		{
			return -0x2400 + -0x0062;
		}
}

pub fn mbedtls_x509_get_sig(u8 ** p, const u8 * end, mbedtls_x509_buf * sig) -> i32
{
	i32 ret;
	usize len;
	if (end - *p) < 1
	{
		return -0x2480 + -0x0060;
	}
	sig.tag = **p;
	if (ret = mbedtls_asn1_get_bitstring_null(p, end, &len)) != 0
	{
		return -0x2480 + ret;
	}
	sig.len = len;
	sig.p = *p;
	*p += len;
	return 0;
}

pub fn mbedtls_x509_get_sig_alg(const mbedtls_x509_buf * sig_oid, const mbedtls_x509_buf * sig_params, mbedtls_md_type_t * md_alg, mbedtls_pk_type_t * pk_alg, void ** sig_opts) -> i32
{
	i32 ret;
	if *sig_opts != NULL
	{
		return -0x2800;
	}
	if (ret = mbedtls_oid_get_sig_alg(sig_oid, md_alg, pk_alg)) != 0
	{
		return -0x2600 + ret;
	}
	if *pk_alg == MBEDTLS_PK_RSASSA_PSS
	{
		mbedtls_pk_rsassa_pss_options * pss_opts;
		pss_opts = mbedtls_calloc(1, sizeof(mbedtls_pk_rsassa_pss_options));
		if pss_opts == NULL
		{
			return -0x2880;
		}
		ret = mbedtls_x509_get_rsassa_pss_params(sig_params, md_alg, &pss_opts.mgf1_hash_id, &pss_opts.expected_salt_len);
		if ret != 0
		{
			mbedtls_free(pss_opts);
			return ret;
		}
		*sig_opts = (void *) pss_opts;
	}
	else
	{
		if (sig_params.tag != 0x05 && sig_params.tag != 0) || sig_params.len != 0
		{
			return -0x2300;
		}
	}
	return 0;
}

pub fn mbedtls_x509_get_ext(u8 ** p, const u8 * end, mbedtls_x509_buf * ext, i32 tag) -> i32
{
	i32 ret;
	usize len;
	if *p == end
	{
		return 0;
	}
	ext.tag = **p;
	if (ret = mbedtls_asn1_get_tag(p, end, &ext.len, 0x80 | 0x20 | tag)) != 0
	{
		return ret;
	}
	ext.p = *p;
	end = *p + ext.len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x2500 + ret;
	}
	if end != *p + len
	{
		return -0x2500 + -0x0066;
	}
	return 0;
}

pub fn mbedtls_x509_dn_gets(i8 * buf, usize size, const mbedtls_x509_name * dn) -> i32
{
	i32 ret;
	usize i, n;
	u8 c, merge = 0;
	const mbedtls_x509_name * name;
	const i8 * short_name = NULL;
	i8 s[256], *p;
	memset(s, 0, sizeof(s));
	name = dn;
	p = buf;
	n = size;
	while (name != NULL)
	{
		if !name.oid.p
		{
			name = name.next;
			continue;
		}
		if name != dn
		{
			ret = snprintf(p, n, merge ? " + " : ", ");
			do
			{
				if ret < 0 || (usize) ret >= n
				{
					return -0x2980;
				}
				n -= (usize) ret;
				p += (usize) ret;
			}
			while (0);
		}
		ret = mbedtls_oid_get_attr_short_name(&name.oid, &short_name);
		if ret == 0
		{
			ret = snprintf(p, n, "%s=", short_name);
		}
		else
		{
			ret = snprintf(p, n, "\?\?=");
		}
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		for (i = 0; i < name.val.len; i++)
		{
			if i >= sizeof(s) - 1
			{
				break;

			}
			c = name.val.p[i];
			if c < 32 || c == 127 || (c > 128 && c < 160)
			{
				s[i] = '?';
			}
			else
			{
				s[i] = c;
			}
		}
		s[i] = '\0';
		ret = snprintf(p, n, "%s", s);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		merge = name.next_merged;
		name = name.next;
	}
	return (int) (size - n);
}

pub fn mbedtls_x509_serial_gets(i8 * buf, usize size, const mbedtls_x509_buf * serial) -> i32
{
	i32 ret;
	usize i, n, nr;
	i8 * p;
	p = buf;
	n = size;
	nr = (serial.len <= 32) ? serial.len : 28;
	for (i = 0; i < nr; i++)
	{
		if i == 0 && nr > 1 && serial.p[i] == 0x0
		{
			continue;
		}
		ret = snprintf(p, n, "%02X%s", serial.p[i], (i < nr - 1) ? ":" : "");
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
	}
	if nr != serial.len
	{
		ret = snprintf(p, n, "....");
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
	}
	return (int) (size - n);
}

pub fn mbedtls_x509_sig_alg_gets(i8 * buf, usize size, const mbedtls_x509_buf * sig_oid, mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg, const void * sig_opts) -> i32
{
	i32 ret;
	i8 * p = buf;
	usize n = size;
	const i8 * desc = NULL;
	ret = mbedtls_oid_get_sig_alg_desc(sig_oid, &desc);
	if ret != 0
	{
		ret = snprintf(p, n, "???");
	}
	else
	{
		ret = snprintf(p, n, "%s", desc);
	}
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	if pk_alg == MBEDTLS_PK_RSASSA_PSS
	{
		const mbedtls_pk_rsassa_pss_options * pss_opts;
		const mbedtls_md_info_t *md_info, *mgf_md_info;
		pss_opts = (const mbedtls_pk_rsassa_pss_options *) sig_opts;
		md_info = mbedtls_md_info_from_type(md_alg);
		mgf_md_info = mbedtls_md_info_from_type(pss_opts.mgf1_hash_id);
		ret = snprintf(p, n, " (%s, MGF1-%s, 0x%02X)", md_info ? mbedtls_md_get_name(md_info) : "???", mgf_md_info ? mbedtls_md_get_name(mgf_md_info) : "???", pss_opts.expected_salt_len);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
	}
	return (int) (size - n);
}

pub fn mbedtls_x509_key_size_helper(i8 * buf, usize buf_size, const i8 * name) -> i32
{
	i8 * p = buf;
	usize n = buf_size;
	i32 ret;
	ret = snprintf(p, n, "%s key size", name);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	return 0;
}

fn x509_get_current_time(mbedtls_x509_time * now) -> i32
{
	struct tm * lt;
	time_t tt;
	i32 ret = 0;
	if mbedtls_mutex_lock(&mbedtls_threading_gmtime_mutex) != 0
	{
		return -0x001E;
	}
	tt = time(NULL);
	lt = gmtime(&tt);
	if lt == NULL
	{
		ret = -1;
	}
	else
	{
		now.year = lt.tm_year + 1900;
		now.mon = lt.tm_mon + 1;
		now.day = lt.tm_mday;
		now.hour = lt.tm_hour;
		now.min = lt.tm_min;
		now.sec = lt.tm_sec;
	}
	if mbedtls_mutex_unlock(&mbedtls_threading_gmtime_mutex) != 0
	{
		return -0x001E;
	}
	return ret;
}

fn x509_check_time(const mbedtls_x509_time * before, const mbedtls_x509_time * after) -> i32
{
	if before.year > after.year
	{
		return 1;
	}
	if before.year == after.year && before.mon > after.mon
	{
		return 1;
	}
	if before.year == after.year && before.mon == after.mon && before.day > after.day
	{
		return 1;
	}
	if before.year == after.year && before.mon == after.mon && before.day == after.day && before.hour > after.hour
	{
		return 1;
	}
	if before.year == after.year && before.mon == after.mon && before.day == after.day && before.hour == after.hour && before.min > after.min
	{
		return 1;
	}
	if before.year == after.year && before.mon == after.mon && before.day == after.day && before.hour == after.hour && before.min == after.min && before.sec > after.sec
	{
		return 1;
	}
	return 0;
}

pub fn mbedtls_x509_time_is_past(const mbedtls_x509_time * to) -> i32
{
	mbedtls_x509_time now;
	if x509_get_current_time(&now) != 0
	{
		return 1;
	}
	return x509_check_time(&now, to);
}

pub fn mbedtls_x509_time_is_future(const mbedtls_x509_time * from) -> i32
{
	mbedtls_x509_time now;
	if x509_get_current_time(&now) != 0
	{
		return 1;
	}
	return x509_check_time(from, &now);
}

pub fn mbedtls_x509_self_test(i32 verbose) -> i32
{
	((void) verbose);
	return 0;
}

typedef struct
{
	const i8 * name;
	usize name_len;
	const i8 * oid;
} x509_attr_descriptor_t;
static const x509_attr_descriptor_t x509_attrs[] = {{"CN", sizeof("CN") - 1, "\x55"
		"\x04"
		"\x03"
	},
	{
		"commonName", sizeof("commonName") - 1, "\x55"
		"\x04"
		"\x03"
	},
	{
		"C", sizeof("C") - 1, "\x55"
		"\x04"
		"\x06"
	},
	{
		"countryName", sizeof("countryName") - 1, "\x55"
		"\x04"
		"\x06"
	},
	{
		"O", sizeof("O") - 1, "\x55"
		"\x04"
		"\x0A"
	},
	{
		"organizationName", sizeof("organizationName") - 1, "\x55"
		"\x04"
		"\x0A"
	},
	{
		"L", sizeof("L") - 1, "\x55"
		"\x04"
		"\x07"
	},
	{
		"locality", sizeof("locality") - 1, "\x55"
		"\x04"
		"\x07"
	},
	{
		"R", sizeof("R") - 1, "\x2a"
		"\x86\x48"
		"\x86\xf7\x0d"
		"\x01"
		"\x09"
		"\x01"
	},
	{
		"OU", sizeof("OU") - 1, "\x55"
		"\x04"
		"\x0B"
	},
	{
		"organizationalUnitName", sizeof("organizationalUnitName") - 1, "\x55"
		"\x04"
		"\x0B"
	},
	{
		"ST", sizeof("ST") - 1, "\x55"
		"\x04"
		"\x08"
	},
	{
		"stateOrProvinceName", sizeof("stateOrProvinceName") - 1, "\x55"
		"\x04"
		"\x08"
	},
	{
		"emailAddress", sizeof("emailAddress") - 1, "\x2a"
		"\x86\x48"
		"\x86\xf7\x0d"
		"\x01"
		"\x09"
		"\x01"
	},
	{
		"serialNumber", sizeof("serialNumber") - 1, "\x55"
		"\x04"
		"\x05"
	},
	{
		"postalAddress", sizeof("postalAddress") - 1, "\x55"
		"\x04"
		"\x10"
	},
	{
		"postalCode", sizeof("postalCode") - 1, "\x55"
		"\x04"
		"\x11"
	},
	{
		"dnQualifier", sizeof("dnQualifier") - 1, "\x55"
		"\x04"
		"\x2E"
	},
	{
		"title", sizeof("title") - 1, "\x55"
		"\x04"
		"\x0C"
	},
	{
		"surName", sizeof("surName") - 1, "\x55"
		"\x04"
		"\x04"
	},
	{
		"SN", sizeof("SN") - 1, "\x55"
		"\x04"
		"\x04"
	},
	{
		"givenName", sizeof("givenName") - 1, "\x55"
		"\x04"
		"\x2A"
	},
	{
		"GN", sizeof("GN") - 1, "\x55"
		"\x04"
		"\x2A"
	},
	{
		"initials", sizeof("initials") - 1, "\x55"
		"\x04"
		"\x2B"
	},
	{
		"pseudonym", sizeof("pseudonym") - 1, "\x55"
		"\x04"
		"\x41"
	},
	{
		"generationQualifier", sizeof("generationQualifier") - 1, "\x55"
		"\x04"
		"\x2C"
	},
	{"domainComponent", sizeof("domainComponent") - 1, "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x19"}, {"DC", sizeof("DC") - 1, "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x19"}, {NULL, 0, NULL}
};
fn i8 * x509_at_oid_from_name(const i8 * name, usize name_len) -> const
{
	const x509_attr_descriptor_t * cur;
	for (cur = x509_attrs; cur.name != NULL; cur++)
		if cur.name_len == name_len && strncmp(cur.name, name, name_len) == 0
		{
			break;

		}
	return cur.oid;
}

pub fn mbedtls_x509_string_to_names(mbedtls_asn1_named_data ** head, const i8 * name) -> i32
{
	i32 ret = 0;
	const i8 *s = name, *c = s;
	const i8 * end = s + strlen(s);
	const i8 * oid = NULL;
	i32 in_tag = 1;
	i8 data[256];
	i8 * d = data;
	mbedtls_asn1_free_named_data_list(head);
	while (c <= end)
	{
		if in_tag && *c == '='
		{
			if (oid = x509_at_oid_from_name(s, c - s)) == NULL
			{
				ret = -0x2100;
				goto exit;
			}
			s = c + 1;
			in_tag = 0;
			d = data;
		}
		if !in_tag && *c == '\\' && c != end
		{
			c++;
			if c == end || *c != ','
			{
				ret = -0x2380;
				goto exit;
			}
		}
		else
			if !in_tag && (*c == ',' || c == end)
			{
				if mbedtls_asn1_store_named_data(head, oid, strlen(oid), (u8 *) data, d - data) == NULL
				{
					return -0x2880;
				}
				while (c < end && *(c + 1) == ' ')
				{
					c++;
				}
				s = c + 1;
				in_tag = 1;
			}
		if !in_tag && s != c + 1
		{
			*(d++) = *c;
			if d - data == 256
			{
				ret = -0x2380;
				goto exit;
			}
		}
		c++;
	}
exit:
	return ret;
}

pub fn mbedtls_x509_set_extension(mbedtls_asn1_named_data ** head, const i8 * oid, usize oid_len, i32 critical, const u8 * val, usize val_len) -> i32
{
	mbedtls_asn1_named_data * cur;
	if (cur = mbedtls_asn1_store_named_data(head, oid, oid_len, NULL, val_len + 1)) == NULL
	{
		return -0x2880;
	}
	cur.val.p[0] = critical;
	memcpy(cur.val.p + 1, val, val_len);
	return 0;
}

fn x509_write_name(u8 ** p, u8 * start, const i8 * oid, usize oid_len, const u8 * name, usize name_len) -> i32
{
	i32 ret;
	usize len = 0;
	if ((sizeof("\x2a"
				"\x86\x48"
				"\x86\xf7\x0d"
				"\x01"
				"\x09"
				"\x01") -
			1) == oid_len &&
			memcmp(oid, "\x2a"
				   "\x86\x48"
				   "\x86\xf7\x0d"
				   "\x01"
				   "\x09"
				   "\x01",
				   oid_len) == 0)
	{
		do
		{
			if (ret = mbedtls_asn1_write_ia5_string(p, start, (const i8 *) name, name_len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	else
	{
		do
		{
			if (ret = mbedtls_asn1_write_printable_string(p, start, (const i8 *) name, name_len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_asn1_write_oid(p, start, oid, oid_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x20 | 0x11)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_x509_write_names(u8 ** p, u8 * start, mbedtls_asn1_named_data * first) -> i32
{
	i32 ret;
	usize len = 0;
	mbedtls_asn1_named_data * cur = first;
	while (cur != NULL)
	{
		do
		{
			if (ret = x509_write_name(p, start, (i8 *) cur.oid.p, cur.oid.len, cur.val.p, cur.val.len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		cur = cur.next;
	}
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_x509_write_sig(u8 ** p, u8 * start, const i8 * oid, usize oid_len, u8 * sig, usize size) -> i32
{
	i32 ret;
	usize len = 0;
	if *p < start || (usize)(*p - start) < size
	{
		return -0x006C;
	}
	len = size;
	(*p) -= len;
	memcpy(*p, sig, len);
	if *p - start < 1
	{
		return -0x006C;
	}
	*--(*p) = 0;
	len += 1;
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x03)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_algorithm_identifier(p, start, oid, oid_len, 0)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

fn x509_write_extension(u8 ** p, u8 * start, mbedtls_asn1_named_data * ext) -> i32
{
	i32 ret;
	usize len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_raw_buffer(p, start, ext.val.p + 1, ext.val.len - 1)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, ext.val.len - 1)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x04)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	if ext.val.p[0] != 0
	{
		do
		{
			if (ret = mbedtls_asn1_write_bool(p, start, 1)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_asn1_write_raw_buffer(p, start, ext.oid.p, ext.oid.len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, ext.oid.len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x06)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(p, start, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_x509_write_extensions(u8 ** p, u8 * start, mbedtls_asn1_named_data * first) -> i32
{
	i32 ret;
	usize len = 0;
	mbedtls_asn1_named_data * cur_ext = first;
	while (cur_ext != NULL)
	{
		do
		{
			if (ret = x509_write_extension(p, start, cur_ext)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		cur_ext = cur_ext.next;
	}
	return (int) len;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

fn x509_crl_get_version(u8 ** p, const u8 * end, i32 * ver) -> i32
{
	i32 ret;
	if (ret = mbedtls_asn1_get_int(p, end, ver)) != 0
	{
		if ret == -0x0062
		{
			*ver = 0;
			return 0;
		}
		return -0x2200 + ret;
	}
	return 0;
}

fn x509_get_crl_ext(u8 ** p, const u8 * end, mbedtls_x509_buf * ext) -> i32
{
	i32 ret;
	usize len = 0;
	if (ret = mbedtls_x509_get_ext(p, end, ext, 0)) != 0
	{
		if ret == -0x0062
		{
			return 0;
		}
		return ret;
	}
	while (*p < end)
	{
		if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
		{
			return -0x2500 + ret;
		}
		*p += len;
	}
	if *p != end
	{
		return -0x2500 + -0x0066;
	}
	return 0;
}

fn x509_get_crl_entry_ext(u8 ** p, const u8 * end, mbedtls_x509_buf * ext) -> i32
{
	i32 ret;
	usize len = 0;
	if end <= *p
	{
		return 0;
	}
	ext.tag = **p;
	ext.p = *p;
	if (ret = mbedtls_asn1_get_tag(p, end, &ext.len, 0x20 | 0x10)) != 0
	{
		if ret == -0x0062
		{
			ext.p = NULL;
			return 0;
		}
		return -0x2500 + ret;
	}
	end = *p + ext.len;
	if end != *p + ext.len
	{
		return -0x2500 + -0x0066;
	}
	while (*p < end)
	{
		if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
		{
			return -0x2500 + ret;
		}
		*p += len;
	}
	if *p != end
	{
		return -0x2500 + -0x0066;
	}
	return 0;
}

fn x509_get_entries(u8 ** p, const u8 * end, mbedtls_x509_crl_entry * entry) -> i32
{
	i32 ret;
	usize entry_len;
	mbedtls_x509_crl_entry * cur_entry = entry;
	if *p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_tag(p, end, &entry_len, 0x10 | 0x20)) != 0
	{
		if ret == -0x0062
		{
			return 0;
		}
		return ret;
	}
	end = *p + entry_len;
	while (*p < end)
	{
		usize len2;
		const u8 * end2;
		if (ret = mbedtls_asn1_get_tag(p, end, &len2, 0x10 | 0x20)) != 0
		{
			return ret;
		}
		cur_entry.raw.tag = **p;
		cur_entry.raw.p = *p;
		cur_entry.raw.len = len2;
		end2 = *p + len2;
		if (ret = mbedtls_x509_get_serial(p, end2, &cur_entry.serial)) != 0
		{
			return ret;
		}
		if (ret = mbedtls_x509_get_time(p, end2, &cur_entry.revocation_date)) != 0
		{
			return ret;
		}
		if (ret = x509_get_crl_entry_ext(p, end2, &cur_entry.entry_ext)) != 0
		{
			return ret;
		}
		if *p < end
		{
			cur_entry.next = mbedtls_calloc(1, sizeof(mbedtls_x509_crl_entry));
			if cur_entry.next == NULL
			{
				return -0x2880;
			}
			cur_entry = cur_entry.next;
		}
	}
	return 0;
}

pub fn mbedtls_x509_crl_parse_der(mbedtls_x509_crl * chain, const u8 * buf, usize buflen) -> i32
{
	i32 ret;
	usize len;
	u8 *p, *end;
	mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;
	mbedtls_x509_crl * crl = chain;
	if crl == NULL || buf == NULL
	{
		return -0x2800;
	}
	memset(&sig_params1, 0, sizeof(mbedtls_x509_buf));
	memset(&sig_params2, 0, sizeof(mbedtls_x509_buf));
	memset(&sig_oid2, 0, sizeof(mbedtls_x509_buf));
	while (crl.version != 0 && crl.next != NULL)
	{
		crl = crl.next;
	}
	if crl.version != 0 && crl.next == NULL
	{
		crl.next = mbedtls_calloc(1, sizeof(mbedtls_x509_crl));
		if crl.next == NULL
		{
			mbedtls_x509_crl_free(crl);
			return -0x2880;
		}
		mbedtls_x509_crl_init(crl.next);
		crl = crl.next;
	}
	if (p = mbedtls_calloc(1, buflen)) == NULL
	{
		return -0x2880;
	}
	memcpy(p, buf, buflen);
	crl.raw.p = p;
	crl.raw.len = buflen;
	end = p + buflen;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return -0x2180;
	}
	if len != (usize)(end - p)
	{
		mbedtls_x509_crl_free(crl);
		return -0x2180 + -0x0066;
	}
	crl.tbs.p = p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return -0x2180 + ret;
	}
	end = p + len;
	crl.tbs.len = end - crl.tbs.p;
	if (ret = x509_crl_get_version(&p, end, &crl.version)) != 0 || (ret = mbedtls_x509_get_alg(&p, end, &crl.sig_oid, &sig_params1)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return ret;
	}
	crl.version++;
	if crl.version > 2
	{
		mbedtls_x509_crl_free(crl);
		return -0x2580;
	}
	if (ret = mbedtls_x509_get_sig_alg(&crl.sig_oid, &sig_params1, &crl.sig_md, &crl.sig_pk, &crl.sig_opts)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return -0x2600;
	}
	crl.issuer_raw.p = p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return -0x2180 + ret;
	}
	if (ret = mbedtls_x509_get_name(&p, p + len, &crl.issuer)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return ret;
	}
	crl.issuer_raw.len = p - crl.issuer_raw.p;
	if (ret = mbedtls_x509_get_time(&p, end, &crl.this_update)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return ret;
	}
	if (ret = mbedtls_x509_get_time(&p, end, &crl.next_update)) != 0
	{
		if ret != (-0x2400 + -0x0062) && ret != (-0x2400 + -0x0060)
		{
			mbedtls_x509_crl_free(crl);
			return ret;
		}
	}
	if (ret = x509_get_entries(&p, end, &crl.entry)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return ret;
	}
	if crl.version == 2
	{
		ret = x509_get_crl_ext(&p, end, &crl.crl_ext);
		if ret != 0
		{
			mbedtls_x509_crl_free(crl);
			return ret;
		}
	}
	if p != end
	{
		mbedtls_x509_crl_free(crl);
		return -0x2180 + -0x0066;
	}
	end = crl.raw.p + crl.raw.len;
	if (ret = mbedtls_x509_get_alg(&p, end, &sig_oid2, &sig_params2)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return ret;
	}
	if crl.sig_oid.len != sig_oid2.len || memcmp(crl.sig_oid.p, sig_oid2.p, crl.sig_oid.len) != 0 || sig_params1.len != sig_params2.len || (sig_params1.len != 0 && memcmp(sig_params1.p, sig_params2.p, sig_params1.len) != 0)
	{
		mbedtls_x509_crl_free(crl);
		return -0x2680;
	}
	if (ret = mbedtls_x509_get_sig(&p, end, &crl.sig)) != 0
	{
		mbedtls_x509_crl_free(crl);
		return ret;
	}
	if p != end
	{
		mbedtls_x509_crl_free(crl);
		return -0x2180 + -0x0066;
	}
	return 0;
}

pub fn mbedtls_x509_crl_parse(mbedtls_x509_crl * chain, const u8 * buf, usize buflen) -> i32
{
	i32 ret;
	usize use_len;
	mbedtls_pem_context pem;
	i32 is_pem = 0;
	if chain == NULL || buf == NULL
	{
		return -0x2800;
	}
	do
	{
		mbedtls_pem_init(&pem);
		if buflen == 0 || buf[buflen - 1] != '\0'
		{
			ret = -0x1080;
		}
		else
		{
			ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN X509 CRL-----", "-----END X509 CRL-----", buf, NULL, 0, &use_len);
		}
		if ret == 0
		{
			is_pem = 1;
			buflen -= use_len;
			buf += use_len;
			if (ret = mbedtls_x509_crl_parse_der(chain, pem.buf, pem.buflen)) != 0
			{
				return ret;
			}
			mbedtls_pem_free(&pem);
		}
		else
			if ret != -0x1080
			{
				mbedtls_pem_free(&pem);
				return ret;
			}
	}
	while (is_pem && buflen > 1);
	if is_pem
	{
		return 0;
	}
	else
	{
		return mbedtls_x509_crl_parse_der(chain, buf, buflen);
	}
}

pub fn mbedtls_x509_crl_parse_file(mbedtls_x509_crl * chain, const i8 * path) -> i32
{
	i32 ret;
	usize n;
	u8 * buf;
	if (ret = mbedtls_pk_load_file(path, &buf, &n)) != 0
	{
		return ret;
	}
	ret = mbedtls_x509_crl_parse(chain, buf, n);
	zeroize(buf, n);
	mbedtls_free(buf);
	return ret;
}

pub fn mbedtls_x509_crl_info(i8 * buf, usize size, const i8 * prefix, const mbedtls_x509_crl * crl) -> i32
{
	i32 ret;
	usize n;
	i8 * p;
	const mbedtls_x509_crl_entry * entry;
	p = buf;
	n = size;
	ret = snprintf(p, n, "%sCRL version   : %d", prefix, crl.version);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%sissuer name   : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_dn_gets(p, n, &crl.issuer);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%sthis update   : "
				   "%04d-%02d-%02d %02d:%02d:%02d",
				   prefix, crl.this_update.year, crl.this_update.mon, crl.this_update.day, crl.this_update.hour, crl.this_update.min, crl.this_update.sec);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%snext update   : "
				   "%04d-%02d-%02d %02d:%02d:%02d",
				   prefix, crl.next_update.year, crl.next_update.mon, crl.next_update.day, crl.next_update.hour, crl.next_update.min, crl.next_update.sec);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	entry = &crl.entry;
	ret = snprintf(p, n, "\n%sRevoked certificates:", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	while (entry != NULL && entry.raw.len != 0)
	{
		ret = snprintf(p, n, "\n%sserial number: ", prefix);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		ret = mbedtls_x509_serial_gets(p, n, &entry.serial);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		ret = snprintf(p, n, " revocation date: "
					   "%04d-%02d-%02d %02d:%02d:%02d",
					   entry.revocation_date.year, entry.revocation_date.mon, entry.revocation_date.day, entry.revocation_date.hour, entry.revocation_date.min, entry.revocation_date.sec);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		entry = entry.next;
	}
	ret = snprintf(p, n, "\n%si32 using  : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_sig_alg_gets(p, n, &crl.sig_oid, crl.sig_pk, crl.sig_md, crl.sig_opts);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n");
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	return (int) (size - n);
}

pub fn mbedtls_x509_crl_init(mbedtls_x509_crl * crl)
{
	memset(crl, 0, sizeof(mbedtls_x509_crl));
}

pub fn mbedtls_x509_crl_free(mbedtls_x509_crl * crl)
{
	mbedtls_x509_crl * crl_cur = crl;
	mbedtls_x509_crl * crl_prv;
	mbedtls_x509_name * name_cur;
	mbedtls_x509_name * name_prv;
	mbedtls_x509_crl_entry * entry_cur;
	mbedtls_x509_crl_entry * entry_prv;
	if crl == NULL
	{
		return;
	}
	do
	{
		mbedtls_free(crl_cur.sig_opts);
		name_cur = crl_cur.issuer.next;
		while (name_cur != NULL)
		{
			name_prv = name_cur;
			name_cur = name_cur.next;
			zeroize(name_prv, sizeof(mbedtls_x509_name));
			mbedtls_free(name_prv);
		}
		entry_cur = crl_cur.entry.next;
		while (entry_cur != NULL)
		{
			entry_prv = entry_cur;
			entry_cur = entry_cur.next;
			zeroize(entry_prv, sizeof(mbedtls_x509_crl_entry));
			mbedtls_free(entry_prv);
		}
		if crl_cur.raw.p != NULL
		{
			zeroize(crl_cur.raw.p, crl_cur.raw.len);
			mbedtls_free(crl_cur.raw.p);
		}
		crl_cur = crl_cur.next;
	}
	while (crl_cur != NULL);
	crl_cur = crl;
	do
	{
		crl_prv = crl_cur;
		crl_cur = crl_cur.next;
		zeroize(crl_prv, sizeof(mbedtls_x509_crl));
		if crl_prv != crl
		{
			mbedtls_free(crl_prv);
		}
	}
	while (crl_cur != NULL);
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default =
{
	(1 << (MBEDTLS_MD_SHA1 - 1)) | (1 << (MBEDTLS_MD_RIPEMD160 - 1)) | (1 << (MBEDTLS_MD_SHA224 - 1)) | (1 << (MBEDTLS_MD_SHA256 - 1)) | (1 << (MBEDTLS_MD_SHA384 - 1)) | (1 << (MBEDTLS_MD_SHA512 - 1)), 0xFFFFFFF, 0xFFFFFFF, 2048,
};
const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next =
{
	(1 << (MBEDTLS_MD_SHA256 - 1)) | (1 << (MBEDTLS_MD_SHA384 - 1)) | (1 << (MBEDTLS_MD_SHA512 - 1)), 0xFFFFFFF, (1 << (MBEDTLS_ECP_DP_SECP256R1 - 1)) | (1 << (MBEDTLS_ECP_DP_SECP384R1 - 1)) | (1 << (MBEDTLS_ECP_DP_SECP521R1 - 1)) | (1 << (MBEDTLS_ECP_DP_BP256R1 - 1)) | (1 << (MBEDTLS_ECP_DP_BP384R1 - 1)) | (1 << (MBEDTLS_ECP_DP_BP512R1 - 1)) | (1 << (MBEDTLS_ECP_DP_SECP256K1 - 1)), 2048,
};
const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =
{
	(1 << (MBEDTLS_MD_SHA256 - 1)) | (1 << (MBEDTLS_MD_SHA384 - 1)), (1 << (MBEDTLS_PK_ECDSA - 1)), (1 << (MBEDTLS_ECP_DP_SECP256R1 - 1)) | (1 << (MBEDTLS_ECP_DP_SECP384R1 - 1)), 0,
};
fn x509_profile_check_md_alg(const mbedtls_x509_crt_profile * profile, mbedtls_md_type_t md_alg) -> i32
{
	if (profile.allowed_mds & (1 << (md_alg - 1))) != 0
	{
		return 0;
	}
	return -1;
}

fn x509_profile_check_pk_alg(const mbedtls_x509_crt_profile * profile, mbedtls_pk_type_t pk_alg) -> i32
{
	if (profile.allowed_pks & (1 << (pk_alg - 1))) != 0
	{
		return 0;
	}
	return -1;
}

fn x509_profile_check_key(const mbedtls_x509_crt_profile * profile, mbedtls_pk_type_t pk_alg, const mbedtls_pk_context * pk) -> i32
{
	if pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS
	{
		if mbedtls_pk_get_bitlen(pk) >= profile.rsa_min_bitlen
		{
			return 0;
		}
		return -1;
	}
	if pk_alg == MBEDTLS_PK_ECDSA || pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH
	{
		mbedtls_ecp_group_id gid = mbedtls_pk_ec(*pk)->grp.id;
		if (profile.allowed_curves & (1 << (gid - 1))) != 0
		{
			return 0;
		}
		return -1;
	}
	return -1;
}

fn x509_get_version(u8 ** p, const u8 * end, i32 * ver) -> i32
{
	i32 ret;
	usize len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x80 | 0x20 | 0)) != 0
	{
		if ret == -0x0062
		{
			*ver = 0;
			return 0;
		}
		return ret;
	}
	end = *p + len;
	if (ret = mbedtls_asn1_get_int(p, end, ver)) != 0
	{
		return -0x2200 + ret;
	}
	if *p != end
	{
		return -0x2200 + -0x0066;
	}
	return 0;
}

fn x509_get_dates(u8 ** p, const u8 * end, mbedtls_x509_time * from, mbedtls_x509_time * to) -> i32
{
	i32 ret;
	usize len;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x2400 + ret;
	}
	end = *p + len;
	if (ret = mbedtls_x509_get_time(p, end, from)) != 0
	{
		return ret;
	}
	if (ret = mbedtls_x509_get_time(p, end, to)) != 0
	{
		return ret;
	}
	if *p != end
	{
		return -0x2400 + -0x0066;
	}
	return 0;
}

fn x509_get_uid(u8 ** p, const u8 * end, mbedtls_x509_buf * uid, i32 n) -> i32
{
	i32 ret;
	if *p == end
	{
		return 0;
	}
	uid.tag = **p;
	if (ret = mbedtls_asn1_get_tag(p, end, &uid.len, 0x80 | 0x20 | n)) != 0
	{
		if ret == -0x0062
		{
			return 0;
		}
		return ret;
	}
	uid.p = *p;
	*p += uid.len;
	return 0;
}

fn x509_get_basic_constraints(u8 ** p, const u8 * end, i32 * ca_istrue, i32 * max_pathlen) -> i32
{
	i32 ret;
	usize len;
	*ca_istrue = 0;
	*max_pathlen = 0;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x2500 + ret;
	}
	if *p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_bool(p, end, ca_istrue)) != 0
	{
		if ret == -0x0062
		{
			ret = mbedtls_asn1_get_int(p, end, ca_istrue);
		}
		if ret != 0
		{
			return -0x2500 + ret;
		}
		if *ca_istrue != 0
		{
			*ca_istrue = 1;
		}
	}
	if *p == end
	{
		return 0;
	}
	if (ret = mbedtls_asn1_get_int(p, end, max_pathlen)) != 0
	{
		return -0x2500 + ret;
	}
	if *p != end
	{
		return -0x2500 + -0x0066;
	}
	(*max_pathlen)++;
	return 0;
}

fn x509_get_ns_cert_type(u8 ** p, const u8 * end, u8 * ns_cert_type) -> i32
{
	i32 ret;
	mbedtls_x509_bitstring bs = {0, 0, NULL};
	if (ret = mbedtls_asn1_get_bitstring(p, end, &bs)) != 0
	{
		return -0x2500 + ret;
	}
	if bs.len != 1
	{
		return -0x2500 + -0x0064;
	}
	*ns_cert_type = *bs.p;
	return 0;
}

fn x509_get_key_usage(u8 ** p, const u8 * end, u32 * key_usage) -> i32
{
	i32 ret;
	usize i;
	mbedtls_x509_bitstring bs = {0, 0, NULL};
	if (ret = mbedtls_asn1_get_bitstring(p, end, &bs)) != 0
	{
		return -0x2500 + ret;
	}
	if bs.len < 1
	{
		return -0x2500 + -0x0064;
	}
	*key_usage = 0;
	for (i = 0; i < bs.len && i < sizeof(i32 int); i++)
	{
		*key_usage |= (i32 int) bs.p[i] << (8 * i);
	}
	return 0;
}

fn x509_get_ext_key_usage(u8 ** p, const u8 * end, mbedtls_x509_sequence * ext_key_usage) -> i32
{
	i32 ret;
	if (ret = mbedtls_asn1_get_sequence_of(p, end, ext_key_usage, 0x06)) != 0
	{
		return -0x2500 + ret;
	}
	if ext_key_usage.buf.p == NULL
	{
		return -0x2500 + -0x0064;
	}
	return 0;
}

fn x509_get_subject_alt_name(u8 ** p, const u8 * end, mbedtls_x509_sequence * subject_alt_name) -> i32
{
	i32 ret;
	usize len, tag_len;
	mbedtls_asn1_buf * buf;
	u8 tag;
	mbedtls_asn1_sequence * cur = subject_alt_name;
	if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
	{
		return -0x2500 + ret;
	}
	if *p + len != end
	{
		return -0x2500 + -0x0066;
	}
	while (*p < end)
	{
		if (end - *p) < 1
		{
			return -0x2500 + -0x0060;
		}
		tag = **p;
		(*p)++;
		if (ret = mbedtls_asn1_get_len(p, end, &tag_len)) != 0
		{
			return -0x2500 + ret;
		}
		if (tag & 0x80) != 0x80
		{
			return -0x2500 + -0x0062;
		}
		if tag != (0x80 | 2)
		{
			*p += tag_len;
			continue;
		}
		if cur.buf.p != NULL
		{
			if cur.next != NULL
			{
				return -0x2500;
			}
			cur.next = mbedtls_calloc(1, sizeof(mbedtls_asn1_sequence));
			if cur.next == NULL
			{
				return -0x2500 + -0x006A;
			}
			cur = cur.next;
		}
		buf = &(cur.buf);
		buf.tag = tag;
		buf.p = *p;
		buf.len = tag_len;
		*p += buf.len;
	}
	cur.next = NULL;
	if *p != end
	{
		return -0x2500 + -0x0066;
	}
	return 0;
}

fn x509_get_crt_ext(u8 ** p, const u8 * end, mbedtls_x509_crt * crt) -> i32
{
	i32 ret;
	usize len;
	u8 *end_ext_data, *end_ext_octet;
	if (ret = mbedtls_x509_get_ext(p, end, &crt.v3_ext, 3)) != 0
	{
		if ret == -0x0062
		{
			return 0;
		}
		return ret;
	}
	while (*p < end)
	{
		mbedtls_x509_buf extn_oid = {0, 0, NULL};
		i32 is_critical = 0;
		i32 ext_type = 0;
		if (ret = mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10)) != 0
		{
			return -0x2500 + ret;
		}
		end_ext_data = *p + len;
		extn_oid.tag = **p;
		if (ret = mbedtls_asn1_get_tag(p, end, &extn_oid.len, 0x06)) != 0
		{
			return -0x2500 + ret;
		}
		extn_oid.p = *p;
		*p += extn_oid.len;
		if (end - *p) < 1
		{
			return -0x2500 + -0x0060;
		}
		if (ret = mbedtls_asn1_get_bool(p, end_ext_data, &is_critical)) != 0 && (ret != -0x0062)
		{
			return -0x2500 + ret;
		}
		if (ret = mbedtls_asn1_get_tag(p, end_ext_data, &len, 0x04)) != 0
		{
			return -0x2500 + ret;
		}
		end_ext_octet = *p + len;
		if end_ext_octet != end_ext_data
		{
			return -0x2500 + -0x0066;
		}
		ret = mbedtls_oid_get_x509_ext_type(&extn_oid, &ext_type);
		if ret != 0
		{
			*p = end_ext_octet;
			if is_critical
			{
				return -0x2500 + -0x0062;
			}
			continue;
		}
		if (crt.ext_types & ext_type) != 0
		{
			return -0x2500;
		}
		crt.ext_types |= ext_type;
		switch (ext_type)
		{
			case (1 << 8):
			if (ret = x509_get_basic_constraints(p, end_ext_octet, &crt.ca_istrue, &crt.max_pathlen)) != 0
			{
				return ret;
			}
			break;

			case (1 << 2):
			if (ret = x509_get_key_usage(p, end_ext_octet, &crt.key_usage)) != 0
			{
				return ret;
			}
			break;

			case (1 << 11):
			if (ret = x509_get_ext_key_usage(p, end_ext_octet, &crt.ext_key_usage)) != 0
			{
				return ret;
			}
			break;

			case (1 << 5):
			if (ret = x509_get_subject_alt_name(p, end_ext_octet, &crt.subject_alt_names)) != 0
			{
				return ret;
			}
			break;

			case (1 << 16):
			if (ret = x509_get_ns_cert_type(p, end_ext_octet, &crt.ns_cert_type)) != 0
			{
				return ret;
			}
			break;

		default:
			return -0x2080;
		}
	}
	if *p != end
	{
		return -0x2500 + -0x0066;
	}
	return 0;
}

fn x509_crt_parse_der_core(mbedtls_x509_crt * crt, const u8 * buf, usize buflen) -> i32
{
	i32 ret;
	usize len;
	u8 *p, *end, *crt_end;
	mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;
	memset(&sig_params1, 0, sizeof(mbedtls_x509_buf));
	memset(&sig_params2, 0, sizeof(mbedtls_x509_buf));
	memset(&sig_oid2, 0, sizeof(mbedtls_x509_buf));
	if crt == NULL || buf == NULL
	{
		return -0x2800;
	}
	p = (u8 *) buf;
	len = buflen;
	end = p + len;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return -0x2180;
	}
	if len > (usize)(end - p)
	{
		mbedtls_x509_crt_free(crt);
		return -0x2180 + -0x0066;
	}
	crt_end = p + len;
	crt.raw.len = crt_end - buf;
	crt.raw.p = p = mbedtls_calloc(1, crt.raw.len);
	if p == NULL
	{
		return -0x2880;
	}
	memcpy(p, buf, crt.raw.len);
	p += crt.raw.len - len;
	end = crt_end = p + len;
	crt.tbs.p = p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return -0x2180 + ret;
	}
	end = p + len;
	crt.tbs.len = end - crt.tbs.p;
	if (ret = x509_get_version(&p, end, &crt.version)) != 0 || (ret = mbedtls_x509_get_serial(&p, end, &crt.serial)) != 0 || (ret = mbedtls_x509_get_alg(&p, end, &crt.sig_oid, &sig_params1)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	crt.version++;
	if crt.version > 3
	{
		mbedtls_x509_crt_free(crt);
		return -0x2580;
	}
	if (ret = mbedtls_x509_get_sig_alg(&crt.sig_oid, &sig_params1, &crt.sig_md, &crt.sig_pk, &crt.sig_opts)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	crt.issuer_raw.p = p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return -0x2180 + ret;
	}
	if (ret = mbedtls_x509_get_name(&p, p + len, &crt.issuer)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	crt.issuer_raw.len = p - crt.issuer_raw.p;
	if (ret = x509_get_dates(&p, end, &crt.valid_from, &crt.valid_to)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	crt.subject_raw.p = p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return -0x2180 + ret;
	}
	if len && (ret = mbedtls_x509_get_name(&p, p + len, &crt.subject)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	crt.subject_raw.len = p - crt.subject_raw.p;
	if (ret = mbedtls_pk_parse_subpubkey(&p, end, &crt.pk)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	if crt.version == 2 || crt.version == 3
	{
		ret = x509_get_uid(&p, end, &crt.issuer_id, 1);
		if ret != 0
		{
			mbedtls_x509_crt_free(crt);
			return ret;
		}
	}
	if crt.version == 2 || crt.version == 3
	{
		ret = x509_get_uid(&p, end, &crt.subject_id, 2);
		if ret != 0
		{
			mbedtls_x509_crt_free(crt);
			return ret;
		}
	}
	if crt.version == 3
	{
		ret = x509_get_crt_ext(&p, end, crt);
		if ret != 0
		{
			mbedtls_x509_crt_free(crt);
			return ret;
		}
	}
	if p != end
	{
		mbedtls_x509_crt_free(crt);
		return -0x2180 + -0x0066;
	}
	end = crt_end;
	if (ret = mbedtls_x509_get_alg(&p, end, &sig_oid2, &sig_params2)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	if crt.sig_oid.len != sig_oid2.len || memcmp(crt.sig_oid.p, sig_oid2.p, crt.sig_oid.len) != 0 || sig_params1.len != sig_params2.len || (sig_params1.len != 0 && memcmp(sig_params1.p, sig_params2.p, sig_params1.len) != 0)
	{
		mbedtls_x509_crt_free(crt);
		return -0x2680;
	}
	if (ret = mbedtls_x509_get_sig(&p, end, &crt.sig)) != 0
	{
		mbedtls_x509_crt_free(crt);
		return ret;
	}
	if p != end
	{
		mbedtls_x509_crt_free(crt);
		return -0x2180 + -0x0066;
	}
	return 0;
}

pub fn mbedtls_x509_crt_parse_der(mbedtls_x509_crt * chain, const u8 * buf, usize buflen) -> i32
{
	i32 ret;
	mbedtls_x509_crt *crt = chain, *prev = NULL;
	if crt == NULL || buf == NULL
	{
		return -0x2800;
	}
	while (crt.version != 0 && crt.next != NULL)
	{
		prev = crt;
		crt = crt.next;
	}
	if crt.version != 0 && crt.next == NULL
	{
		crt.next = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
		if crt.next == NULL
		{
			return -0x2880;
		}
		prev = crt;
		mbedtls_x509_crt_init(crt.next);
		crt = crt.next;
	}
	if (ret = x509_crt_parse_der_core(crt, buf, buflen)) != 0
	{
		if prev
		{
			prev.next = NULL;
		}
		if crt != chain
		{
			mbedtls_free(crt);
		}
		return ret;
	}
	return 0;
}

pub fn mbedtls_x509_crt_parse(mbedtls_x509_crt * chain, const u8 * buf, usize buflen) -> i32
{
	i32 success = 0, first_error = 0, total_failed = 0;
	i32 buf_format = 1;
	if chain == NULL || buf == NULL
	{
		return -0x2800;
	}
	if buflen != 0 && buf[buflen - 1] == '\0' && strstr((const i8 *) buf, "-----BEGIN CERTIFICATE-----") != NULL
	{
		buf_format = 2;
	}
	if buf_format == 1
	{
		return mbedtls_x509_crt_parse_der(chain, buf, buflen);
	}
	if buf_format == 2
	{
		i32 ret;
		mbedtls_pem_context pem;
		while (buflen > 1)
		{
			usize use_len;
			mbedtls_pem_init(&pem);
			ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN CERTIFICATE-----", "-----END CERTIFICATE-----", buf, NULL, 0, &use_len);
			if ret == 0
			{
				buflen -= use_len;
				buf += use_len;
			}
			else
				if ret == -0x1480
				{
					return ret;
				}
				else
					if ret != -0x1080
					{
						mbedtls_pem_free(&pem);
						buflen -= use_len;
						buf += use_len;
						if first_error == 0
						{
							first_error = ret;
						}
						total_failed++;
						continue;
					}
					else
					{
						break;

					}
			ret = mbedtls_x509_crt_parse_der(chain, pem.buf, pem.buflen);
			mbedtls_pem_free(&pem);
			if ret != 0
			{
				if ret == -0x2880
				{
					return ret;
				}
				if first_error == 0
				{
					first_error = ret;
				}
				total_failed++;
				continue;
			}
			success = 1;
		}
	}
	if success
	{
		return total_failed;
	}
	else
		if first_error
		{
			return first_error;
		}
		else
		{
			return -0x2780;
		}
}

pub fn mbedtls_x509_crt_parse_file(mbedtls_x509_crt * chain, const i8 * path) -> i32
{
	i32 ret;
	usize n;
	u8 * buf;
	if (ret = mbedtls_pk_load_file(path, &buf, &n)) != 0
	{
		return ret;
	}
	ret = mbedtls_x509_crt_parse(chain, buf, n);
	zeroize(buf, n);
	mbedtls_free(buf);
	return ret;
}

pub fn mbedtls_x509_crt_parse_path(mbedtls_x509_crt * chain, const i8 * path) -> i32
{
	i32 ret = 0;
	i32 t_ret;
	struct stat sb;
	struct dirent * entry;
	i8 entry_name[255];
	DIR * dir = opendir(path);
	if dir == NULL
	{
		return -0x2900;
	}
	if (ret = mbedtls_mutex_lock(&mbedtls_threading_readdir_mutex)) != 0
	{
		closedir(dir);
		return ret;
	}
	while ((entry = readdir(dir)) != NULL)
	{
		snprintf(entry_name, sizeof entry_name, "%s/%s", path, entry.d_name);
		if stat(entry_name, &sb) == -1
		{
			closedir(dir);
			ret = -0x2900;
			goto cleanup;
		}
		if !S_ISREG(sb.st_mode)
		{
			continue;
		}
		t_ret = mbedtls_x509_crt_parse_file(chain, entry_name);
		if t_ret < 0
		{
			ret++;
		}
		else
		{
			ret += t_ret;
		}
	}
	closedir(dir);
cleanup:
	if mbedtls_mutex_unlock(&mbedtls_threading_readdir_mutex) != 0
	{
		ret = -0x001E;
	}
	return ret;
}

fn x509_info_subject_alt_name(i8 ** buf, usize * size, const mbedtls_x509_sequence * subject_alt_name) -> i32
{
	usize i;
	usize n = *size;
	i8 * p = *buf;
	const mbedtls_x509_sequence * cur = subject_alt_name;
	const i8 * sep = "";
	usize sep_len = 0;
	while (cur != NULL)
	{
		if cur.buf.len + sep_len >= n
		{
			*p = '\0';
			return -0x2980;
		}
		n -= cur.buf.len + sep_len;
		for (i = 0; i < sep_len; i++)
		{
			*p++ = sep[i];
		}
		for (i = 0; i < cur.buf.len; i++)
		{
			*p++ = cur.buf.p[i];
		}
		sep = ", ";
		sep_len = 2;
		cur = cur.next;
	}
	*p = '\0';
	*size = n;
	*buf = p;
	return 0;
}

fn x509_info_cert_type(i8 ** buf, usize * size, u8 ns_cert_type) -> i32
{
	i32 ret;
	usize n = *size;
	i8 * p = *buf;
	const i8 * sep = "";
	if ns_cert_type & (0x80)
	{
		ret = snprintf(p, n, "%s"
					   "SSL Client",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if ns_cert_type & (0x40)
	{
		ret = snprintf(p, n, "%s"
					   "SSL Server",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if ns_cert_type & (0x20)
	{
		ret = snprintf(p, n, "%s"
					   "Email",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if ns_cert_type & (0x10)
	{
		ret = snprintf(p, n, "%s"
					   "Object Signing",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if ns_cert_type & (0x08)
	{
		ret = snprintf(p, n, "%s"
					   "Reserved",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if ns_cert_type & (0x04)
	{
		ret = snprintf(p, n, "%s"
					   "SSL CA",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if ns_cert_type & (0x02)
	{
		ret = snprintf(p, n, "%s"
					   "Email CA",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if ns_cert_type & (0x01)
	{
		ret = snprintf(p, n, "%s"
					   "Object Signing CA",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	*size = n;
	*buf = p;
	return 0;
}

fn x509_info_key_usage(i8 ** buf, usize * size, u32 key_usage) -> i32
{
	i32 ret;
	usize n = *size;
	i8 * p = *buf;
	const i8 * sep = "";
	if key_usage & (0x80)
	{
		ret = snprintf(p, n, "%s"
					   "Digital Signature",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x40)
	{
		ret = snprintf(p, n, "%s"
					   "Non Repudiation",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x20)
	{
		ret = snprintf(p, n, "%s"
					   "Key Encipherment",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x10)
	{
		ret = snprintf(p, n, "%s"
					   "Data Encipherment",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x08)
	{
		ret = snprintf(p, n, "%s"
					   "Key Agreement",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x04)
	{
		ret = snprintf(p, n, "%s"
					   "Key Cert Sign",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x02)
	{
		ret = snprintf(p, n, "%s"
					   "CRL Sign",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x01)
	{
		ret = snprintf(p, n, "%s"
					   "Encipher Only",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	if key_usage & (0x8000)
	{
		ret = snprintf(p, n, "%s"
					   "Decipher Only",
					   sep);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
	};
	;
	*size = n;
	*buf = p;
	return 0;
}

fn x509_info_ext_key_usage(i8 ** buf, usize * size, const mbedtls_x509_sequence * extended_key_usage) -> i32
{
	i32 ret;
	const i8 * desc;
	usize n = *size;
	i8 * p = *buf;
	const mbedtls_x509_sequence * cur = extended_key_usage;
	const i8 * sep = "";
	while (cur != NULL)
	{
		if mbedtls_oid_get_extended_key_usage(&cur.buf, &desc) != 0
		{
			desc = "???";
		}
		ret = snprintf(p, n, "%s%s", sep, desc);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		sep = ", ";
		cur = cur.next;
	}
	*size = n;
	*buf = p;
	return 0;
}

pub fn mbedtls_x509_crt_info(i8 * buf, usize size, const i8 * prefix, const mbedtls_x509_crt * crt) -> i32
{
	i32 ret;
	usize n;
	i8 * p;
	i8 key_size_str[18];
	p = buf;
	n = size;
	if NULL == crt
	{
		ret = snprintf(p, n, "\nCertificate is uninitialised!\n");
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		return (int) (size - n);
	}
	ret = snprintf(p, n, "%scert. version     : %d\n", prefix, crt.version);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "%sserial number     : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_serial_gets(p, n, &crt.serial);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%sissuer name       : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_dn_gets(p, n, &crt.issuer);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%ssubject name      : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_dn_gets(p, n, &crt.subject);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%sissued  on        : "
				   "%04d-%02d-%02d %02d:%02d:%02d",
				   prefix, crt.valid_from.year, crt.valid_from.mon, crt.valid_from.day, crt.valid_from.hour, crt.valid_from.min, crt.valid_from.sec);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%sexpires on        : "
				   "%04d-%02d-%02d %02d:%02d:%02d",
				   prefix, crt.valid_to.year, crt.valid_to.mon, crt.valid_to.day, crt.valid_to.hour, crt.valid_to.min, crt.valid_to.sec);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%si32 using      : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_sig_alg_gets(p, n, &crt.sig_oid, crt.sig_pk, crt.sig_md, crt.sig_opts);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	if (ret = mbedtls_x509_key_size_helper(key_size_str, 18, mbedtls_pk_get_name(&crt.pk))) != 0
	{
		return ret;
	}
	ret = snprintf(p, n, "\n%s%-"
				   "18"
				   "s: %d bits",
				   prefix, key_size_str, (int) mbedtls_pk_get_bitlen(&crt.pk));
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	if crt.ext_types & (1 << 8)
	{
		ret = snprintf(p, n, "\n%sbasic constraints : CA=%s", prefix, crt.ca_istrue ? "true" : "false");
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		if crt.max_pathlen > 0
		{
			ret = snprintf(p, n, ", max_pathlen=%d", crt.max_pathlen - 1);
			do
			{
				if ret < 0 || (usize) ret >= n
				{
					return -0x2980;
				}
				n -= (usize) ret;
				p += (usize) ret;
			}
			while (0);
		}
	}
	if crt.ext_types & (1 << 5)
	{
		ret = snprintf(p, n, "\n%ssubject alt name  : ", prefix);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		if (ret = x509_info_subject_alt_name(&p, &n, &crt.subject_alt_names)) != 0
		{
			return ret;
		}
	}
	if crt.ext_types & (1 << 16)
	{
		ret = snprintf(p, n, "\n%scert. type        : ", prefix);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		if (ret = x509_info_cert_type(&p, &n, crt.ns_cert_type)) != 0
		{
			return ret;
		}
	}
	if crt.ext_types & (1 << 2)
	{
		ret = snprintf(p, n, "\n%skey usage         : ", prefix);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		if (ret = x509_info_key_usage(&p, &n, crt.key_usage)) != 0
		{
			return ret;
		}
	}
	if crt.ext_types & (1 << 11)
	{
		ret = snprintf(p, n, "\n%sext key usage     : ", prefix);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		if (ret = x509_info_ext_key_usage(&p, &n, &crt.ext_key_usage)) != 0
		{
			return ret;
		}
	}
	ret = snprintf(p, n, "\n");
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	return (int) (size - n);
}

struct x509_crt_verify_string
{
	i32 code;
	const i8 * string;
};
static const struct x509_crt_verify_string x509_crt_verify_strings[] = {{0x01, "The certificate validity has expired"}, {0x02, "The certificate has been revoked (is on a CRL)"}, {0x04, "The certificate Common Name (CN) does not match with the expected CN"}, {0x08, "The certificate is not correctly i32 by the trusted CA"}, {0x10, "The CRL is not correctly i32 by the trusted CA"}, {0x20, "The CRL is expired"}, {0x40, "Certificate was missing"}, {0x80, "Certificate verification was skipped"}, {0x0100, "Other reason (can be used by verify callback)"}, {0x0200, "The certificate validity starts in the future"}, {0x0400, "The CRL is from the future"}, {0x0800, "Usage does not match the keyUsage extension"}, {0x1000, "Usage does not match the extendedKeyUsage extension"}, {0x2000, "Usage does not match the nsCertType extension"}, {0x4000, "The certificate is i32 with an unacceptable hash."}, {0x8000, "The certificate is i32 with an unacceptable PK alg (eg RSA vs ECDSA)."}, {0x010000, "The certificate is i32 with an unacceptable key (eg bad curve, RSA too short)."}, {0x020000, "The CRL is i32 with an unacceptable hash."}, {0x040000, "The CRL is i32 with an unacceptable PK alg (eg RSA vs ECDSA)."}, {0x080000, "The CRL is i32 with an unacceptable key (eg bad curve, RSA too short)."}, {0, NULL}};
pub fn mbedtls_x509_crt_verify_info(i8 * buf, usize size, const i8 * prefix, u32 flags) -> i32
{
	i32 ret;
	const struct x509_crt_verify_string * cur;
	i8 * p = buf;
	usize n = size;
	for (cur = x509_crt_verify_strings; cur.string != NULL; cur++)
	{
		if (flags & cur.code) == 0
		{
			continue;
		}
		ret = snprintf(p, n, "%s%s\n", prefix, cur.string);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
		flags ^= cur.code;
	}
	if flags != 0
	{
		ret = snprintf(p, n, "%sUnknown reason "
					   "(this should not happen)\n",
					   prefix);
		do
		{
			if ret < 0 || (usize) ret >= n
			{
				return -0x2980;
			}
			n -= (usize) ret;
			p += (usize) ret;
		}
		while (0);
	}
	return (int) (size - n);
}

pub fn mbedtls_x509_crt_check_key_usage(const mbedtls_x509_crt * crt, u32 usage) -> i32
{
	u32 usage_must, usage_may;
	u32 may_mask = (0x01) | (0x8000);
	if (crt.ext_types & (1 << 2)) == 0
	{
		return 0;
	}
	usage_must = usage & ~may_mask;
	if ((crt.key_usage & ~may_mask) & usage_must) != usage_must
	{
		return -0x2800;
	}
	usage_may = usage & may_mask;
	if ((crt.key_usage & may_mask) | usage_may) != usage_may
	{
		return -0x2800;
	}
	return 0;
}

pub fn mbedtls_x509_crt_check_extended_key_usage(const mbedtls_x509_crt * crt, const i8 * usage_oid, usize usage_len) -> i32
{
	const mbedtls_x509_sequence * cur;
	if (crt.ext_types & (1 << 11)) == 0
	{
		return 0;
	}
	for (cur = &crt.ext_key_usage; cur != NULL; cur = cur.next)
	{
		const mbedtls_x509_buf * cur_oid = &cur.buf;
		if cur_oid.len == usage_len && memcmp(cur_oid.p, usage_oid, usage_len) == 0
		{
			return 0;
		}
		if ((((sizeof("\x55"
					  "\x1D"
					  "\x25"
					  "\x00") -
				1) != (cur_oid)->len) ||
				memcmp(("\x55"
						"\x1D"
						"\x25"
						"\x00"),
					   (cur_oid)->p, (cur_oid)->len) != 0) == 0)
		{
			return 0;
		}
	}
	return -0x2800;
}

pub fn mbedtls_x509_crt_is_revoked(const mbedtls_x509_crt * crt, const mbedtls_x509_crl * crl) -> i32
{
	const mbedtls_x509_crl_entry * cur = &crl.entry;
	while (cur != NULL && cur.serial.len != 0)
	{
		if crt.serial.len == cur.serial.len && memcmp(crt.serial.p, cur.serial.p, crt.serial.len) == 0
		{
			if mbedtls_x509_time_is_past(&cur.revocation_date)
			{
				return 1;
			}
		}
		cur = cur.next;
	}
	return 0;
}

fn x509_crt_verifycrl(mbedtls_x509_crt * crt, mbedtls_x509_crt * ca, mbedtls_x509_crl * crl_list, const mbedtls_x509_crt_profile * profile) -> i32
{
	i32 flags = 0;
	u8 hash[64];
	const mbedtls_md_info_t * md_info;
	if ca == NULL
	{
		return flags;
	}
	while (crl_list != NULL)
	{
		if crl_list.version == 0 || crl_list.issuer_raw.len != ca.subject_raw.len || memcmp(crl_list.issuer_raw.p, ca.subject_raw.p, crl_list.issuer_raw.len) != 0
		{
			crl_list = crl_list.next;
			continue;
		}
		if mbedtls_x509_crt_check_key_usage(ca, (0x02)) != 0
		{
			flags |= 0x10;
			break;

		}
		if x509_profile_check_md_alg(profile, crl_list.sig_md) != 0
		{
			flags |= 0x020000;
		}
		if x509_profile_check_pk_alg(profile, crl_list.sig_pk) != 0
		{
			flags |= 0x040000;
		}
		md_info = mbedtls_md_info_from_type(crl_list.sig_md);
		if md_info == NULL
		{
			flags |= 0x10;
			break;

		}
		mbedtls_md(md_info, crl_list.tbs.p, crl_list.tbs.len, hash);
		if x509_profile_check_key(profile, crl_list.sig_pk, &ca.pk) != 0
		{
			flags |= 0x010000;
		}
		if mbedtls_pk_verify_ext(crl_list.sig_pk, crl_list.sig_opts, &ca.pk, crl_list.sig_md, hash, mbedtls_md_get_size(md_info), crl_list.sig.p, crl_list.sig.len) != 0
		{
			flags |= 0x10;
			break;

		}
		if mbedtls_x509_time_is_past(&crl_list.next_update)
		{
			flags |= 0x20;
		}
		if mbedtls_x509_time_is_future(&crl_list.this_update)
		{
			flags |= 0x0400;
		}
		if mbedtls_x509_crt_is_revoked(crt, crl_list)
		{
			flags |= 0x02;
			break;

		}
		crl_list = crl_list.next;
	}
	return flags;
}

fn x509_memcasecmp(const void * s1, const void * s2, usize len) -> i32
{
	usize i;
	u8 diff;
	const u8 *n1 = s1, *n2 = s2;
	for (i = 0; i < len; i++)
	{
		diff = n1[i] ^ n2[i];
		if diff == 0
		{
			continue;
		}
		if diff == 32 && ((n1[i] >= 'a' && n1[i] <= 'z') || (n1[i] >= 'A' && n1[i] <= 'Z'))
		{
			continue;
		}
		return -1;
	}
	return 0;
}

fn x509_check_wildcard(const i8 * cn, mbedtls_x509_buf * name) -> i32
{
	usize i;
	usize cn_idx = 0, cn_len = strlen(cn);
	if name.len < 3 || name.p[0] != '*' || name.p[1] != '.'
	{
		return 0;
	}
	for (i = 0; i < cn_len; ++i)
	{
		if cn[i] == '.'
		{
			cn_idx = i;
			break;

		}
	}
	if cn_idx == 0
	{
		return -1;
	}
	if cn_len - cn_idx == name.len - 1 && x509_memcasecmp(name.p + 1, cn + cn_idx, name.len - 1) == 0
	{
		return 0;
	}
	return -1;
}

fn x509_string_cmp(const mbedtls_x509_buf * a, const mbedtls_x509_buf * b) -> i32
{
	if a.tag == b.tag && a.len == b.len && memcmp(a.p, b.p, b.len) == 0
	{
		return 0;
	}
	if (a.tag == 0x0C || a.tag == 0x13) && (b.tag == 0x0C || b.tag == 0x13) && a.len == b.len && x509_memcasecmp(a.p, b.p, b.len) == 0
	{
		return 0;
	}
	return -1;
}

fn x509_name_cmp(const mbedtls_x509_name * a, const mbedtls_x509_name * b) -> i32
{
	while (a != NULL || b != NULL)
	{
		if a == NULL || b == NULL
		{
			return -1;
		}
		if a.oid.tag != b.oid.tag || a.oid.len != b.oid.len || memcmp(a.oid.p, b.oid.p, b.oid.len) != 0
		{
			return -1;
		}
		if x509_string_cmp(&a.val, &b.val) != 0
		{
			return -1;
		}
		if a.next_merged != b.next_merged
		{
			return -1;
		}
		a = a.next;
		b = b.next;
	}
	return 0;
}

fn x509_crt_check_parent(const mbedtls_x509_crt * child, const mbedtls_x509_crt * parent, i32 top, i32 bottom) -> i32
{
	i32 need_ca_bit;
	if x509_name_cmp(&child.issuer, &parent.subject) != 0
	{
		return -1;
	}
	need_ca_bit = 1;
	if top && parent.version < 3
	{
		need_ca_bit = 0;
	}
	if top && bottom && child.raw.len == parent.raw.len && memcmp(child.raw.p, parent.raw.p, child.raw.len) == 0
	{
		need_ca_bit = 0;
	}
	if need_ca_bit && !parent.ca_istrue
	{
		return -1;
	}
	if need_ca_bit && mbedtls_x509_crt_check_key_usage(parent, (0x04)) != 0
	{
		return -1;
	}
	return 0;
}

fn x509_crt_verify_top(mbedtls_x509_crt * child, mbedtls_x509_crt * trust_ca, mbedtls_x509_crl * ca_crl, const mbedtls_x509_crt_profile * profile, i32 path_cnt, i32 self_cnt, u32 * flags, i32 (*f_vrfy)(void *, mbedtls_x509_crt *, int, u32 *), void * p_vrfy) -> i32
{
	i32 ret;
	u32 ca_flags = 0;
	i32 check_path_cnt;
	u8 hash[64];
	const mbedtls_md_info_t * md_info;
	if mbedtls_x509_time_is_past(&child.valid_to)
	{
		*flags |= 0x01;
	}
	if mbedtls_x509_time_is_future(&child.valid_from)
	{
		*flags |= 0x0200;
	}
	if x509_profile_check_md_alg(profile, child.sig_md) != 0
	{
		*flags |= 0x4000;
	}
	if x509_profile_check_pk_alg(profile, child.sig_pk) != 0
	{
		*flags |= 0x8000;
	}
	*flags |= 0x08;
	md_info = mbedtls_md_info_from_type(child.sig_md);
	if md_info == NULL
	{
		trust_ca = NULL;
	}
	else
	{
		mbedtls_md(md_info, child.tbs.p, child.tbs.len, hash);
	}
	for (; trust_ca != NULL; trust_ca = trust_ca.next)
	{
		if x509_crt_check_parent(child, trust_ca, 1, path_cnt == 0) != 0
		{
			continue;
		}
		check_path_cnt = path_cnt + 1;
		if child.subject_raw.len == trust_ca.subject_raw.len && memcmp(child.subject_raw.p, trust_ca.subject_raw.p, child.issuer_raw.len) == 0
		{
			check_path_cnt--;
		}
		if trust_ca.max_pathlen > 0 && trust_ca.max_pathlen < check_path_cnt - self_cnt
		{
			continue;
		}
		if mbedtls_x509_time_is_past(&trust_ca.valid_to)
		{
			continue;
		}
		if mbedtls_x509_time_is_future(&trust_ca.valid_from)
		{
			continue;
		}
		if mbedtls_pk_verify_ext(child.sig_pk, child.sig_opts, &trust_ca.pk, child.sig_md, hash, mbedtls_md_get_size(md_info), child.sig.p, child.sig.len) != 0
		{
			continue;
		}
		*flags &= ~0x08;
		if x509_profile_check_key(profile, child.sig_pk, &trust_ca.pk) != 0
		{
			*flags |= 0x010000;
		}
		break;

	}
	if trust_ca != NULL && (child.subject_raw.len != trust_ca.subject_raw.len || memcmp(child.subject_raw.p, trust_ca.subject_raw.p, child.issuer_raw.len) != 0)
	{
		*flags |= x509_crt_verifycrl(child, trust_ca, ca_crl, profile);
		if NULL != f_vrfy
		{
			if (ret = f_vrfy(p_vrfy, trust_ca, path_cnt + 1, &ca_flags)) != 0
			{
				return ret;
			}
		}
	}
	if NULL != f_vrfy
	{
		if (ret = f_vrfy(p_vrfy, child, path_cnt, flags)) != 0
		{
			return ret;
		}
	}
	*flags |= ca_flags;
	return 0;
}

fn x509_crt_verify_child(mbedtls_x509_crt * child, mbedtls_x509_crt * parent, mbedtls_x509_crt * trust_ca, mbedtls_x509_crl * ca_crl, const mbedtls_x509_crt_profile * profile, i32 path_cnt, i32 self_cnt, u32 * flags, i32 (*f_vrfy)(void *, mbedtls_x509_crt *, int, u32 *), void * p_vrfy) -> i32
{
	i32 ret;
	u32 parent_flags = 0;
	u8 hash[64];
	mbedtls_x509_crt * grandparent;
	const mbedtls_md_info_t * md_info;
	if (path_cnt != 0) && x509_name_cmp(&child.issuer, &child.subject) == 0
	{
		self_cnt++;
	}
	if 1 + path_cnt > 8
	{
		*flags |= 0x08;
		return -0x2700;
	}
	if mbedtls_x509_time_is_past(&child.valid_to)
	{
		*flags |= 0x01;
	}
	if mbedtls_x509_time_is_future(&child.valid_from)
	{
		*flags |= 0x0200;
	}
	if x509_profile_check_md_alg(profile, child.sig_md) != 0
	{
		*flags |= 0x4000;
	}
	if x509_profile_check_pk_alg(profile, child.sig_pk) != 0
	{
		*flags |= 0x8000;
	}
	md_info = mbedtls_md_info_from_type(child.sig_md);
	if md_info == NULL
	{
		*flags |= 0x08;
	}
	else
	{
		mbedtls_md(md_info, child.tbs.p, child.tbs.len, hash);
		if x509_profile_check_key(profile, child.sig_pk, &parent.pk) != 0
		{
			*flags |= 0x010000;
		}
		if mbedtls_pk_verify_ext(child.sig_pk, child.sig_opts, &parent.pk, child.sig_md, hash, mbedtls_md_get_size(md_info), child.sig.p, child.sig.len) != 0
		{
			*flags |= 0x08;
		}
	}
	*flags |= x509_crt_verifycrl(child, parent, ca_crl, profile);
	for (grandparent = trust_ca; grandparent != NULL; grandparent = grandparent.next)
	{
		if x509_crt_check_parent(parent, grandparent, 0, path_cnt == 0) == 0
		{
			break;

		}
	}
	if grandparent != NULL
	{
		ret = x509_crt_verify_top(parent, grandparent, ca_crl, profile, path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy);
		if ret != 0
		{
			return ret;
		}
	}
	else
	{
		for (grandparent = parent.next; grandparent != NULL; grandparent = grandparent.next)
		{
			if grandparent.max_pathlen > 0 && grandparent.max_pathlen < 2 + path_cnt - self_cnt
			{
				continue;
			}
			if x509_crt_check_parent(parent, grandparent, 0, path_cnt == 0) == 0
			{
				break;

			}
		}
		if grandparent != NULL
		{
			ret = x509_crt_verify_child(parent, grandparent, trust_ca, ca_crl, profile, path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy);
			if ret != 0
			{
				return ret;
			}
		}
		else
		{
			ret = x509_crt_verify_top(parent, trust_ca, ca_crl, profile, path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy);
			if ret != 0
			{
				return ret;
			}
		}
	}
	if NULL != f_vrfy
		if (ret = f_vrfy(p_vrfy, child, path_cnt, flags)) != 0
		{
			return ret;
		}
	*flags |= parent_flags;
	return 0;
}

pub fn mbedtls_x509_crt_verify(mbedtls_x509_crt * crt, mbedtls_x509_crt * trust_ca, mbedtls_x509_crl * ca_crl, const i8 * cn, u32 * flags, i32 (*f_vrfy)(void *, mbedtls_x509_crt *, int, u32 *), void * p_vrfy) -> i32
{
	return mbedtls_x509_crt_verify_with_profile(crt, trust_ca, ca_crl, &mbedtls_x509_crt_profile_default, cn, flags, f_vrfy, p_vrfy);
}

pub fn mbedtls_x509_crt_verify_with_profile(mbedtls_x509_crt * crt, mbedtls_x509_crt * trust_ca, mbedtls_x509_crl * ca_crl, const mbedtls_x509_crt_profile * profile, const i8 * cn, u32 * flags, i32 (*f_vrfy)(void *, mbedtls_x509_crt *, int, u32 *), void * p_vrfy) -> i32
{
	usize cn_len;
	i32 ret;
	i32 pathlen = 0, selfi32 = 0;
	mbedtls_x509_crt * parent;
	mbedtls_x509_name * name;
	mbedtls_x509_sequence * cur = NULL;
	mbedtls_pk_type_t pk_type;
	if profile == NULL
	{
		return -0x2800;
	}
	*flags = 0;
	if cn != NULL
	{
		name = &crt.subject;
		cn_len = strlen(cn);
		if crt.ext_types & (1 << 5)
		{
			cur = &crt.subject_alt_names;
			while (cur != NULL)
			{
				if cur.buf.len == cn_len && x509_memcasecmp(cn, cur.buf.p, cn_len) == 0
				{
					break;

				}
				if cur.buf.len > 2 && memcmp(cur.buf.p, "*.", 2) == 0 && x509_check_wildcard(cn, &cur.buf) == 0
				{
					break;

				}
				cur = cur.next;
			}
			if cur == NULL
			{
				*flags |= 0x04;
			}
		}
		else
		{
			while (name != NULL)
			{
				if ((((sizeof("\x55"
							  "\x04"
							  "\x03") -
						1) != (&name.oid)->len) ||
						memcmp(("\x55"
								"\x04"
								"\x03"),
							   (&name.oid)->p, (&name.oid)->len) != 0) == 0)
				{
					if name.val.len == cn_len && x509_memcasecmp(name.val.p, cn, cn_len) == 0
					{
						break;

					}
					if name.val.len > 2 && memcmp(name.val.p, "*.", 2) == 0 && x509_check_wildcard(cn, &name.val) == 0
					{
						break;

					}
				}
				name = name.next;
			}
			if name == NULL
			{
				*flags |= 0x04;
			}
		}
	}
	pk_type = mbedtls_pk_get_type(&crt.pk);
	if x509_profile_check_pk_alg(profile, pk_type) != 0
	{
		*flags |= 0x8000;
	}
	if x509_profile_check_key(profile, pk_type, &crt.pk) != 0
	{
		*flags |= 0x010000;
	}
	for (parent = trust_ca; parent != NULL; parent = parent.next)
	{
		if x509_crt_check_parent(crt, parent, 0, pathlen == 0) == 0
		{
			break;

		}
	}
	if parent != NULL
	{
		ret = x509_crt_verify_top(crt, parent, ca_crl, profile, pathlen, selfsigned, flags, f_vrfy, p_vrfy);
		if ret != 0
		{
			return ret;
		}
	}
	else
	{
		for (parent = crt.next; parent != NULL; parent = parent.next)
			if x509_crt_check_parent(crt, parent, 0, pathlen == 0) == 0
			{
				break;

			}
		if parent != NULL
		{
			ret = x509_crt_verify_child(crt, parent, trust_ca, ca_crl, profile, pathlen, selfsigned, flags, f_vrfy, p_vrfy);
			if ret != 0
			{
				return ret;
			}
		}
		else
		{
			ret = x509_crt_verify_top(crt, trust_ca, ca_crl, profile, pathlen, selfsigned, flags, f_vrfy, p_vrfy);
			if ret != 0
			{
				return ret;
			}
		}
	}
	if *flags != 0
	{
		return -0x2700;
	}
	return 0;
}

pub fn mbedtls_x509_crt_init(mbedtls_x509_crt * crt)
{
	memset(crt, 0, sizeof(mbedtls_x509_crt));
}

pub fn mbedtls_x509_crt_free(mbedtls_x509_crt * crt)
{
	mbedtls_x509_crt * cert_cur = crt;
	mbedtls_x509_crt * cert_prv;
	mbedtls_x509_name * name_cur;
	mbedtls_x509_name * name_prv;
	mbedtls_x509_sequence * seq_cur;
	mbedtls_x509_sequence * seq_prv;
	if crt == NULL
	{
		return;
	}
	do
	{
		mbedtls_pk_free(&cert_cur.pk);
		mbedtls_free(cert_cur.sig_opts);
		name_cur = cert_cur.issuer.next;
		while (name_cur != NULL)
		{
			name_prv = name_cur;
			name_cur = name_cur.next;
			zeroize(name_prv, sizeof(mbedtls_x509_name));
			mbedtls_free(name_prv);
		}
		name_cur = cert_cur.subject.next;
		while (name_cur != NULL)
		{
			name_prv = name_cur;
			name_cur = name_cur.next;
			zeroize(name_prv, sizeof(mbedtls_x509_name));
			mbedtls_free(name_prv);
		}
		seq_cur = cert_cur.ext_key_usage.next;
		while (seq_cur != NULL)
		{
			seq_prv = seq_cur;
			seq_cur = seq_cur.next;
			zeroize(seq_prv, sizeof(mbedtls_x509_sequence));
			mbedtls_free(seq_prv);
		}
		seq_cur = cert_cur.subject_alt_names.next;
		while (seq_cur != NULL)
		{
			seq_prv = seq_cur;
			seq_cur = seq_cur.next;
			zeroize(seq_prv, sizeof(mbedtls_x509_sequence));
			mbedtls_free(seq_prv);
		}
		if cert_cur.raw.p != NULL
		{
			zeroize(cert_cur.raw.p, cert_cur.raw.len);
			mbedtls_free(cert_cur.raw.p);
		}
		cert_cur = cert_cur.next;
	}
	while (cert_cur != NULL);
	cert_cur = crt;
	do
	{
		cert_prv = cert_cur;
		cert_cur = cert_cur.next;
		zeroize(cert_prv, sizeof(mbedtls_x509_crt));
		if cert_prv != crt
		{
			mbedtls_free(cert_prv);
		}
	}
	while (cert_cur != NULL);
}

typedef struct mbedtls_x509_csr
{
	mbedtls_x509_buf raw;
	mbedtls_x509_buf cri;
	i32 version;
	mbedtls_x509_buf subject_raw;
	mbedtls_x509_name subject;
	mbedtls_pk_context pk;
	mbedtls_x509_buf sig_oid;
	mbedtls_x509_buf sig;
	mbedtls_md_type_t sig_md;
	mbedtls_pk_type_t sig_pk;
	void * sig_opts;
} mbedtls_x509_csr;
typedef struct mbedtls_x509write_csr
{
	mbedtls_pk_context * key;
	mbedtls_asn1_named_data * subject;
	mbedtls_md_type_t md_alg;
	mbedtls_asn1_named_data * extensions;
} mbedtls_x509write_csr;

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

fn x509_csr_get_version(u8 ** p, const u8 * end, i32 * ver) -> i32
{
	i32 ret;
	if (ret = mbedtls_asn1_get_int(p, end, ver)) != 0
	{
		if ret == -0x0062
		{
			*ver = 0;
			return 0;
		}
		return -0x2200 + ret;
	}
	return 0;
}

pub fn mbedtls_x509_csr_parse_der(mbedtls_x509_csr * csr, const u8 * buf, usize buflen) -> i32
{
	i32 ret;
	usize len;
	u8 *p, *end;
	mbedtls_x509_buf sig_params;
	memset(&sig_params, 0, sizeof(mbedtls_x509_buf));
	if csr == NULL || buf == NULL || buflen == 0
	{
		return -0x2800;
	}
	mbedtls_x509_csr_init(csr);
	p = mbedtls_calloc(1, len = buflen);
	if p == NULL
	{
		return -0x2880;
	}
	memcpy(p, buf, buflen);
	csr.raw.p = p;
	csr.raw.len = len;
	end = p + len;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return -0x2180;
	}
	if len != (usize)(end - p)
	{
		mbedtls_x509_csr_free(csr);
		return -0x2180 + -0x0066;
	}
	csr.cri.p = p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return -0x2180 + ret;
	}
	end = p + len;
	csr.cri.len = end - csr.cri.p;
	if (ret = x509_csr_get_version(&p, end, &csr.version)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return ret;
	}
	csr.version++;
	if csr.version != 1
	{
		mbedtls_x509_csr_free(csr);
		return -0x2580;
	}
	csr.subject_raw.p = p;
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return -0x2180 + ret;
	}
	if (ret = mbedtls_x509_get_name(&p, p + len, &csr.subject)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return ret;
	}
	csr.subject_raw.len = p - csr.subject_raw.p;
	if (ret = mbedtls_pk_parse_subpubkey(&p, end, &csr.pk)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return ret;
	}
	if (ret = mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x80)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return -0x2180 + ret;
	}
	p += len;
	end = csr.raw.p + csr.raw.len;
	if (ret = mbedtls_x509_get_alg(&p, end, &csr.sig_oid, &sig_params)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return ret;
	}
	if (ret = mbedtls_x509_get_sig_alg(&csr.sig_oid, &sig_params, &csr.sig_md, &csr.sig_pk, &csr.sig_opts)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return -0x2600;
	}
	if (ret = mbedtls_x509_get_sig(&p, end, &csr.sig)) != 0
	{
		mbedtls_x509_csr_free(csr);
		return ret;
	}
	if p != end
	{
		mbedtls_x509_csr_free(csr);
		return -0x2180 + -0x0066;
	}
	return 0;
}

pub fn mbedtls_x509_csr_parse(mbedtls_x509_csr * csr, const u8 * buf, usize buflen) -> i32
{
	i32 ret;
	usize use_len;
	mbedtls_pem_context pem;
	if csr == NULL || buf == NULL || buflen == 0
	{
		return -0x2800;
	}
	mbedtls_pem_init(&pem);
	if buf[buflen - 1] != '\0'
	{
		ret = -0x1080;
	}
	else
	{
		ret = mbedtls_pem_read_buffer(&pem, "-----BEGIN CERTIFICATE REQUEST-----", "-----END CERTIFICATE REQUEST-----", buf, NULL, 0, &use_len);
	}
	if ret == 0
	{
		if (ret = mbedtls_x509_csr_parse_der(csr, pem.buf, pem.buflen)) != 0
		{
			return ret;
		}
		mbedtls_pem_free(&pem);
		return 0;
	}
	else
		if ret != -0x1080
		{
			mbedtls_pem_free(&pem);
			return ret;
		}
		else
		{
			return mbedtls_x509_csr_parse_der(csr, buf, buflen);
		}
}

pub fn mbedtls_x509_csr_parse_file(mbedtls_x509_csr * csr, const i8 * path) -> i32
{
	i32 ret;
	usize n;
	u8 * buf;
	if (ret = mbedtls_pk_load_file(path, &buf, &n)) != 0
	{
		return ret;
	}
	ret = mbedtls_x509_csr_parse(csr, buf, n);
	zeroize(buf, n);
	mbedtls_free(buf);
	return ret;
}

pub fn mbedtls_x509_csr_info(i8 * buf, usize size, const i8 * prefix, const mbedtls_x509_csr * csr) -> i32
{
	i32 ret;
	usize n;
	i8 * p;
	i8 key_size_str[14];
	p = buf;
	n = size;
	ret = snprintf(p, n, "%sCSR version   : %d", prefix, csr.version);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%ssubject name  : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_dn_gets(p, n, &csr.subject);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = snprintf(p, n, "\n%si32 using  : ", prefix);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	ret = mbedtls_x509_sig_alg_gets(p, n, &csr.sig_oid, csr.sig_pk, csr.sig_md, csr.sig_opts);
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	if (ret = mbedtls_x509_key_size_helper(key_size_str, 14, mbedtls_pk_get_name(&csr.pk))) != 0
	{
		return ret;
	}
	ret = snprintf(p, n, "\n%s%-"
				   "14"
				   "s: %d bits\n",
				   prefix, key_size_str, (int) mbedtls_pk_get_bitlen(&csr.pk));
	do
	{
		if ret < 0 || (usize) ret >= n
		{
			return -0x2980;
		}
		n -= (usize) ret;
		p += (usize) ret;
	}
	while (0);
	return (int) (size - n);
}

pub fn mbedtls_x509_csr_init(mbedtls_x509_csr * csr)
{
	memset(csr, 0, sizeof(mbedtls_x509_csr));
}

pub fn mbedtls_x509_csr_free(mbedtls_x509_csr * csr)
{
	mbedtls_x509_name * name_cur;
	mbedtls_x509_name * name_prv;
	if csr == NULL
	{
		return;
	}
	mbedtls_pk_free(&csr.pk);
	mbedtls_free(csr.sig_opts);
	name_cur = csr.subject.next;
	while (name_cur != NULL)
	{
		name_prv = name_cur;
		name_cur = name_cur.next;
		zeroize(name_prv, sizeof(mbedtls_x509_name));
		mbedtls_free(name_prv);
	}
	if csr.raw.p != NULL
	{
		zeroize(csr.raw.p, csr.raw.len);
		mbedtls_free(csr.raw.p);
	}
	zeroize(csr, sizeof(mbedtls_x509_csr));
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_x509write_crt_init(mbedtls_x509write_cert * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_x509write_cert));
	mbedtls_mpi_init(&ctx.serial);
	ctx.version = 2;
}

pub fn mbedtls_x509write_crt_free(mbedtls_x509write_cert * ctx)
{
	mbedtls_mpi_free(&ctx.serial);
	mbedtls_asn1_free_named_data_list(&ctx.subject);
	mbedtls_asn1_free_named_data_list(&ctx.issuer);
	mbedtls_asn1_free_named_data_list(&ctx.extensions);
	zeroize(ctx, sizeof(mbedtls_x509write_cert));
}

pub fn mbedtls_x509write_crt_set_version(mbedtls_x509write_cert * ctx, i32 version)
{
	ctx.version = version;
}

pub fn mbedtls_x509write_crt_set_md_alg(mbedtls_x509write_cert * ctx, mbedtls_md_type_t md_alg)
{
	ctx.md_alg = md_alg;
}

pub fn mbedtls_x509write_crt_set_subject_key(mbedtls_x509write_cert * ctx, mbedtls_pk_context * key)
{
	ctx.subject_key = key;
}

pub fn mbedtls_x509write_crt_set_issuer_key(mbedtls_x509write_cert * ctx, mbedtls_pk_context * key)
{
	ctx.issuer_key = key;
}

pub fn mbedtls_x509write_crt_set_subject_name(mbedtls_x509write_cert * ctx, const i8 * subject_name) -> i32
{
	return mbedtls_x509_string_to_names(&ctx.subject, subject_name);
}

pub fn mbedtls_x509write_crt_set_issuer_name(mbedtls_x509write_cert * ctx, const i8 * issuer_name) -> i32
{
	return mbedtls_x509_string_to_names(&ctx.issuer, issuer_name);
}

pub fn mbedtls_x509write_crt_set_serial(mbedtls_x509write_cert * ctx, const mbedtls_mpi * serial) -> i32
{
	i32 ret;
	if (ret = mbedtls_mpi_copy(&ctx.serial, serial)) != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_x509write_crt_set_validity(mbedtls_x509write_cert * ctx, const i8 * not_before, const i8 * not_after) -> i32
{
	if strlen(not_before) != 15 - 1 || strlen(not_after) != 15 - 1
	{
		return -0x2800;
	}
	strncpy(ctx.not_before, not_before, 15);
	strncpy(ctx.not_after, not_after, 15);
	ctx.not_before[15 - 1] = 'Z';
	ctx.not_after[15 - 1] = 'Z';
	return 0;
}

pub fn mbedtls_x509write_crt_set_extension(mbedtls_x509write_cert * ctx, const i8 * oid, usize oid_len, i32 critical, const u8 * val, usize val_len) -> i32
{
	return mbedtls_x509_set_extension(&ctx.extensions, oid, oid_len, critical, val, val_len);
}

pub fn mbedtls_x509write_crt_set_basic_constraints(mbedtls_x509write_cert * ctx, i32 is_ca, i32 max_pathlen) -> i32
{
	i32 ret;
	u8 buf[9];
	u8 * c = buf + sizeof(buf);
	usize len = 0;
	memset(buf, 0, sizeof(buf));
	if is_ca && max_pathlen > 127
	{
		return -0x2800;
	}
	if is_ca
	{
		if max_pathlen >= 0
		{
			do
			{
				if (ret = mbedtls_asn1_write_int(&c, buf, max_pathlen)) < 0
				{
					return ret;
				}
				else
				{
					len += ret;
				}
			}
			while (0);
		}
		do
		{
			if (ret = mbedtls_asn1_write_bool(&c, buf, 1)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return mbedtls_x509write_crt_set_extension(ctx, "\x55"
			"\x1D"
			"\x13",
			(sizeof("\x55"
					"\x1D"
					"\x13") -
			 1),
			0, buf + sizeof(buf) - len, len);
}

pub fn mbedtls_x509write_crt_set_subject_key_identifier(mbedtls_x509write_cert * ctx) -> i32
{
	i32 ret;
	u8 buf[1024 * 2 + 20];
	u8 * c = buf + sizeof(buf);
	usize len = 0;
	memset(buf, 0, sizeof(buf));
	do
	{
		if (ret = mbedtls_pk_write_pubkey(&c, buf, ctx.subject_key)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	mbedtls_sha1(buf + sizeof(buf) - len, len, buf + sizeof(buf) - 20);
	c = buf + sizeof(buf) - 20;
	len = 20;
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, buf, 0x04)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return mbedtls_x509write_crt_set_extension(ctx, "\x55"
			"\x1D"
			"\x0E",
			(sizeof("\x55"
					"\x1D"
					"\x0E") -
			 1),
			0, buf + sizeof(buf) - len, len);
}

pub fn mbedtls_x509write_crt_set_authority_key_identifier(mbedtls_x509write_cert * ctx) -> i32
{
	i32 ret;
	u8 buf[1024 * 2 + 20];
	u8 * c = buf + sizeof(buf);
	usize len = 0;
	memset(buf, 0, sizeof(buf));
	do
	{
		if (ret = mbedtls_pk_write_pubkey(&c, buf, ctx.issuer_key)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	mbedtls_sha1(buf + sizeof(buf) - len, len, buf + sizeof(buf) - 20);
	c = buf + sizeof(buf) - 20;
	len = 20;
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, buf, 0x80 | 0)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return mbedtls_x509write_crt_set_extension(ctx, "\x55"
			"\x1D"
			"\x23",
			(sizeof("\x55"
					"\x1D"
					"\x23") -
			 1),
			0, buf + sizeof(buf) - len, len);
}

pub fn mbedtls_x509write_crt_set_key_usage(mbedtls_x509write_cert * ctx, u32 key_usage) -> i32
{
	u8 buf[4], ku;
	u8 * c;
	i32 ret;
	if (key_usage & ~0xfe) != 0
	{
		return -0x2080;
	}
	c = buf + 4;
	ku = (i8) key_usage;
	if (ret = mbedtls_asn1_write_bitstring(&c, buf, &ku, 7)) != 4
	{
		return ret;
	}
	ret = mbedtls_x509write_crt_set_extension(ctx, "\x55"
			"\x1D"
			"\x0F",
			(sizeof("\x55"
					"\x1D"
					"\x0F") -
			 1),
			1, buf, 4);
	if ret != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_x509write_crt_set_ns_cert_type(mbedtls_x509write_cert * ctx, u8 ns_cert_type) -> i32
{
	u8 buf[4];
	u8 * c;
	i32 ret;
	c = buf + 4;
	if (ret = mbedtls_asn1_write_bitstring(&c, buf, &ns_cert_type, 8)) != 4
	{
		return ret;
	}
	ret = mbedtls_x509write_crt_set_extension(ctx, "\x60"
			"\x86\x48"
			"\x01"
			"\x86\xF8\x42"
			"\x01"
			"\x01",
			(sizeof("\x60"
					"\x86\x48"
					"\x01"
					"\x86\xF8\x42"
					"\x01"
					"\x01") -
			 1),
			0, buf, 4);
	if ret != 0
	{
		return ret;
	}
	return 0;
}

fn x509_write_time(u8 ** p, u8 * start, const i8 * time, usize size) -> i32
{
	i32 ret;
	usize len = 0;
	if time[0] == '2' && time[1] == '0' && time[2] < '5'
	{
		do
		{
			if (ret = mbedtls_asn1_write_raw_buffer(p, start, (const u8 *) time + 2, size - 2)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_tag(p, start, 0x17)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	else
	{
		do
		{
			if (ret = mbedtls_asn1_write_raw_buffer(p, start, (const u8 *) time, size)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_len(p, start, len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_tag(p, start, 0x18)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	return (int) len;
}

pub fn mbedtls_x509write_crt_der(mbedtls_x509write_cert * ctx, u8 * buf, usize size, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	const i8 * sig_oid;
	usize sig_oid_len = 0;
	u8 *c, *c2;
	u8 hash[64];
	u8 sig[1024];
	u8 tmp_buf[2048];
	usize sub_len = 0, pub_len = 0, sig_and_oid_len = 0, sig_len;
	usize len = 0;
	mbedtls_pk_type_t pk_alg;
	c = tmp_buf + sizeof(tmp_buf);
	pk_alg = mbedtls_pk_get_type(ctx.issuer_key);
	if pk_alg == MBEDTLS_PK_ECKEY
	{
		pk_alg = MBEDTLS_PK_ECDSA;
	}
	if (ret = mbedtls_oid_get_oid_by_sig_alg(pk_alg, ctx.md_alg, &sig_oid, &sig_oid_len)) != 0
	{
		return ret;
	}
	do
	{
		if (ret = mbedtls_x509_write_extensions(&c, tmp_buf, ctx.extensions)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x80 | 0x20 | 3)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_pk_write_pubkey_der(ctx.subject_key, tmp_buf, c - tmp_buf)) < 0
		{
			return ret;
		}
		else
		{
			pub_len += ret;
		}
	}
	while (0);
	c -= pub_len;
	len += pub_len;
	do
	{
		if (ret = mbedtls_x509_write_names(&c, tmp_buf, ctx.subject)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	sub_len = 0;
	do
	{
		if (ret = x509_write_time(&c, tmp_buf, ctx.not_after, 15)) < 0
		{
			return ret;
		}
		else
		{
			sub_len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = x509_write_time(&c, tmp_buf, ctx.not_before, 15)) < 0
		{
			return ret;
		}
		else
		{
			sub_len += ret;
		}
	}
	while (0);
	len += sub_len;
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, tmp_buf, sub_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_x509_write_names(&c, tmp_buf, ctx.issuer)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_algorithm_identifier(&c, tmp_buf, sig_oid, strlen(sig_oid), 0)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_mpi(&c, tmp_buf, &ctx.serial)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	sub_len = 0;
	do
	{
		if (ret = mbedtls_asn1_write_int(&c, tmp_buf, ctx.version)) < 0
		{
			return ret;
		}
		else
		{
			sub_len += ret;
		}
	}
	while (0);
	len += sub_len;
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, tmp_buf, sub_len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x80 | 0x20 | 0)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	mbedtls_md(mbedtls_md_info_from_type(ctx.md_alg), c, len, hash);
	if (ret = mbedtls_pk_sign(ctx.issuer_key, ctx.md_alg, hash, 0, sig, &sig_len, f_rng, p_rng)) != 0
	{
		return ret;
	}
	c2 = buf + size;
	do
	{
		if (ret = mbedtls_x509_write_sig(&c2, buf, sig_oid, sig_oid_len, sig, sig_len)) < 0
		{
			return ret;
		}
		else
		{
			sig_and_oid_len += ret;
		}
	}
	while (0);
	c2 -= len;
	memcpy(c2, c, len);
	len += sig_and_oid_len;
	do
	{
		if (ret = mbedtls_asn1_write_len(&c2, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c2, buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_x509write_crt_pem(mbedtls_x509write_cert * crt, u8 * buf, usize size, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	u8 output_buf[4096];
	usize olen = 0;
	if (ret = mbedtls_x509write_crt_der(crt, output_buf, sizeof(output_buf), f_rng, p_rng)) < 0
	{
		return ret;
	}
	if (ret = mbedtls_pem_write_buffer("-----BEGIN CERTIFICATE-----\n", "-----END CERTIFICATE-----\n", output_buf + sizeof(output_buf) - ret, ret, buf, size, &olen)) != 0
	{
		return ret;
	}
	return 0;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_x509write_csr_init(mbedtls_x509write_csr * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_x509write_csr));
}

pub fn mbedtls_x509write_csr_free(mbedtls_x509write_csr * ctx)
{
	mbedtls_asn1_free_named_data_list(&ctx.subject);
	mbedtls_asn1_free_named_data_list(&ctx.extensions);
	zeroize(ctx, sizeof(mbedtls_x509write_csr));
}

pub fn mbedtls_x509write_csr_set_md_alg(mbedtls_x509write_csr * ctx, mbedtls_md_type_t md_alg)
{
	ctx.md_alg = md_alg;
}

pub fn mbedtls_x509write_csr_set_key(mbedtls_x509write_csr * ctx, mbedtls_pk_context * key)
{
	ctx.key = key;
}

pub fn mbedtls_x509write_csr_set_subject_name(mbedtls_x509write_csr * ctx, const i8 * subject_name) -> i32
{
	return mbedtls_x509_string_to_names(&ctx.subject, subject_name);
}

pub fn mbedtls_x509write_csr_set_extension(mbedtls_x509write_csr * ctx, const i8 * oid, usize oid_len, const u8 * val, usize val_len) -> i32
{
	return mbedtls_x509_set_extension(&ctx.extensions, oid, oid_len, 0, val, val_len);
}

pub fn mbedtls_x509write_csr_set_key_usage(mbedtls_x509write_csr * ctx, u8 key_usage) -> i32
{
	u8 buf[4];
	u8 * c;
	i32 ret;
	c = buf + 4;
	if (ret = mbedtls_asn1_write_bitstring(&c, buf, &key_usage, 7)) != 4
	{
		return ret;
	}
	ret = mbedtls_x509write_csr_set_extension(ctx, "\x55"
			"\x1D"
			"\x0F",
			(sizeof("\x55"
					"\x1D"
					"\x0F") -
			 1),
			buf, 4);
	if ret != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_x509write_csr_set_ns_cert_type(mbedtls_x509write_csr * ctx, u8 ns_cert_type) -> i32
{
	u8 buf[4];
	u8 * c;
	i32 ret;
	c = buf + 4;
	if (ret = mbedtls_asn1_write_bitstring(&c, buf, &ns_cert_type, 8)) != 4
	{
		return ret;
	}
	ret = mbedtls_x509write_csr_set_extension(ctx, "\x60"
			"\x86\x48"
			"\x01"
			"\x86\xF8\x42"
			"\x01"
			"\x01",
			(sizeof("\x60"
					"\x86\x48"
					"\x01"
					"\x86\xF8\x42"
					"\x01"
					"\x01") -
			 1),
			buf, 4);
	if ret != 0
	{
		return ret;
	}
	return 0;
}

pub fn mbedtls_x509write_csr_der(mbedtls_x509write_csr * ctx, u8 * buf, usize size, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	const i8 * sig_oid;
	usize sig_oid_len = 0;
	u8 *c, *c2;
	u8 hash[64];
	u8 sig[1024];
	u8 tmp_buf[2048];
	usize pub_len = 0, sig_and_oid_len = 0, sig_len;
	usize len = 0;
	mbedtls_pk_type_t pk_alg;
	c = tmp_buf + sizeof(tmp_buf);
	do
	{
		if (ret = mbedtls_x509_write_extensions(&c, tmp_buf, ctx.extensions)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	if len
	{
		do
		{
			if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x10)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x11)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if ((ret = mbedtls_asn1_write_oid(&c, tmp_buf, "\x2a"
											  "\x86\x48"
											  "\x86\xf7\x0d"
											  "\x01"
											  "\x09"
											  "\x0e",
											  (sizeof("\x2a"
													  "\x86\x48"
													  "\x86\xf7\x0d"
													  "\x01"
													  "\x09"
													  "\x0e") -
											   1))) < 0)
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
		do
		{
			if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x10)) < 0
			{
				return ret;
			}
			else
			{
				len += ret;
			}
		}
		while (0);
	}
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x80)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_pk_write_pubkey_der(ctx.key, tmp_buf, c - tmp_buf)) < 0
		{
			return ret;
		}
		else
		{
			pub_len += ret;
		}
	}
	while (0);
	c -= pub_len;
	len += pub_len;
	do
	{
		if (ret = mbedtls_x509_write_names(&c, tmp_buf, ctx.subject)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_int(&c, tmp_buf, 0)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_len(&c, tmp_buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c, tmp_buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	mbedtls_md(mbedtls_md_info_from_type(ctx.md_alg), c, len, hash);
	pk_alg = mbedtls_pk_get_type(ctx.key);
	if pk_alg == MBEDTLS_PK_ECKEY
	{
		pk_alg = MBEDTLS_PK_ECDSA;
	}
	if (ret = mbedtls_pk_sign(ctx.key, ctx.md_alg, hash, 0, sig, &sig_len, f_rng, p_rng)) != 0 || (ret = mbedtls_oid_get_oid_by_sig_alg(pk_alg, ctx.md_alg, &sig_oid, &sig_oid_len)) != 0
	{
		return ret;
	}
	c2 = buf + size;
	do
	{
		if (ret = mbedtls_x509_write_sig(&c2, buf, sig_oid, sig_oid_len, sig, sig_len)) < 0
		{
			return ret;
		}
		else
		{
			sig_and_oid_len += ret;
		}
	}
	while (0);
	c2 -= len;
	memcpy(c2, c, len);
	len += sig_and_oid_len;
	do
	{
		if (ret = mbedtls_asn1_write_len(&c2, buf, len)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	do
	{
		if (ret = mbedtls_asn1_write_tag(&c2, buf, 0x20 | 0x10)) < 0
		{
			return ret;
		}
		else
		{
			len += ret;
		}
	}
	while (0);
	return (int) len;
}

pub fn mbedtls_x509write_csr_pem(mbedtls_x509write_csr * ctx, u8 * buf, usize size, i32 (*f_rng)(void *, u8 *, usize), void * p_rng) -> i32
{
	i32 ret;
	u8 output_buf[4096];
	usize olen = 0;
	if (ret = mbedtls_x509write_csr_der(ctx, output_buf, sizeof(output_buf), f_rng, p_rng)) < 0
	{
		return ret;
	}
	if (ret = mbedtls_pem_write_buffer("-----BEGIN CERTIFICATE REQUEST-----\n", "-----END CERTIFICATE REQUEST-----\n", output_buf + sizeof(output_buf) - ret, ret, buf, size, &olen)) != 0
	{
		return ret;
	}
	return 0;
}

fn zeroize(void * v, usize n)
{
	volatile u8 * p = v;
	while (n--)
	{
		*p++ = 0;
	}
}

pub fn mbedtls_xtea_init(mbedtls_xtea_context * ctx)
{
	memset(ctx, 0, sizeof(mbedtls_xtea_context));
}

pub fn mbedtls_xtea_free(mbedtls_xtea_context * ctx)
{
	if ctx == NULL
	{
		return;
	}
	zeroize(ctx, sizeof(mbedtls_xtea_context));
}

pub fn mbedtls_xtea_setup(mbedtls_xtea_context * ctx, const u8 key[16])
{
	i32 i;
	memset(ctx, 0, sizeof(mbedtls_xtea_context));
	for (i = 0; i < 4; i++)
	{
		{
			(ctx.k[i]) = ((u32)(key)[(i << 2)] << 24) | ((u32)(key)[(i << 2) + 1] << 16) | ((u32)(key)[(i << 2) + 2] << 8) | ((u32)(key)[(i << 2) + 3]);
		};
	}
}

pub fn mbedtls_xtea_crypt_ecb(mbedtls_xtea_context * ctx, i32 mode, const u8 input[8], u8 output[8]) -> i32
{
	u32 *k, v0, v1, i;
	k = ctx.k;
	{
		(v0) = ((u32)(input)[(0)] << 24) | ((u32)(input)[(0) + 1] << 16) | ((u32)(input)[(0) + 2] << 8) | ((u32)(input)[(0) + 3]);
	};
	{
		(v1) = ((u32)(input)[(4)] << 24) | ((u32)(input)[(4) + 1] << 16) | ((u32)(input)[(4) + 2] << 8) | ((u32)(input)[(4) + 3]);
	};
	if mode == 1
	{
		u32 sum = 0, delta = 0x9E3779B9;
		for (i = 0; i < 32; i++)
		{
			v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
			sum += delta;
			v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum >> 11) & 3]);
		}
	}
	else
	{
		u32 delta = 0x9E3779B9, sum = delta * 32;
		for (i = 0; i < 32; i++)
		{
			v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum >> 11) & 3]);
			sum -= delta;
			v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
		}
	}
	{
		(output)[(0)] = (i8) ((v0) >> 24);
		(output)[(0) + 1] = (i8) ((v0) >> 16);
		(output)[(0) + 2] = (i8) ((v0) >> 8);
		(output)[(0) + 3] = (i8) ((v0));
	};
	{
		(output)[(4)] = (i8) ((v1) >> 24);
		(output)[(4) + 1] = (i8) ((v1) >> 16);
		(output)[(4) + 2] = (i8) ((v1) >> 8);
		(output)[(4) + 3] = (i8) ((v1));
	};
	return 0;
}

pub fn mbedtls_xtea_crypt_cbc(mbedtls_xtea_context * ctx, i32 mode, usize length, u8 iv[8], const u8 * input, u8 * output) -> i32
{
	i32 i;
	u8 temp[8];
	if length % 8
	{
		return -0x0028;
	}
	if mode == 0
	{
		while (length > 0)
		{
			memcpy(temp, input, 8);
			mbedtls_xtea_crypt_ecb(ctx, mode, input, output);
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (output[i] ^ iv[i]);
			}
			memcpy(iv, temp, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	else
	{
		while (length > 0)
		{
			for (i = 0; i < 8; i++)
			{
				output[i] = (i8) (input[i] ^ iv[i]);
			}
			mbedtls_xtea_crypt_ecb(ctx, mode, output, output);
			memcpy(iv, output, 8);
			input += 8;
			output += 8;
			length -= 8;
		}
	}
	return 0;
}

static const u8 xtea_test_key[6][16] = {{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}, {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}, {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
static const u8 xtea_test_pt[6][8] = {{0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48}, {0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41}, {0x5a, 0x5b, 0x6e, 0x27, 0x89, 0x48, 0xd7, 0x7f}, {0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48}, {0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41}, {0x70, 0xe1, 0x22, 0x5d, 0x6e, 0x4e, 0x76, 0x55}};
static const u8 xtea_test_ct[6][8] = {{0x49, 0x7d, 0xf3, 0xd0, 0x72, 0x61, 0x2c, 0xb5}, {0xe7, 0x8f, 0x2d, 0x13, 0x74, 0x43, 0x41, 0xd8}, {0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41}, {0xa0, 0x39, 0x05, 0x89, 0xf8, 0xb8, 0xef, 0xa5}, {0xed, 0x23, 0x37, 0x5a, 0x82, 0x1a, 0x8c, 0x2d}, {0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41}};
pub fn mbedtls_xtea_self_test(i32 verbose) -> i32
{
	i32 i, ret = 0;
	u8 buf[8];
	mbedtls_xtea_context ctx;
	mbedtls_xtea_init(&ctx);
	for (i = 0; i < 6; i++)
	{
		if verbose != 0
		{
			printf("  XTEA test #%d: ", i + 1);
		}
		memcpy(buf, xtea_test_pt[i], 8);
		mbedtls_xtea_setup(&ctx, xtea_test_key[i]);
		mbedtls_xtea_crypt_ecb(&ctx, 1, buf, buf);
		if memcmp(buf, xtea_test_ct[i], 8) != 0
		{
			if verbose != 0
			{
				printf("failed\n");
			}
			ret = 1;
			goto exit;
		}
		if verbose != 0
		{
			printf("passed\n");
		}
	}
	if verbose != 0
	{
		printf("\n");
	}
exit:
	mbedtls_xtea_free(&ctx);
	return ret;
}

